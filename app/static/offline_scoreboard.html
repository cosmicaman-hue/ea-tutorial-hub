<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>EXCEL ACADEMY LEADERSHIP BOARD - Offline System</title>
    <link rel="manifest" href="/scoreboard/manifest.webmanifest">
    <meta name="theme-color" content="#0b1020">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <style>
        :root {
            --primary: #60a5fa;
            --primary-dark: #2563eb;
            --danger: #f87171;
            --success: #34d399;
            --warning: #fbbf24;
            --info: #38bdf8;
            --bg: #0b1020;
            --bg-card: #111827;
            --bg-elevated: #0f172a;
            --border: #1f2a44;
            --text: #e5e7eb;
            --text-muted: #94a3b8;
            --glow: rgba(96, 165, 250, 0.18);
            --number-font: 'Rockwell', 'Rockwell Nova', 'Georgia', serif;
            --display-font: 'Trebuchet MS', 'Segoe UI', 'Tahoma', sans-serif;
            --counter-font: 'Trebuchet MS', 'Segoe UI', 'Arial', sans-serif;
            /* ── iOS-style motion system ── */
            --ease-out:    cubic-bezier(0.25, 0.46, 0.45, 0.94);
            --ease-in-out: cubic-bezier(0.42, 0.00, 0.58, 1.00);
            --ease-in:     cubic-bezier(0.42, 0.00, 1.00, 1.00);
            --spring:      cubic-bezier(0.2, 0.8, 0.2, 1);
            --spring-soft: cubic-bezier(0.2, 0.8, 0.2, 1);
            --dur-xxs: 70ms;
            --dur-xs:  120ms;
            --dur-sm:  280ms;
            --dur-md:  380ms;
            --dur-lg:  500ms;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-font-smoothing: antialiased;
        }

        html {
            scroll-behavior: auto;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', sans-serif;
            background:
                radial-gradient(900px 520px at 12% 10%, rgba(30, 64, 175, 0.25), transparent 60%),
                radial-gradient(900px 520px at 88% 18%, rgba(16, 185, 129, 0.18), transparent 60%),
                radial-gradient(1000px 640px at 50% 85%, rgba(251, 191, 36, 0.08), transparent 65%),
                linear-gradient(160deg, #0b1020 0%, #0f172a 55%, #0b1020 100%);
            color: var(--text);
            line-height: 1.6;
            font-size: 18px;
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
            text-rendering: optimizeLegibility;
            scroll-behavior: smooth;
        }

        /* Disable animations during scroll for smooth performance */
        body.scrolling * {
            animation-play-state: paused !important;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 0 15px;
            padding-bottom: calc(120px + env(safe-area-inset-bottom, 0px));
            contain: layout style paint;
        }

        /* HEADER */
        .header {
            position: relative;
            overflow: hidden;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.96) 0%, rgba(30, 41, 59, 0.92) 45%, rgba(15, 118, 110, 0.9) 100%);
            color: white;
            padding: 25px 0;
            box-shadow: 0 12px 30px rgba(0,0,0,0.35);
            margin-bottom: 30px;
        }

        .header::after {
            content: '';
            position: absolute;
            inset: 0;
            background: radial-gradient(900px circle at 20% 20%, rgba(148, 163, 184, 0.22), transparent 40%),
                        radial-gradient(1100px circle at 80% 10%, rgba(56, 189, 248, 0.18), transparent 45%),
                        radial-gradient(900px circle at 50% 80%, rgba(16, 185, 129, 0.18), transparent 55%);
            opacity: 0.6;
            pointer-events: none;
            animation: floatGlow 18s ease-in-out infinite alternate;
            will-change: auto;
        }

        @keyframes floatGlow {
            from { transform: translateY(0); }
            to { transform: translateY(-6px); }
        }

        .header .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            text-align: center;
            gap: 6px;
            position: relative;
            z-index: 1;
        }

        .header h1 {
            font-size: clamp(28px, 3.2vw, 44px);
            font-weight: 800;
            margin-bottom: 0;
            letter-spacing: 1.2px;
            text-transform: uppercase;
            font-family: var(--display-font);
            text-shadow: 0 8px 22px rgba(15, 23, 42, 0.45), 0 2px 6px rgba(59, 130, 246, 0.3);
        }

        .header .subhead {
            font-size: clamp(18px, 2vw, 28px);
            font-weight: 700;
            letter-spacing: 1px;
            text-transform: uppercase;
            color: rgba(255, 255, 255, 0.9);
            font-family: var(--display-font);
        }

        .header .tagline {
            font-size: clamp(12px, 1.2vw, 15px);
            opacity: 0.75;
            letter-spacing: 0.6px;
            text-transform: uppercase;
            font-family: var(--display-font);
        }

        /* CONTROLS */
        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
            flex-wrap: wrap;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .sync-row {
            display: flex;
            align-items: center;
            gap: 12px;
            flex-wrap: wrap;
            margin: 10px 0 15px;
        }

        .sync-pill {
            padding: 6px 12px;
            border-radius: 999px;
            font-size: 12px;
            font-weight: 600;
            letter-spacing: 0.2px;
            border: 1px solid rgba(148, 163, 184, 0.3);
            background: rgba(148, 163, 184, 0.12);
            color: var(--text);
        }

        .sync-pill.online {
            background: rgba(16, 185, 129, 0.15);
            border-color: rgba(16, 185, 129, 0.35);
            color: #34d399;
        }

        .sync-pill.syncing {
            background: rgba(59, 130, 246, 0.15);
            border-color: rgba(59, 130, 246, 0.35);
            color: #60a5fa;
        }

        .sync-pill.offline {
            background: rgba(248, 113, 113, 0.12);
            border-color: rgba(248, 113, 113, 0.35);
            color: #f87171;
        }

        .sync-pill.stale {
            background: rgba(245, 158, 11, 0.15);
            border-color: rgba(245, 158, 11, 0.4);
            color: #fbbf24;
        }

        .sync-meta {
            font-size: 12px;
            color: var(--text-muted);
        }

        label {
            font-size: 13px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input, select, button {
            padding: 10px 12px;
            border: 1px solid var(--border);
            border-radius: 6px;
            font-size: 16px;
            font-family: inherit;
            transition: transform 80ms var(--spring), box-shadow 200ms var(--ease-out);
            contain: layout style;
        }

        input, select {
            background: var(--bg-elevated);
            color: var(--text);
            border-color: var(--border);
        }

        input:focus, select:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--glow);
            transition: border-color var(--dur-sm) var(--ease-out), box-shadow var(--dur-sm) var(--ease-out);
        }

        /* ── Simple tap feedback ───────────────────────────────────────── */
        button:not(:disabled):not(.tab-button):not(.col-toggle):active {
            opacity: 0.88;
        }
        .month-button:active {
            opacity: 0.88 !important;
        }
        .tab-button:active {
            opacity: 0.85;
        }
        /* Score-cell editable tap response */
        .score-cell.editable:active {
            opacity: 0.85;
        }

        button {
            background: var(--primary);
            color: white;
            border: none;
            cursor: pointer;
            font-weight: 600;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            will-change: transform;
            transform: translateZ(0);
            contain: layout style;
        }

        button:hover:not(:disabled) {
            background: var(--primary-dark);
            box-shadow: 0 6px 12px rgba(37, 99, 235, 0.25);
            transform: translateY(-1px) translateZ(0);
        }

        button:active:not(:disabled) {
            transform: translateY(0) translateZ(0);
        }

        button.secondary {
            background: var(--bg-elevated);
            color: var(--text);
            border: 1px solid var(--border);
            transition: background-color var(--dur-sm) var(--ease-out), border-color var(--dur-sm) var(--ease-out), transform var(--dur-xs) var(--spring);
        }

        button.secondary:hover:not(:disabled) {
            background: rgba(148, 163, 184, 0.12);
            border-color: var(--primary);
            transform: translateY(-2px);
        }

        button.secondary:active:not(:disabled) {
            transform: translateY(-1px);
        }

        button.danger {
            background: var(--danger);
            transition: background-color var(--dur-sm) var(--ease-out), box-shadow var(--dur-md) var(--spring-soft), transform var(--dur-xs) var(--spring);
        }

        button.danger:hover:not(:disabled) {
            background: #ef4444;
            box-shadow: 0 12px 28px rgba(248, 113, 113, 0.4);
            transform: translateY(-2px);
        }

        button.danger:active:not(:disabled) {
            transform: translateY(-1px);
        }

        .score-input {
            width: 165px;
            padding: 10px 12px;
            border-radius: 6px;
            border: 1px solid rgba(148, 163, 184, 0.3);
            background: rgba(15, 23, 42, 0.9);
            color: var(--text);
            font-family: var(--number-font);
            font-size: 16px;
            transition: border-color var(--dur-sm) var(--ease-out), box-shadow var(--dur-sm) var(--ease-out), background-color var(--dur-sm) var(--ease-out);
            will-change: auto;
        }
        .veto-reason-input {
            width: 220px;
            font-size: 14px;
        }

        .score-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--glow);
        }
        .score-input.filled {
            border-color: #22c55e;
            background: rgba(34, 197, 94, 0.24);
            box-shadow: inset 0 0 0 1px rgba(34, 197, 94, 0.4);
            transition: border-color var(--dur-sm) var(--ease-out), background-color var(--dur-sm) var(--ease-out), box-shadow var(--dur-sm) var(--ease-out);
        }
        .score-input-wrapper {
            position: relative;
            display: inline-flex;
            align-items: center;
            gap: 4px;
        }
        .stored-score-badge, .stored-star-badge, .stored-veto-badge {
            display: inline-block;
            font-size: 12px;
            font-weight: 800;
            font-family: var(--number-font);
            padding: 3px 8px;
            border-radius: 5px;
            white-space: nowrap;
            vertical-align: middle;
            min-width: 28px;
            text-align: center;
            transition: transform var(--dur-xs) var(--spring), box-shadow var(--dur-sm) var(--ease-out);
            will-change: transform, box-shadow;
        }
        .stored-score-badge {
            background: linear-gradient(135deg, rgba(34, 197, 94, 0.35), rgba(22, 163, 74, 0.5));
            color: #bbf7d0;
            border: 1px solid rgba(34, 197, 94, 0.6);
            box-shadow: 0 0 4px rgba(34, 197, 94, 0.25);
        }
        .stored-star-badge {
            background: linear-gradient(135deg, rgba(234, 179, 8, 0.3), rgba(202, 138, 4, 0.45));
            color: #fef08a;
            border: 1px solid rgba(234, 179, 8, 0.55);
            box-shadow: 0 0 4px rgba(234, 179, 8, 0.2);
        }
        .stored-star-badge::before {
            content: '\2605 ';
            font-size: 10px;
        }
        .stored-veto-badge {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.3), rgba(37, 99, 235, 0.45));
            color: #bfdbfe;
            border: 1px solid rgba(59, 130, 246, 0.55);
            box-shadow: 0 0 4px rgba(59, 130, 246, 0.2);
        }
        .stored-veto-badge::before {
            content: 'V';
            font-size: 10px;
            margin-right: 2px;
        }
        .score-recorded-row td {
            background: linear-gradient(90deg, rgba(34, 197, 94, 0.14), rgba(15, 23, 42, 0.08));
        }
        .attendance-marked-row td {
            background: linear-gradient(90deg, rgba(34, 197, 94, 0.16), rgba(15, 23, 42, 0.08));
        }
        .attendance-marked {
            border-color: rgba(34, 197, 94, 0.65) !important;
            background: rgba(34, 197, 94, 0.16) !important;
        }
        .score-save-btn {
            background: linear-gradient(135deg, #16a34a, #22c55e);
            color: #fff;
            border: none;
            border-radius: 8px;
            padding: 8px 10px;
            font-weight: 700;
            cursor: pointer;
            box-shadow: 0 6px 16px rgba(22, 163, 74, 0.3);
            transition: box-shadow var(--dur-sm) var(--ease-out), transform var(--dur-xxs) var(--spring);
            will-change: transform;
            transform: translateZ(0);
        }
        .score-save-btn:hover:not(:disabled) {
            box-shadow: 0 10px 24px rgba(22, 163, 74, 0.35);
            transform: translateY(-1px) translateZ(0);
        }
        .score-save-btn:active:not(:disabled) {
            transform: translateY(0) translateZ(0);
        }
        @media (max-width: 1100px) {
            #add-score-tab .controls {
                grid-template-columns: 1fr 1fr;
            }
            #recordStudentsTable th,
            #recordStudentsTable td {
                padding: 10px 8px;
            }
            .score-input {
                width: 135px;
                font-size: 15px;
            }
        }
        @media (max-width: 900px) {
            #add-score-tab .form-grid {
                grid-template-columns: 1fr;
            }
            #add-score-tab .controls {
                grid-template-columns: 1fr;
            }
            #recordStudentsTable th,
            #recordStudentsTable td {
                padding: 10px 8px;
            }
            .score-input {
                width: 128px;
                font-size: 16px;
                min-height: 42px;
            }
            .score-save-btn {
                padding: 10px 10px;
                min-width: 44px;
                min-height: 42px;
            }
        }
        @media (max-width: 640px) {
            .score-input {
                width: 114px;
                font-size: 15px;
                padding: 9px 10px;
            }
            #recordStudentsTable th,
            #recordStudentsTable td {
                padding: 9px 6px;
            }
            #recordStudentsTable td {
                white-space: nowrap;
            }
        }

        /* TABS */
        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 25px;
            flex-wrap: wrap;
            border-bottom: 2px solid rgba(148, 163, 184, 0.2);
            padding-bottom: 0;
        }

        .tab-button {
            padding: 12px 20px;
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-weight: 600;
            border-bottom: 3px solid transparent;
            margin-bottom: -2px;
            transition: color 200ms var(--ease-out), border-bottom-color 200ms var(--ease-out);
            will-change: color;
        }

        .tab-button i {
            margin-right: 8px;
            color: var(--tab-icon, var(--primary));
        }

        .tab-button.active {
            color: var(--text);
            border-bottom-color: var(--tab-icon, var(--primary));
        }

        .tab-button:hover {
            color: var(--text);
        }

        .tab-spacer {
            flex: 1;
        }

        .tab-button.right-tab {
            margin-left: auto;
        }

        .score-cell.editable {
            cursor: pointer;
            will-change: auto;
            transition: background-color var(--dur-sm) var(--ease-out);
        }

        .score-cell.editable:hover {
            background: rgba(56, 189, 248, 0.2) !important;
        }

        /* MONTH SELECTOR */
        .month-nav {
            display: flex;
            gap: 8px;
            margin-bottom: 18px;
            align-items: center;
            flex-wrap: wrap;
            padding: 12px 16px;
            background: linear-gradient(135deg, rgba(15, 23, 42, 0.7), rgba(17, 24, 39, 0.6));
            border: 1px solid rgba(148, 163, 184, 0.18);
            border-radius: 12px;
        }

        .month-nav-label {
            font-size: 11px;
            font-weight: 700;
            color: var(--text-muted);
            letter-spacing: 0.8px;
            text-transform: uppercase;
            margin-right: 4px;
            white-space: nowrap;
        }

        .month-button {
            padding: 9px 20px;
            background: rgba(30, 41, 59, 0.85);
            border: 2px solid rgba(148, 163, 184, 0.22);
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            transition: background-color var(--dur-sm) var(--ease-out), border-color var(--dur-sm) var(--ease-out), box-shadow var(--dur-sm) var(--ease-out), transform var(--dur-xxs) var(--spring);
            font-size: 13px;
            font-family: var(--number-font);
            color: var(--text-secondary);
            letter-spacing: 0.2px;
            will-change: transform;
            transform: translateZ(0);
        }

        .month-button.active {
            background: var(--primary);
            color: #fff;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.28), 0 3px 10px rgba(59, 130, 246, 0.38);
            transform: translateY(-1px);
            font-size: 14px;
            padding: 10px 22px;
        }

        .month-button:hover:not(.active) {
            border-color: var(--primary);
            color: var(--primary);
            background: rgba(59, 130, 246, 0.1);
            transform: translateY(-1px);
        }

        /* SCOREBOARD */
        .scoreboard-wrapper {
            background: linear-gradient(160deg, rgba(15, 23, 42, 0.96) 0%, rgba(17, 24, 39, 0.96) 100%);
            border-radius: 8px;
            border: 1px solid rgba(148, 163, 184, 0.18);
            box-shadow: 0 18px 40px rgba(0,0,0,0.35);
            overflow: hidden;
            contain: layout style;
        }

        .scoreboard-scroll {
            overflow-x: auto;
            overflow-y: hidden;
            max-height: none;
            padding-bottom: 0;
            position: relative;
            background-color: #0f172a;
            isolation: isolate;
            scroll-behavior: auto;
            -webkit-overflow-scrolling: touch;
            overscroll-behavior-x: contain;
        }

        .scoreboard-scroll-top {
            display: block;
            overflow-x: scroll;
            overflow-y: hidden;
            -webkit-overflow-scrolling: touch;
            height: 20px;
            margin: 0 0 6px;
            background: rgba(30, 41, 59, 0.85);
            border-radius: 6px;
            border: 1px solid rgba(148, 163, 184, 0.25);
        }
        .scoreboard-scroll-top-spacer {
            height: 1px;
            min-width: 1px;
        }
        #scoreboard-tab .scoreboard-wrapper {
            overflow: visible;
            margin-bottom: 24px;
        }

        #scoreboard-tab .scoreboard-scroll {
            overflow-x: scroll;
            overflow-y: auto;
            max-height: calc(100vh - 90px);
            min-height: 470px;
            padding-bottom: 0;
            scroll-behavior: auto;
        }

        @media (max-width: 980px) {
            #scoreboard-tab .scoreboard-scroll {
                max-height: calc(100vh - 85px);
                min-height: 370px;
            }
        }

        /* ── Custom scrollbar — amber thumb, high contrast against dark track ── */
        #scoreboardBottomScroll {
            scrollbar-width: thin;
            scrollbar-color: #f59e0b #0f172a;
        }
        #scoreboardBottomScroll::-webkit-scrollbar {
            height: 14px;
            width: 8px;
        }
        #scoreboardBottomScroll::-webkit-scrollbar-track {
            background: #0f172a;
            border-radius: 7px;
            border: 1px solid rgba(148, 163, 184, 0.15);
        }
        #scoreboardBottomScroll::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, #f59e0b, #fbbf24);
            border-radius: 7px;
            min-width: 50px;
            border: 2px solid #0f172a;
        }
        #scoreboardBottomScroll::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, #fbbf24, #fde68a);
        }
        #scoreboardTopScroll {
            scrollbar-width: thin;
            scrollbar-color: #f59e0b #0f172a;
        }
        #scoreboardTopScroll::-webkit-scrollbar {
            height: 14px;
        }
        #scoreboardTopScroll::-webkit-scrollbar-track {
            background: #0f172a;
            border-radius: 7px;
            border: 1px solid rgba(148, 163, 184, 0.15);
        }
        #scoreboardTopScroll::-webkit-scrollbar-thumb {
            background: linear-gradient(90deg, #f59e0b, #fbbf24);
            border-radius: 7px;
            min-width: 50px;
            border: 2px solid #0f172a;
        }
        #scoreboardTopScroll::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(90deg, #fbbf24, #fde68a);
        }

        .master-update-btn {
            position: fixed;
            right: 18px;
            bottom: 18px;
            z-index: 1200;
            background: linear-gradient(135deg, #ef4444, #f59e0b);
            color: #fff;
            border: none;
            border-radius: 999px;
            padding: 12px 18px;
            font-weight: 700;
            font-size: 13px;
            letter-spacing: 0.2px;
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.35);
            cursor: pointer;
            transition: box-shadow var(--dur-md) var(--spring-soft), transform var(--dur-sm) var(--spring), filter var(--dur-xs) var(--ease-out);
            will-change: transform, box-shadow;
        }

        .master-update-btn:hover:not(:disabled) {
            box-shadow: 0 16px 40px rgba(0, 0, 0, 0.45);
            transform: translateY(-4px);
            filter: brightness(1.05);
        }

        .master-update-btn:active:not(:disabled) {
            transform: translateY(-2px);
        }

        .master-update-btn:disabled {
            opacity: 0.7;
            cursor: not-allowed;
        }

        .scoreboard {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            font-size: 15px;
            min-width: max-content;
            white-space: nowrap;
            font-family: var(--number-font);
            position: relative;
            isolation: isolate;
        }

        .scoreboard thead {
            background: linear-gradient(135deg, rgb(30, 64, 175) 0%, rgb(14, 116, 144) 100%);
            color: white;
        }

        .scoreboard th {
            padding: 12px 8px;
            text-align: left;
            font-weight: 600;
            border: 1px solid rgba(255,255,255,0.15);
            white-space: nowrap;
            background-clip: padding-box;
            color: #f8fafc;
            background-color: rgba(15, 23, 42, 0.92);
            box-sizing: border-box;
        }
        #scoreboardTable thead th:nth-child(odd) {
            background: linear-gradient(135deg, rgb(59, 130, 246), rgb(14, 116, 144));
        }
        #scoreboardTable thead th:nth-child(even) {
            background: linear-gradient(135deg, rgb(30, 58, 138), rgb(15, 118, 110));
        }
        #scoreboardTable thead th.total-cell,
        #scoreboardTable thead th.vote-cell {
            background: linear-gradient(135deg, rgb(245, 158, 11), rgb(251, 191, 36));
            color: #1f2937;
        }

        .scoreboard td {
            padding: 14px 10px;
            border: 1px solid rgba(148, 163, 184, 0.15);
            white-space: nowrap;
            background-clip: padding-box;
            background-color: #0f172a;
            position: relative;
            mix-blend-mode: normal;
            box-sizing: border-box;
        }
        #scoreboardTable {
            --sb-rank-w: 82px;
            --sb-roll-w: 124px;
            --sb-name-w: 320px;
            --sb-class-w: 72px;
            --sb-fees-w: 70px;
        }
        #scoreboardTable th.rank-cell,
        #scoreboardTable td.rank-cell {
            width: var(--sb-rank-w) !important;
            min-width: var(--sb-rank-w) !important;
            max-width: var(--sb-rank-w) !important;
        }
        #scoreboardTable th.sticky-left-1,
        #scoreboardTable td.sticky-left-1 {
            width: var(--sb-roll-w) !important;
            min-width: var(--sb-roll-w) !important;
            max-width: var(--sb-roll-w) !important;
        }
        #scoreboardTable th.sticky-left-2,
        #scoreboardTable td.sticky-left-2 {
            width: var(--sb-name-w) !important;
            min-width: var(--sb-name-w) !important;
            max-width: var(--sb-name-w) !important;
        }
        #scoreboardTable th.sticky-left-3,
        #scoreboardTable td.sticky-left-3 {
            width: var(--sb-class-w) !important;
            min-width: var(--sb-class-w) !important;
            max-width: var(--sb-class-w) !important;
        }
        #scoreboardTable th.sticky-left-4,
        #scoreboardTable td.sticky-left-4 {
            width: var(--sb-fees-w) !important;
            min-width: var(--sb-fees-w) !important;
            max-width: var(--sb-fees-w) !important;
        }

        .scoreboard td button,
        .scoreboard td .button-like {
            font-size: 14px !important;
            padding: 8px 10px;
            line-height: 1.25;
        }

        .scoreboard tbody tr {
            contain: layout style;
        }
        .scoreboard tbody tr td {
            background: #0f172a;
            transition: background-color 200ms var(--ease-out);
            contain: layout style paint;
        }
        .scoreboard tbody tr:nth-child(even) td {
            background: #0b1220;
        }
        .scoreboard tbody tr:hover td {
            background: #1f2937;
        }
        .scoreboard tbody tr:nth-child(even) td.sticky-left,
        .scoreboard tbody tr:nth-child(even) td.sticky-right {
            background-color: #0b1220 !important;
        }
        .scoreboard tbody tr:hover td.sticky-left,
        .scoreboard tbody tr:hover td.sticky-right {
            background-color: #1f2937 !important;
        }

        /* Record Score tab: reduce repaint/animation pressure while vertically scrolling large editable grids. */
        #recordStudentsTable tbody tr td {
            transition: none !important;
        }
        #recordStudentsTable .score-input,
        #recordStudentsTable .score-save-btn {
            will-change: auto !important;
            transform: none !important;
        }
        #recordStudentsTable .score-save-btn:hover:not(:disabled),
        #recordStudentsTable .score-save-btn:active:not(:disabled) {
            transform: none !important;
        }
        #recordStudentsTable,
        #recordStudentsTable tbody tr,
        #recordStudentsTable tbody tr td {
            contain: none !important;
            backface-visibility: visible !important;
            -webkit-backface-visibility: visible !important;
        }
        #scoreboardTable tbody tr,
        #scoreboardTable tbody tr td {
            contain: none !important;
        }

        /* MEDALS/BADGES */
        .medal {
            display: inline-block;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            color: white;
            font-size: 12px;
            margin-right: 8px;
            font-family: var(--number-font);
        }
        #scoreboardTable td.rank-cell {
            text-align: center !important;
            vertical-align: middle !important;
        }
        #scoreboardTable td.rank-cell .medal {
            width: 40px;
            height: 40px;
            font-size: 18px;
            margin: 0 auto;
            line-height: 1;
        }

        .medal.gold {
            background: linear-gradient(135deg, #fbbf24 0%, #f59e0b 100%);
        }

        .medal.silver {
            background: linear-gradient(135deg, #d1d5db 0%, #9ca3af 100%);
        }

        .medal.bronze {
            background: linear-gradient(135deg, #fb923c 0%, #ea580c 100%);
        }

        .badge {
            display: inline-block;
            padding: 2px 6px;
            background: var(--info);
            color: white;
            border-radius: 3px;
            font-size: 11px;
            font-weight: 600;
            margin: 0 2px;
        }

        .badge.cr { background: #8b5cf6; }
        .badge.col { background: #06b6d4; }
        .badge.rm { background: #f59e0b; }
        .badge.v { background: #10b981; }
        .badge.vv { background: #34d399; }
        .badge.success { background: #22c55e; }
        .badge.warning { background: #f59e0b; }

        /* SCORE CELL */
        .score-cell {
            text-align: center;
            min-width: 50px;
            font-weight: 500;
            background: #111827;
            padding: 10px 6px;
            font-family: var(--number-font);
            font-size: clamp(16px, 1.5vw, 22px);
            line-height: 1.2;
        }

        .score-cell.positive {
            color: var(--success);
            font-weight: 600;
        }

        .score-cell.negative {
            color: var(--danger);
            font-weight: 600;
        }

        .score-cell.entered-zero {
            color: #93c5fd;
            font-weight: 600;
        }

        .score-cell.star-awarded {
            box-shadow: inset 0 0 0 1px rgba(251, 191, 36, 0.45);
            text-shadow: 0 0 6px rgba(251, 191, 36, 0.2);
        }
        .score-cell.star-awarded-green {
            box-shadow: inset 0 0 0 1px rgba(34, 197, 94, 0.55);
            text-shadow: 0 0 6px rgba(34, 197, 94, 0.25);
        }
        .star-added {
            color: #22c55e;
            font-weight: 700;
        }

        .record-star-undo-btn {
            width: 18px;
            height: 18px;
            min-width: 18px;
            border-radius: 999px;
            border: 1px solid rgba(251, 191, 36, 0.55);
            background: rgba(15, 23, 42, 0.85);
            color: #fcd34d;
            font-size: 10px;
            line-height: 1;
            padding: 0;
            cursor: pointer;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            margin-left: 4px;
        }

        .record-star-undo-btn:hover {
            background: rgba(251, 191, 36, 0.2);
            border-color: rgba(251, 191, 36, 0.8);
        }

        .score-cell.star-used-green {
            background: linear-gradient(135deg, #065f46 0%, #047857 100%) !important;
            color: #ecfdf5 !important;
            font-weight: 900;
            text-align: center !important;
            vertical-align: middle !important;
            letter-spacing: 0.4px;
            text-shadow: 0 0 6px rgba(16, 185, 129, 0.45), 0 0 2px rgba(0, 0, 0, 0.5);
            box-shadow: inset 0 0 0 2px rgba(16, 185, 129, 0.55);
        }

        .score-cell.star-used-red {
            background: linear-gradient(135deg, #f87171 0%, #b91c1c 100%);
            color: #ffffff;
            font-weight: 800;
            font-size: 22px;
            text-shadow: 0 0 6px rgba(0, 0, 0, 0.45);
        }
        .score-cell.star-used-red:hover {
            background: transparent !important;
        }

        .score-cell.veto-used {
            background: linear-gradient(135deg, #3b82f6 0%, #1d4ed8 100%);
            color: #0f172a;
            font-weight: 800;
            position: relative;
            overflow: visible;
        }
        .score-cell.veto-used[data-reason] {
            background: linear-gradient(135deg, #ef4444 0%, #b91c1c 100%);
            color: #fff7ed;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
        }
        .score-cell.veto-used[data-reason]:hover::after {
            content: attr(data-reason);
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: calc(100% + 8px);
            min-width: 220px;
            max-width: 360px;
            white-space: normal;
            background: rgba(15, 23, 42, 0.98);
            color: #f8fafc;
            border: 1px solid rgba(248, 113, 113, 0.85);
            border-radius: 10px;
            padding: 10px 12px;
            font-size: 14px;
            line-height: 1.35;
            z-index: 40;
            box-shadow: 0 14px 28px rgba(0, 0, 0, 0.45);
            pointer-events: none;
        }
        .score-cell.veto-used[data-reason]:hover::before {
            content: '';
            position: absolute;
            left: 50%;
            transform: translateX(-50%);
            bottom: calc(100% + 2px);
            border-width: 6px;
            border-style: solid;
            border-color: rgba(248, 113, 113, 0.85) transparent transparent transparent;
            z-index: 41;
            pointer-events: none;
        }

        .score-cell.bonus-neutral {
            color: #e2e8f0;
            font-weight: 600;
        }

        .score-cell.total {
            background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 100%);
            font-weight: 800;
            color: #1f2937;
        }

        .flash {
            animation: flashPulse 1s infinite;
        }

        @keyframes flashPulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        .rank-cell {
            font-weight: 700;
            color: #f59e0b;
            text-align: center;
            font-size: clamp(18px, 1.6vw, 24px);
            font-family: var(--number-font);
        }

        .total-cell {
            color: #fde68a;
            text-align: center;
            font-size: clamp(18px, 1.6vw, 24px);
            font-family: var(--number-font);
        }

        .top-scorer-name {
            color: #fde68a;
            font-weight: 900;
            letter-spacing: 0.4px;
            text-shadow: 0 0 14px rgba(251, 191, 36, 0.55), 0 0 6px rgba(15, 23, 42, 0.6);
        }
        .stat-card .top-scorer-name {
            font-size: clamp(20px, 2.2vw, 30px);
        }
        .scoreboard tr.top-scorer-row td {
            background: linear-gradient(90deg, rgba(250, 204, 21, 0.12), rgba(251, 191, 36, 0.06));
        }
        #scoreboardTable thead tr#scoreboardHeaderRow th {
            background: linear-gradient(135deg, rgb(14, 116, 144), rgb(30, 64, 175)) !important;
            color: #e0f2fe !important;
            border-top: 2px solid rgba(56, 189, 248, 0.78) !important;
            border-bottom: 2px solid rgba(37, 99, 235, 0.6) !important;
            box-shadow: inset 0 1px 0 rgba(255, 255, 255, 0.08);
        }
        #scoreboardTable thead tr#scoreboardHeaderRow th.total-cell {
            background: linear-gradient(135deg, rgb(245, 158, 11), rgb(251, 191, 36)) !important;
            color: #1f2937 !important;
        }
        #scoreboardTable thead tr#scoreboardHeaderRow th.vote-cell {
            background: linear-gradient(135deg, rgb(6, 182, 212), rgb(2, 132, 199)) !important;
            color: #ecfeff !important;
        }

        /* ── Sticky header row: pins column/date labels while scrolling down ── */
        #scoreboardTable thead th {
            position: sticky !important;
            top: 0;
            z-index: 55;
        }
        /* Corner cells (horizontally + vertically sticky) → highest z-index + opaque header bg */
        #scoreboardTable thead th.sticky-left,
        #scoreboardTable thead th.sticky-right,
        #scoreboardTable thead th.extra-fixed {
            z-index: 80 !important;
            background: linear-gradient(135deg, rgb(30, 64, 175), rgb(14, 116, 144)) !important;
        }
        /* Visual drop-shadow to separate sticky header from scrolling body rows */
        #scoreboardTable thead tr:last-child th {
            box-shadow: 0 3px 8px rgba(0, 0, 0, 0.45);
        }

        .vote-cell {
            font-weight: 700;
            color: #38bdf8;
            text-align: center;
            font-size: clamp(18px, 1.6vw, 24px);
            font-family: var(--number-font);
        }

        .blink {
            animation: glowBlink 1.6s ease-in-out infinite;
            position: relative;
            background-size: 200% 100%;
            will-change: box-shadow, outline;
        }

        @keyframes glowBlink {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(250, 204, 21, 0.25), 0 0 10px rgba(250, 204, 21, 0.35);
                outline: 1px solid rgba(250, 204, 21, 0.45);
                text-shadow: 0 0 6px rgba(250, 204, 21, 0.45);
                background-position: 0% 50%;
            }
            50% {
                box-shadow: 0 0 0 2px rgba(250, 204, 21, 0.7), 0 0 18px rgba(250, 204, 21, 0.85);
                outline: 2px solid rgba(250, 204, 21, 0.7);
                text-shadow: 0 0 12px rgba(250, 204, 21, 0.75);
                background-position: 100% 50%;
            }
        }

        .blink-first {
            animation: glowGold 1.6s ease-in-out infinite;
            background-image: linear-gradient(120deg, rgba(251, 191, 36, 0.15), rgba(245, 158, 11, 0.05), rgba(251, 191, 36, 0.2));
            will-change: box-shadow, outline;
        }
        .blink-second {
            animation: glowSilver 1.9s ease-in-out infinite;
            background-image: linear-gradient(120deg, rgba(226, 232, 240, 0.12), rgba(148, 163, 184, 0.05), rgba(226, 232, 240, 0.18));
            will-change: box-shadow, outline;
        }
        .blink-third {
            animation: glowBronze 2.1s ease-in-out infinite;
            background-image: linear-gradient(120deg, rgba(251, 146, 60, 0.12), rgba(234, 88, 12, 0.05), rgba(251, 146, 60, 0.18));
            will-change: box-shadow, outline;
        }

        @keyframes glowGold {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(251, 191, 36, 0.3), 0 0 12px rgba(251, 191, 36, 0.55);
                outline: 2px solid rgba(251, 191, 36, 0.55);
                text-shadow: 0 0 8px rgba(251, 191, 36, 0.65);
            }
            50% {
                box-shadow: 0 0 0 3px rgba(251, 191, 36, 0.75), 0 0 22px rgba(251, 191, 36, 0.9);
                outline: 3px solid rgba(251, 191, 36, 0.8);
                text-shadow: 0 0 14px rgba(251, 191, 36, 0.9);
            }
        }
        @keyframes glowSilver {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(148, 163, 184, 0.3), 0 0 10px rgba(226, 232, 240, 0.6);
                outline: 2px solid rgba(226, 232, 240, 0.55);
                text-shadow: 0 0 6px rgba(226, 232, 240, 0.65);
            }
            50% {
                box-shadow: 0 0 0 3px rgba(226, 232, 240, 0.75), 0 0 18px rgba(226, 232, 240, 0.9);
                outline: 3px solid rgba(226, 232, 240, 0.75);
                text-shadow: 0 0 12px rgba(226, 232, 240, 0.85);
            }
        }
        @keyframes glowBronze {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(251, 146, 60, 0.3), 0 0 10px rgba(251, 146, 60, 0.6);
                outline: 2px solid rgba(251, 146, 60, 0.55);
                text-shadow: 0 0 6px rgba(251, 146, 60, 0.65);
            }
            50% {
                box-shadow: 0 0 0 3px rgba(251, 146, 60, 0.75), 0 0 18px rgba(251, 146, 60, 0.9);
                outline: 3px solid rgba(251, 146, 60, 0.75);
                text-shadow: 0 0 12px rgba(251, 146, 60, 0.85);
            }
        }

        .inactive-row {
            opacity: 0.55;
        }

        .scoreboard th.sticky-left,
        .scoreboard td.sticky-left {
            position: sticky;
            left: 0;
            z-index: 30;
            background: #0f172a !important;
            background-color: #0f172a !important;
            background-image: none !important;
            background-clip: padding-box;
            opacity: 1;
            box-shadow: 2px 0 0 rgba(148, 163, 184, 0.38);
            backdrop-filter: none;
            border-right: 1px solid rgba(148, 163, 184, 0.45) !important;
            overflow: hidden;
        }
        /* Header sticky-left cells must keep header gradient (not body sticky bg). */
        #scoreboardTable thead th.sticky-left,
        #scoreboardTable thead th.sticky-left-1,
        #scoreboardTable thead th.sticky-left-2,
        #scoreboardTable thead th.sticky-left-3,
        #scoreboardTable thead th.sticky-left-4 {
            background: linear-gradient(135deg, rgb(14, 116, 144), rgb(30, 64, 175)) !important;
            background-color: transparent !important;
            background-image: linear-gradient(135deg, rgb(14, 116, 144), rgb(30, 64, 175)) !important;
        }
        #scoreboardTable th.rank-cell.sticky-left,
        #scoreboardTable td.rank-cell.sticky-left {
            z-index: 45 !important;
            left: 0 !important;
        }
        #scoreboardTable th.sticky-left-1,
        #scoreboardTable td.sticky-left-1 {
            z-index: 44 !important;
            left: calc(var(--sb-rank-w)) !important;
        }
        #scoreboardTable th.sticky-left-2,
        #scoreboardTable td.sticky-left-2 {
            z-index: 43 !important;
            left: calc(var(--sb-rank-w) + var(--sb-roll-w)) !important;
        }
        #scoreboardTable th.sticky-left-3,
        #scoreboardTable td.sticky-left-3 {
            z-index: 42 !important;
            left: calc(var(--sb-rank-w) + var(--sb-roll-w) + var(--sb-name-w)) !important;
        }
        #scoreboardTable th.sticky-left-4,
        #scoreboardTable td.sticky-left-4 {
            z-index: 41 !important;
            left: calc(var(--sb-rank-w) + var(--sb-roll-w) + var(--sb-name-w) + var(--sb-class-w)) !important;
        }
        /* Keep top-left header corner cells above body sticky cells while vertical scrolling. */
        #scoreboardTable thead th.rank-cell.sticky-left {
            z-index: 92 !important;
            top: 0 !important;
        }
        #scoreboardTable thead th.sticky-left-1 { z-index: 91 !important; top: 0 !important; }
        #scoreboardTable thead th.sticky-left-2 { z-index: 90 !important; top: 0 !important; }
        #scoreboardTable thead th.sticky-left-3 { z-index: 89 !important; top: 0 !important; }
        #scoreboardTable thead th.sticky-left-4 { z-index: 88 !important; top: 0 !important; }

        /* Sticky left offsets are controlled by #scoreboardTable CSS variables above. */

        .scoreboard th.sticky-left-2,
        .scoreboard td.sticky-left-2 {
            max-width: 320px;
            min-width: 320px;
            white-space: normal;
            line-height: 1.25;
            overflow-wrap: break-word;
        }

        .scoreboard th.sticky-right,
        .scoreboard td.sticky-right {
            position: sticky;
            right: 0;
            z-index: 26;
            background: #0f172a !important;
            background-color: #0f172a !important;
            background-image: none !important;
            background-clip: padding-box;
            opacity: 1;
            box-shadow: -2px 0 0 rgba(148, 163, 184, 0.38);
            backdrop-filter: none;
            border-left: 1px solid rgba(148, 163, 184, 0.45) !important;
        }
        .scoreboard th.extra-fixed,
        .scoreboard td.extra-fixed {
            background: #0f172a !important;
            background-color: #0f172a !important;
            background-image: none !important;
            min-width: 95px;
            width: 95px;
            text-align: center;
            border-left: 1px solid rgba(148, 163, 184, 0.34) !important;
            font-size: 11px;
            line-height: 1.1;
            white-space: normal;
            word-break: break-word;
        }
        .scoreboard th.extra-fixed {
            z-index: 33;
            font-weight: 700;
        }
        .scoreboard td.extra-fixed {
            z-index: 25;
        }

        .scoreboard th.sticky-right-1,
        .scoreboard td.sticky-right-1 { right: 96px; }

        .scoreboard th.sticky-left,
        .scoreboard th.sticky-right {
            z-index: 34;
        }

        .scoreboard th.total-cell.sticky-right,
        .scoreboard td.total-cell.sticky-right {
            background: linear-gradient(135deg, #f59e0b 0%, #fbbf24 100%) !important;
            color: #1f2937 !important;
            min-width: 150px;
            width: 150px;
        }

        .scoreboard th.vote-cell.sticky-right,
        .scoreboard td.vote-cell.sticky-right {
            background: #0b1f3a !important;
            color: #38bdf8 !important;
            min-width: 96px;
            width: 96px;
            line-height: 1.15;
            text-align: center;
        }
        .scoreboard th.total-cell {
            white-space: normal !important;
            line-height: 1.1;
        }
        .scoreboard th.vote-cell {
            white-space: normal !important;
            word-break: normal !important;
            overflow-wrap: normal !important;
            hyphens: manual;
        }
        .scoreboard td.vote-cell {
            white-space: nowrap !important;
        }

        .student-name-core {
            font-weight: 600;
            color: #f8fafc;
        }

        .post-holder-name {
            padding: 1px 6px;
            border-radius: 6px;
            color: #f0f9ff;
            background: linear-gradient(135deg, rgba(14, 165, 233, 0.2), rgba(34, 211, 238, 0.18));
            border: 1px solid rgba(125, 211, 252, 0.42);
            box-shadow: 0 0 0 1px rgba(14, 165, 233, 0.2) inset;
            text-shadow:
                0 0 4px rgba(125, 211, 252, 0.55),
                0 0 1px rgba(255, 255, 255, 0.5);
            transition: box-shadow var(--dur-sm) var(--ease-out), transform var(--dur-sm) var(--spring-soft);
        }
        .post-holder-name:hover {
            transform: translateY(-2px) scale(1.015);
            box-shadow: 0 0 0 1px rgba(56, 189, 248, 0.45) inset, 0 6px 20px rgba(56, 189, 248, 0.12);
        }
        #scoreboardTable td.sticky-left-2 {
            overflow: hidden;
            contain: paint;
        }
        #scoreboardTable td.sticky-left-2 .name-stack {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            gap: 4px;
            width: 100%;
            min-width: 0;
        }
        #scoreboardTable td.sticky-left-2 .student-name-core {
            display: block;
            width: 100%;
            min-width: 0;
            white-space: normal;
            overflow-wrap: anywhere;
            word-break: break-word;
        }
        #scoreboardTable td.sticky-left-2 .student-meta {
            display: inline-flex;
            flex-wrap: wrap;
            gap: 6px;
            margin-left: 0;
        }
        #scoreboardTable .post-holder-name {
            display: inline;
            position: relative;
            padding: 0 2px;
            border: none;
            border-radius: 0;
            background: transparent;
            box-shadow: none;
            color: #fef3c7;
            font-weight: 800;
            letter-spacing: 0.2px;
            text-shadow:
                0 0 7px rgba(245, 158, 11, 0.35),
                0 0 2px rgba(255, 255, 255, 0.35);
            text-decoration: underline;
            text-decoration-color: rgba(245, 158, 11, 0.72);
            text-underline-offset: 2px;
            text-decoration-thickness: 2px;
            background-image: linear-gradient(transparent 62%, rgba(245, 158, 11, 0.16) 62%);
            background-repeat: no-repeat;
            background-size: 100% 100%;
        }

        /* FEES */
        .fee-input {
            width: 110px;
            max-width: 100%;
        }
        #feesTable td:last-child button {
            margin: 4px 6px 0 0;
            padding: 8px 10px;
            font-size: 12px;
        }
        .fee-name-cell {
            max-width: 220px;
            min-width: 170px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .fee-date-note {
            display: block;
            font-size: 11px;
            color: #94a3b8;
            margin-top: 4px;
        }
        .fee-date-cell {
            display: grid;
            grid-template-columns: minmax(120px, 1fr) 30px;
            align-items: center;
            gap: 4px 6px;
            min-width: 170px;
        }
        .fee-date-input {
            position: relative;
            min-width: 120px;
            width: 100%;
        }
        .fee-date-input::-webkit-calendar-picker-indicator {
            opacity: 0;
            pointer-events: none;
            width: 0;
            margin: 0;
        }
        .fee-date-picker-btn {
            background: rgba(30, 41, 59, 0.85);
            color: #93c5fd;
            border: 1px solid rgba(147, 197, 253, 0.45);
            border-radius: 6px;
            padding: 4px 6px;
            font-size: 12px;
            line-height: 1;
            cursor: pointer;
            width: 30px;
            height: 28px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        #feesTable th,
        #feesTable td {
            white-space: nowrap;
            vertical-align: middle;
        }
        #feesTable th.fees-period-col {
            white-space: normal;
            line-height: 1.15;
            text-align: center;
        }
        #fees-tab .scoreboard-scroll {
            padding-right: 18px;
        }

        .bulk-date-list {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
        }
        .bulk-date-chip {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            background: rgba(30, 58, 138, 0.35);
            border: 1px solid rgba(96, 165, 250, 0.5);
            color: #dbeafe;
            border-radius: 999px;
            padding: 4px 10px;
            font-size: 12px;
        }
        .bulk-date-chip.state-present {
            background: rgba(16, 185, 129, 0.28);
            border-color: rgba(110, 231, 183, 0.7);
        }
        .bulk-date-chip.state-absent {
            background: rgba(239, 68, 68, 0.28);
            border-color: rgba(252, 165, 165, 0.7);
        }
        .bulk-date-chip.state-leave {
            background: rgba(245, 158, 11, 0.28);
            border-color: rgba(253, 186, 116, 0.7);
        }
        .bulk-date-chip.state-late {
            background: rgba(59, 130, 246, 0.28);
            border-color: rgba(147, 197, 253, 0.7);
        }
        .bulk-date-chip button {
            border: none;
            background: transparent;
            color: #bfdbfe;
            cursor: pointer;
            font-size: 12px;
            padding: 0;
            line-height: 1;
        }
        .bulk-calendar {
            border: 1px solid rgba(148, 163, 184, 0.3);
            border-radius: 8px;
            padding: 10px;
            background: rgba(15, 23, 42, 0.65);
            margin-top: 10px;
        }
        .bulk-calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, minmax(34px, 1fr));
            gap: 6px;
        }
        .bulk-calendar-weekday {
            font-size: 11px;
            color: #93c5fd;
            text-align: center;
            font-weight: 700;
        }
        .bulk-day-btn {
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: rgba(30, 41, 59, 0.8);
            color: #e2e8f0;
            border-radius: 6px;
            min-height: 34px;
            cursor: pointer;
            font-size: 12px;
        }
        .bulk-day-btn.selected {
            background: linear-gradient(135deg, #0ea5e9, #2563eb);
            border-color: rgba(125, 211, 252, 0.95);
            color: #f8fafc;
            font-weight: 700;
        }
        .bulk-day-btn.state-present {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.9), rgba(5, 150, 105, 0.9));
            border-color: rgba(110, 231, 183, 0.95);
            color: #ecfdf5;
        }
        .bulk-day-btn.state-absent {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.92), rgba(185, 28, 28, 0.92));
            border-color: rgba(252, 165, 165, 0.95);
            color: #fef2f2;
        }
        .bulk-day-btn.state-leave {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.92), rgba(180, 83, 9, 0.92));
            border-color: rgba(253, 186, 116, 0.95);
            color: #fffbeb;
        }
        .bulk-day-btn.state-late {
            background: linear-gradient(135deg, rgba(59, 130, 246, 0.92), rgba(30, 64, 175, 0.92));
            border-color: rgba(147, 197, 253, 0.95);
            color: #eff6ff;
        }
        .bulk-day-btn.weekend {
            color: #fca5a5;
        }
        .bulk-slot-active {
            border-color: #60a5fa !important;
            background: rgba(59, 130, 246, 0.18) !important;
            color: #dbeafe !important;
        }
        .profile-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }
        .profile-metric {
            border: 1px solid rgba(148, 163, 184, 0.24);
            border-radius: 8px;
            background: rgba(15, 23, 42, 0.72);
            padding: 12px;
        }
        .profile-metric .label {
            font-size: 12px;
            color: #93c5fd;
            text-transform: uppercase;
            letter-spacing: 0.4px;
        }
        .profile-metric .value {
            font-size: 22px;
            font-weight: 800;
            color: #f8fafc;
        }
        .fee-status {
            font-weight: 700;
        }
        .fee-overdue {
            color: #fee2e2;
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid rgba(239, 68, 68, 0.45);
            padding: 4px 8px;
            border-radius: 999px;
            display: inline-flex;
            align-items: center;
            gap: 6px;
            animation: feePulse 1s infinite;
        }
        .fee-paid {
            color: #86efac;
        }
        .fee-due {
            color: #fde68a;
        }
        @keyframes feePulse {
            0%, 100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.4); }
            50% { box-shadow: 0 0 0 3px rgba(239, 68, 68, 0.75); }
        }

        .office-holder-roll {
            font-weight: 700;
            color: #fef9c3;
            background: linear-gradient(135deg, rgba(217, 119, 6, 0.2), rgba(251, 191, 36, 0.24));
            border: 1px solid rgba(251, 191, 36, 0.35) !important;
            border-radius: 6px;
        }

        /* LEADER RANK ALERT — warning when Leader drops below top 10 */
        /* Keyframes animate background-color on td elements (tr-level bg is hidden by td backgrounds) */
        @keyframes leaderWarnPulse {
            0%, 100% { background-color: rgba(251, 146, 60, 0.08); }
            50%       { background-color: rgba(251, 146, 60, 0.26); }
        }
        @keyframes leaderCritFlash {
            0%, 100% { background-color: rgba(239, 68, 68, 0.10); }
            50%       { background-color: rgba(239, 68, 68, 0.34); }
        }
        tr.leader-rank-warning td {
            animation: leaderWarnPulse 2.5s ease-in-out infinite;
        }
        tr.leader-rank-warning td.rank-cell::after {
            content: ' ⚠';
            font-size: 11px;
            color: #fb923c;
        }
        tr.leader-rank-critical td {
            animation: leaderCritFlash 1.1s ease-in-out infinite;
        }
        tr.leader-rank-critical td.rank-cell::after {
            content: ' 🔴';
            font-size: 11px;
        }

        /* POST-HOLDER VETO DEPLETION WARNING — veto_count ≤ 0 */
        tr.veto-depleted-holder td.vote-cell {
            color: #fca5a5 !important;
            background: rgba(239, 68, 68, 0.20) !important;
            font-weight: 800;
            border: 1px solid rgba(239, 68, 68, 0.4) !important;
        }
        tr.veto-depleted-holder td.total-cell {
            border-left: 2px solid rgba(239, 68, 68, 0.45) !important;
        }

        /* STUDENT SELF-ROW HIGHLIGHT */
        tr.my-own-row td {
            background: rgba(99, 102, 241, 0.10) !important;
            border-top: 1px solid rgba(99, 102, 241, 0.25) !important;
            border-bottom: 1px solid rgba(99, 102, 241, 0.25) !important;
        }
        tr.my-own-row td.rank-cell::after { content: ' 👤'; font-size: 11px; }

        /* PRIVACY ELLIPSIS ROW */
        tr.rank-ellipsis-row td {
            background: transparent !important;
            border: none !important;
            padding: 6px 16px !important;
            letter-spacing: 0.04em;
        }

        .student-meta {
            display: inline-flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 6px;
            margin-left: 0;
            vertical-align: middle;
        }

        .name-stack {
            display: inline-flex;
            align-items: center;
            flex-wrap: wrap;
            gap: 6px;
            max-width: 100%;
        }

        .meta-star,
        .meta-veto,
        .designation-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border-radius: 999px;
            padding: 2px 8px;
            font-size: 12px;
            font-weight: 700;
            letter-spacing: 0.2px;
            font-family: var(--counter-font);
        }

        .meta-star {
            background: linear-gradient(135deg, rgba(250, 204, 21, 0.25), rgba(245, 158, 11, 0.35));
            color: #fde68a;
            border: 1px solid rgba(250, 204, 21, 0.35);
        }

        .meta-veto {
            background: linear-gradient(135deg, rgba(248, 113, 113, 0.2), rgba(239, 68, 68, 0.35));
            color: #fecaca;
            border: 1px solid rgba(248, 113, 113, 0.35);
        }

        .designation-chip {
            background: linear-gradient(135deg, rgba(96, 165, 250, 0.25), rgba(99, 102, 241, 0.35));
            color: #dbeafe;
            border: 1px solid rgba(96, 165, 250, 0.4);
        }

        /* FORMS */
        .form-card {
            background: linear-gradient(160deg, rgba(17, 24, 39, 0.96) 0%, rgba(15, 23, 42, 0.96) 100%);
            border-radius: 12px;
            padding: 25px;
            border: 1px solid rgba(148, 163, 184, 0.22);
            box-shadow: 0 20px 40px rgba(0,0,0,0.35);
            margin-bottom: 25px;
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
            transition: border-color var(--dur-md) var(--spring-soft), box-shadow var(--dur-md) var(--ease-out);
            will-change: border-color, box-shadow;
        }

        .form-card:hover {
            border-color: rgba(148, 163, 184, 0.4);
            box-shadow: 0 24px 48px rgba(0,0,0,0.4);
        }

        .form-card h3 {
            margin-bottom: 20px;
            color: var(--primary);
            font-size: 18px;
            transition: color var(--dur-md) var(--ease-out);
        }

        .form-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 15px;
            margin-bottom: 15px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
            gap: 5px;
        }

        .form-group label {
            font-weight: 600;
            color: var(--text);
            transition: color var(--dur-xs) var(--ease-out);
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            padding: 10px 12px;
            border: 1px solid rgba(148, 163, 184, 0.2);
            border-radius: 6px;
            font-family: inherit;
            font-size: 16px;
            background: var(--bg-elevated);
            color: var(--text);
            transition: border-color var(--dur-sm) var(--spring-soft), background-color var(--dur-xs) var(--ease-out), box-shadow var(--dur-md) var(--spring-soft);\n            will-change: border-color, box-shadow, background-color;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            border-color: var(--primary);
            box-shadow: 0 0 0 3px var(--glow);
            background: rgba(15, 23, 42, 0.95);
        }

        .form-group textarea {
            resize: vertical;
            min-height: 80px;
        }

        .form-buttons {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        /* STATS */
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.88) 0%, rgba(16, 185, 129, 0.88) 100%);
            color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 14px 32px rgba(0,0,0,0.35);
            transition: transform var(--dur-sm) var(--spring-soft), box-shadow var(--dur-sm) var(--ease-out);
            will-change: transform;
            transform: translateZ(0);
        }

        .stat-card:hover {
            transform: translateY(-2px) translateZ(0);
            box-shadow: 0 20px 40px rgba(0,0,0,0.4);
        }

        .stat-card h4 {
            font-size: 12px;
            opacity: 0.9;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-card .value {
            font-size: 28px;
            font-weight: 700;
            font-family: var(--number-font);
        }

        /* MODAL */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: var(--bg-elevated);
            padding: 30px;
            border-radius: 8px;
            max-width: 500px;
            width: 90%;
            max-height: 90vh;
            overflow-y: auto;
            box-shadow: 0 20px 25px rgba(0,0,0,0.2);
        }

        .toggle-group {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .toggle-group label {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 12px;
            font-weight: 600;
            color: var(--text-muted);
            text-transform: none;
            letter-spacing: 0;
        }

        .col-hidden {
            display: none !important;
        }

        .section-subtitle {
            color: var(--text-muted);
            font-size: 13px;
            margin-top: -8px;
            margin-bottom: 15px;
        }

        .party-members-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
            margin-bottom: 15px;
        }

        .group-vote-info-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 10px;
            margin: 10px 0 4px;
        }

        .group-vote-info-card {
            border: 1px solid var(--border);
            border-radius: 10px;
            background: linear-gradient(135deg, rgba(37,99,235,0.14), rgba(16,185,129,0.08));
            padding: 10px 12px;
        }

        .group-vote-info-card .label {
            display: block;
            font-size: 11px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 4px;
        }

        .group-vote-info-card .value {
            font-size: 15px;
            font-weight: 700;
            color: var(--text);
        }

        .group-vote-dialog {
            max-width: 980px;
            width: 95%;
            border-radius: 14px;
            overflow: hidden;
        }

        .group-vote-dialog .validation-modal-header {
            background: linear-gradient(135deg, rgba(37,99,235,0.25), rgba(14,165,233,0.12), rgba(16,185,129,0.18));
        }

        .group-vote-cards {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
            gap: 12px;
        }

        .group-vote-card {
            border: 1px solid var(--border);
            border-radius: 12px;
            background: linear-gradient(160deg, rgba(15,23,42,0.72), rgba(2,132,199,0.2));
            padding: 12px;
            box-shadow: 0 12px 24px rgba(0,0,0,0.28);
        }

        .celebrate {
            animation: celebratePulse 1.4s ease-in-out infinite;
        }
        @keyframes celebratePulse {
            0% { box-shadow: 0 0 0 0 rgba(34,197,94,0.5); }
            70% { box-shadow: 0 0 0 24px rgba(34,197,94,0); }
            100% { box-shadow: 0 0 0 0 rgba(34,197,94,0); }
        }

        .melancholy {
            animation: melancholyFade 1.2s ease-in-out infinite;
        }
        @keyframes melancholyFade {
            0% { opacity: 1; filter: grayscale(0.1); }
            50% { opacity: 0.6; filter: grayscale(0.6); }
            100% { opacity: 1; filter: grayscale(0.1); }
        }

        .group-vote-card h4 {
            margin: 0 0 8px;
            color: #e0f2fe;
            font-size: 16px;
        }

        .group-vote-card .meta {
            color: #bae6fd;
            font-size: 12px;
            margin-bottom: 10px;
        }

        .result-modal-content {
            max-width: 1400px;
            width: 92vw;
            min-height: 70vh;
            border-radius: 16px;
            overflow: hidden;
            position: relative;
            border: 1px solid rgba(148, 163, 184, 0.35);
            background: radial-gradient(circle at top left, rgba(56, 189, 248, 0.08), rgba(15, 23, 42, 0.9));
            box-shadow: 0 30px 80px rgba(0,0,0,0.5);
        }

        .result-modal-content::before {
            content: "";
            position: absolute;
            inset: 0;
            background: radial-gradient(circle at 20% 20%, rgba(14, 116, 144, 0.35), transparent 60%),
                        radial-gradient(circle at 80% 0%, rgba(14, 116, 144, 0.22), transparent 55%);
            opacity: 0.8;
            pointer-events: none;
        }

        .result-modal-body {
            font-size: 20px;
            line-height: 1.6;
            color: #e2e8f0;
            text-shadow: 0 2px 10px rgba(0,0,0,0.45);
            max-height: 52vh;
            overflow-y: auto;
        }

        .result-modal-banner {
            font-size: 26px;
            font-weight: 800;
            letter-spacing: 0.8px;
            text-transform: uppercase;
            color: #f8fafc;
            margin-bottom: 14px;
        }

        .confetti {
            position: absolute;
            inset: 0;
            pointer-events: none;
            background-image:
                radial-gradient(circle, rgba(34,197,94,0.7) 2px, transparent 3px),
                radial-gradient(circle, rgba(59,130,246,0.7) 2px, transparent 3px),
                radial-gradient(circle, rgba(250,204,21,0.7) 2px, transparent 3px);
            background-size: 120px 120px;
            animation: confettiDrift 6s linear infinite;
            opacity: 0.7;
        }

        @keyframes confettiDrift {
            0% { background-position: 0 0, 40px 60px, 80px 20px; }
            100% { background-position: 120px 240px, 160px 300px, 220px 200px; }
        }

        .rain {
            position: absolute;
            inset: 0;
            pointer-events: none;
            background: repeating-linear-gradient(
                120deg,
                rgba(148, 163, 184, 0.12),
                rgba(148, 163, 184, 0.12) 2px,
                transparent 2px,
                transparent 10px
            );
            animation: rainFall 2.8s linear infinite;
            opacity: 0.5;
        }

        @keyframes rainFall {
            0% { background-position: 0 0; }
            100% { background-position: 120px 240px; }
        }

        .result-modal-content.celebrate {
            border-color: rgba(34, 197, 94, 0.6);
        }

        .result-modal-content.melancholy {
            border-color: rgba(148, 163, 184, 0.5);
        }

        .result-list {
            margin: 0;
            padding-left: 26px;
            display: grid;
            gap: 8px;
        }

        .result-list li {
            font-size: 19px;
            font-weight: 700;
            letter-spacing: 0.2px;
            line-height: 1.45;
        }

        .result-term-label { color: #f8fafc; }
        .result-term-value { color: #e2e8f0; }
        .result-term-winner .result-term-value { color: #86efac; }
        .result-term-votes .result-term-value { color: #93c5fd; }
        .result-term-threshold .result-term-value { color: #fcd34d; }
        .result-term-status .result-term-value { color: #f9a8d4; }
        .result-term-abstain .result-term-value { color: #c4b5fd; }
        .result-term-nota .result-term-value { color: #fda4af; }
        .result-term-reason .result-term-value { color: #fecaca; }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-header h2 {
            color: var(--primary);
            font-size: 20px;
        }

        .close-btn {
            background: transparent;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--text-muted);
            padding: 0;
        }

        .close-btn:hover {
            color: var(--text);
        }

        /* ALERTS */
        .alert {
            padding: 12px 16px;
            border-radius: 6px;
            margin-bottom: 15px;
            display: flex;
            align-items: center;
            gap: 10px;
            animation: fadeIn var(--dur-sm) var(--ease-out) both;
            will-change: auto;
            contain: layout style paint;
        }

        @keyframes slideIn {
            from { opacity: 0; transform: translateY(-10px); }
            to   { opacity: 1; transform: translateY(0); }
        }

        .alert-success {
            background: rgba(22, 163, 74, 0.1);
            color: var(--success);
            border-left: 4px solid var(--success);
        }

        .alert-danger {
            background: rgba(220, 38, 38, 0.1);
            color: var(--danger);
            border-left: 4px solid var(--danger);
        }

        .alert-info {
            background: rgba(37, 99, 235, 0.1);
            color: var(--primary);
            border-left: 4px solid var(--primary);
        }

        /* VALIDATION MODAL - CENTER SCREEN */
        .validation-modal {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            animation: iosFadeIn var(--dur-sm) var(--ease-out) both;
            backdrop-filter: blur(3px);
            -webkit-backdrop-filter: blur(3px);
        }

        .validation-modal.hidden {
            display: none !important;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to   { opacity: 1; }
        }
        @keyframes fadeOut {
            from { opacity: 1; }
            to   { opacity: 0; }
        }

        .validation-modal-content {
            background: var(--bg-card);
            border: 2px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 25px 80px rgba(0, 0, 0, 0.6);
            max-width: 500px;
            width: 90%;
            padding: 0;
            animation: fadeIn var(--dur-sm) var(--ease-out) both;
        }

        @keyframes iosFadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        @keyframes iosSlideUp {
            from { opacity: 0; transform: translateY(12px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .validation-modal-header {
            padding: 20px;
            border-bottom: 1px solid var(--border);
            background: linear-gradient(135deg, rgba(37, 99, 235, 0.1), rgba(16, 185, 129, 0.05));
        }

        .validation-modal-header h3 {
            margin: 0;
            color: var(--primary);
            font-size: 20px;
            font-weight: 600;
        }

        .validation-modal-body {
            padding: 24px 20px;
            color: var(--text);
            line-height: 1.6;
            font-size: 16px;
        }

        .validation-modal-body p {
            margin: 0;
            word-wrap: break-word;
        }

        .validation-modal-footer {
            padding: 16px 20px;
            border-top: 1px solid var(--border);
            display: flex;
            gap: 10px;
            justify-content: flex-end;
        }

        .validation-modal-footer button {
            padding: 10px 24px;
            border-radius: 6px;
            border: none;
            font-size: 14px;
            font-weight: 600;
            cursor: pointer;
            transition: background-color var(--dur-xs) var(--ease-out), box-shadow var(--dur-sm) var(--ease-out), color var(--dur-xs) var(--ease-out), transform var(--dur-xs) var(--spring);
        }

        .btn-primary {
            background: var(--primary);
            color: white;
        }

        .btn-primary:hover {
            background: var(--primary-dark);
            box-shadow: 0 6px 20px rgba(96, 165, 250, 0.3);
        }

        /* CONFIRM MODAL (used for Resources request/transaction confirmation) */
        .confirm-modal-content {
            max-width: 780px;
        }

        .confirm-modal-body {
            font-size: 15px;
        }

        .confirm-details {
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 14px;
            background: rgba(148, 163, 184, 0.06);
        }

        .confirm-details .row {
            display: flex;
            gap: 12px;
            justify-content: space-between;
            padding: 6px 0;
            border-bottom: 1px dashed rgba(148, 163, 184, 0.25);
        }

        .confirm-details .row:last-child {
            border-bottom: none;
        }

        .confirm-details .k {
            color: var(--text-muted);
            font-weight: 600;
        }

        .confirm-details .v {
            color: var(--text);
            font-family: var(--number-font);
            text-align: right;
        }

        /* Resources: Transactions row states (override base scoreboard striping/hover). */
        .scoreboard tbody tr.txn-row-complete td,
        .scoreboard tbody tr.txn-row-complete:hover td {
            background: rgba(16, 185, 129, 0.18) !important;
            background-color: rgba(16, 185, 129, 0.18) !important;
            background-image: none !important;
        }

        .scoreboard tbody tr.txn-row-open td,
        .scoreboard tbody tr.txn-row-open:hover td {
            background: rgba(239, 68, 68, 0.14) !important;
            background-color: rgba(239, 68, 68, 0.14) !important;
            background-image: none !important;
        }

        /* SKELETON LOADERS */
        @keyframes _skeletonShimmer {
            0%   { background-position: -200% 0; }
            100% { background-position:  200% 0; }
        }
        tr.skeleton-row td {
            background: linear-gradient(90deg, #1e293b 25%, #263548 50%, #1e293b 75%) !important;
            background-size: 200% 100% !important;
            animation: _skeletonShimmer 1.4s ease-in-out infinite !important;
            color: transparent !important;
            border-radius: 3px;
            pointer-events: none;
            user-select: none;
        }

        /* RENDER ERROR CARD */
        .render-error-card {
            margin: 16px;
            padding: 14px 18px;
            border: 1px solid #ef4444;
            border-radius: 8px;
            color: #ef4444;
            background: rgba(239,68,68,0.07);
            font-size: 13px;
        }
        .render-error-card a { color: #f87171; }

        /* PAGINATION BAR */
        .sb-pagination {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 12px;
            font-size: 13px;
            color: var(--text-muted, #94a3b8);
            flex-wrap: wrap;
        }
        .sb-pagination button {
            padding: 4px 12px;
            font-size: 12px;
            border-radius: 4px;
        }
        .sb-pagination .sb-page-info {
            flex: 1;
            text-align: center;
        }

        /* RESPONSIVE */
        @media (max-width: 768px) {
            .header {
                position: relative;
                top: auto;
                z-index: 1;
                padding: 10px 0 8px;
                margin-bottom: 10px;
                box-shadow: 0 8px 18px rgba(0,0,0,0.25);
            }
            .header::after {
                opacity: 0.35;
            }
            .header h1 { font-size: 18px; letter-spacing: 0.6px; }
            .header .subhead { font-size: 13px; letter-spacing: 0.5px; }
            .header .tagline { font-size: 10px; opacity: 0.7; }
            .container { padding-bottom: calc(96px + env(safe-area-inset-bottom, 0px)); }
            .form-grid { grid-template-columns: 1fr; }
            .controls { grid-template-columns: 1fr; }
            .tabs {
                overflow-x: auto;
                overflow-y: hidden;
                flex-wrap: nowrap;
                white-space: nowrap;
                -webkit-overflow-scrolling: touch;
                gap: 4px;
                padding-bottom: 6px;
            }
            .tab-button {
                flex: 0 0 auto;
                min-height: 44px;
                padding: 10px 12px;
                font-size: 14px;
            }
            .stats-grid { grid-template-columns: repeat(2, 1fr); }
            .scoreboard { font-size: 13px; }
            .scoreboard td, .scoreboard th { padding: 9px 6px; }
            .month-nav { gap: 5px; }
            .month-button { padding: 6px 12px; font-size: 12px; }
            .form-card {
                padding: 14px;
                margin-bottom: 14px;
            }
            .form-buttons {
                display: grid;
                grid-template-columns: 1fr 1fr;
                gap: 8px;
            }
            .form-buttons button {
                width: 100%;
                min-height: 44px;
            }
            .master-update-btn {
                left: 10px;
                right: 10px;
                bottom: 10px;
                border-radius: 12px;
                justify-content: center;
            }
            .scoreboard th.sticky-left,
            .scoreboard td.sticky-left,
            .scoreboard th.sticky-right,
            .scoreboard td.sticky-right {
                position: static;
                left: auto !important;
                right: auto !important;
                box-shadow: none;
            }
        }

        @media (min-width: 1600px) {
            .container {
                max-width: 1720px;
            }
            body {
                font-size: 18px;
            }
            input, select, button {
                font-size: 18px;
            }
            label {
                font-size: 15px;
            }
            .scoreboard {
                font-size: 18px;
            }
            .scoreboard td,
            .scoreboard th {
                padding: 14px 12px;
            }
            .tab-button {
                font-size: 16px;
                padding-top: 13px;
                padding-bottom: 13px;
            }
            .form-card h3 {
                font-size: 23px;
            }
            .section-subtitle,
            .sync-meta {
                font-size: 15px;
            }
            .scoreboard td button,
            .scoreboard td .button-like {
                font-size: 16px !important;
                padding: 9px 12px;
            }
        }

        @media (min-width: 1920px) {
            body {
                font-size: 19px;
            }
            input, select, button {
                font-size: 19px;
            }
            .scoreboard {
                font-size: 19px;
            }
            .scoreboard td,
            .scoreboard th {
                padding: 16px 14px;
            }
            .tab-button {
                font-size: 18px;
            }
        }

        /* LOADING */
        .loading {
            text-align: center;
            padding: 40px 20px;
            color: var(--text-muted);
        }

        .spinner {
            display: inline-block;
            width: 30px;
            height: 30px;
            border: 3px solid var(--border);
            border-top-color: var(--primary);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes iosTabFadeIn {
            from { 
                opacity: 0; 
                transform: translateY(8px);
            }
            to { 
                opacity: 1; 
                transform: translateY(0); 
            }
        }

        .tab-content {
            animation: iosTabFadeIn var(--dur-md) var(--spring-soft) both;
        }

        .hidden { 
            display: none !important; 
            opacity: 0;
        }

        .text-center { text-align: center; }
        .mt-20 { margin-top: 20px; }
        .mb-20 { margin-bottom: 20px; }

        /* EXPORT BUTTON */
        .export-area {
            background: linear-gradient(145deg, rgba(15, 23, 42, 0.9) 0%, rgba(17, 24, 39, 0.9) 100%);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            border: 1px solid rgba(148, 163, 184, 0.2);
            box-shadow: 0 12px 28px rgba(0,0,0,0.35);
        }

        .tab-alert {
            animation: flashPulse 1.2s infinite;
            border-color: rgba(250, 204, 21, 0.5) !important;
            box-shadow: 0 0 0 2px rgba(250, 204, 21, 0.25);
        }

        .tab-count {
            display: inline-flex;
            min-width: 20px;
            height: 20px;
            border-radius: 999px;
            align-items: center;
            justify-content: center;
            margin-left: 8px;
            padding: 0 6px;
            background: rgba(248, 113, 113, 0.2);
            border: 1px solid rgba(248, 113, 113, 0.45);
            color: #fecaca;
            font-size: 11px;
            font-weight: 700;
            line-height: 1;
        }

        /* NOTIFICATIONS TAB */
        .notification-list { display: grid; grid-template-columns: 1fr; }
        .notif-filter-bar {
            display: flex; gap: 6px; flex-wrap: wrap; margin-bottom: 14px; align-items: center;
        }
        .notif-filter-bar button {
            padding: 4px 13px; font-size: 12px; border-radius: 20px;
            border: 1px solid rgba(148,163,184,0.25); background: rgba(15,23,42,0.5);
            color: #64748b; cursor: pointer;
            transition: color var(--dur-xs) var(--ease-out), border-color var(--dur-xs) var(--ease-out), background-color var(--dur-xs) var(--ease-out), transform var(--dur-xxs) var(--spring-soft);
            white-space: nowrap;
        }
        .notif-filter-bar button:hover { color: #94a3b8; border-color: rgba(148,163,184,0.45); }
        .notif-filter-bar button.nf-active       { background: rgba(99,102,241,0.15); border-color: #818cf8; color: #a5b4fc; }
        .notif-filter-bar button.nf-danger-active{ background: rgba(239,68,68,0.15);  border-color: #ef4444; color: #fca5a5; }
        .notif-filter-bar button.nf-warn-active  { background: rgba(245,158,11,0.15); border-color: #f59e0b; color: #fcd34d; }
        .notif-filter-bar button.nf-info-active  { background: rgba(56,189,248,0.15); border-color: #38bdf8; color: #7dd3fc; }
        .notif-section-header {
            font-size: 10px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase;
            color: #475569; margin: 16px 0 8px; padding-bottom: 6px;
            border-bottom: 1px solid rgba(148,163,184,0.1);
            display: flex; align-items: center; justify-content: space-between;
        }
        .notif-section-header i { margin-right: 5px; }
        .notif-count-badge {
            font-size: 10px; padding: 1px 8px; border-radius: 10px;
            background: rgba(99,102,241,0.2); color: #a5b4fc; font-weight: 700;
        }
        .notif-card {
            display: flex; gap: 11px; align-items: flex-start;
            padding: 11px 13px; border-radius: 10px;
            border: 1px solid rgba(148,163,184,0.13); border-left-width: 3px;
            background: rgba(15,23,42,0.65);
            cursor: pointer; width: 100%; text-align: left;
            transition: background var(--dur-xs) var(--ease-out), transform var(--dur-xs) var(--spring);
        }
        .notif-card:hover     { background: rgba(30,41,59,0.8); transform: translateX(4px); }
        .notif-card.selected  { box-shadow: 0 0 0 1px rgba(99,102,241,0.35); background: rgba(30,41,59,0.85); }
        .notif-card.danger    { border-left-color: #ef4444; }
        .notif-card.warn      { border-left-color: #f59e0b; }
        .notif-card.info      { border-left-color: #38bdf8; }
        .notif-card-icon { font-size: 16px; padding-top: 1px; flex-shrink: 0; width: 20px; text-align: center; }
        .notif-card.danger .notif-card-icon { color: #f87171; }
        .notif-card.warn   .notif-card-icon { color: #fbbf24; }
        .notif-card.info   .notif-card-icon { color: #38bdf8; }
        .notif-card-body { flex: 1; min-width: 0; }
        .notif-card-title  { font-weight: 700; font-size: 13.5px; color: #e2e8f0; margin-bottom: 3px; }
        .notif-card-detail { font-size: 12.5px; color: #94a3b8; line-height: 1.4; }
        .notif-card-meta   { font-size: 11px; color: #475569; margin-top: 4px; }
        .notif-live-dot {
            width: 7px; height: 7px; border-radius: 50%; flex-shrink: 0; margin-top: 8px;
        }
        .notif-live-dot.danger { background: #ef4444; box-shadow: 0 0 5px #ef4444; animation: notifPulse 1.6s ease-in-out infinite; }
        .notif-live-dot.warn   { background: #f59e0b; box-shadow: 0 0 5px #f59e0b; animation: notifPulse 2s   ease-in-out infinite; }
        .notif-live-dot.info   { background: #38bdf8; }
        @keyframes notifPulse {
            0%,100% { opacity: 1; transform: scale(1); }
            50%     { opacity: 0.35; transform: scale(0.65); }
        }
        .notif-detail-panel {
            margin-top: 10px; border-radius: 12px; padding: 15px 17px;
            border: 1px solid rgba(99,102,241,0.2);
            background: linear-gradient(135deg, rgba(30,27,75,0.45), rgba(15,23,42,0.95));
        }
        .notif-detail-panel.danger { border-color: rgba(239,68,68,0.3); background: linear-gradient(135deg,rgba(127,29,29,0.3),rgba(15,23,42,0.95)); }
        .notif-detail-panel.warn   { border-color: rgba(245,158,11,0.3); background: linear-gradient(135deg,rgba(113,63,18,0.3),rgba(15,23,42,0.95)); }
        .notif-detail-panel.info   { border-color: rgba(56,189,248,0.3);  background: linear-gradient(135deg,rgba(12,74,110,0.25),rgba(15,23,42,0.95)); }
        .ndp-icon  { font-size: 24px; margin-bottom: 7px; }
        .ndp-title { font-size: 16px; font-weight: 700; color: #e2e8f0; margin-bottom: 5px; }
        .ndp-detail{ font-size: 13px; color: #cbd5e1; line-height: 1.5; }
        .ndp-meta  { font-size: 11px; color: #64748b; margin-top: 7px; }
        .notif-empty { text-align: center; padding: 30px 16px; color: #334155; }
        .notif-empty i { font-size: 32px; display: block; margin-bottom: 8px; }
        .notif-empty p { margin: 0; font-size: 13px; }
        .notif-history-row {
            display: flex; gap: 9px; align-items: flex-start;
            padding: 7px 10px; border-radius: 7px; cursor: default;
            transition: background var(--dur-xs) var(--ease-out);
        }
        .notif-history-row:hover { background: rgba(30,41,59,0.5); }
        .nhr-dot { width: 6px; height: 6px; border-radius: 50%; margin-top: 5px; flex-shrink: 0; }
        .notif-history-row.danger .nhr-dot { background: #f87171; }
        .notif-history-row.warn   .nhr-dot { background: #fbbf24; }
        .notif-history-row.info   .nhr-dot { background: #38bdf8; }
        .nhr-body { flex: 1; min-width: 0; }
        .nhr-title { color: #94a3b8; font-size: 12px; font-weight: 600; }
        .nhr-stamp { color: #334155; font-size: 11px; margin-top: 1px; }
        .notif-history-row.live-in-log .nhr-title::after {
            content: ' LIVE'; font-size: 9px; color: #4ade80; font-weight: 800;
            margin-left: 4px; vertical-align: middle;
        }

        /* ═══════════════════════════════════════════════════════════════════
           iOS-STYLE MOTION PRIMITIVES
           All durations/easings use the --dur-* / --ease-* / --spring-*
           custom properties defined in :root above.
        ═══════════════════════════════════════════════════════════════════ */

        /* ── Entrance keyframes ─────────────────────────────────────────── */
        @keyframes iosSlideUp {
            from { opacity: 0; transform: translateY(12px) scale(0.988); }
            to   { opacity: 1; transform: translateY(0)    scale(1);     }
        }
        @keyframes iosSlideDown {
            from { opacity: 0; transform: translateY(-16px) scale(0.985); }
            to   { opacity: 1; transform: translateY(0)     scale(1);    }
        }
        @keyframes iosSlideInRight {
            from { opacity: 0; transform: translateX(22px); }
            to   { opacity: 1; transform: translateX(0);    }
        }
        @keyframes iosSlideInLeft {
            from { opacity: 0; transform: translateX(-22px); }
            to   { opacity: 1; transform: translateX(0);     }
        }
        @keyframes iosScaleIn {
            from { opacity: 0; transform: scale(0.88); }
            to   { opacity: 1; transform: scale(1);    }
        }
        @keyframes iosFadeIn {
            from { opacity: 0; transform: scale(0.98); }
            to   { opacity: 1; transform: scale(1);    }
        }
        /* ── Exit keyframes ─────────────────────────────────────────────── */
        @keyframes iosModalOut {
            from { opacity: 1; transform: scale(1);    }
            to   { opacity: 0; transform: scale(0.93); }
        }
        @keyframes iosFadeOut {
            from { opacity: 1; }
            to   { opacity: 0; }
        }
        /* ── Table row stagger entrance ─────────────────────────────────── */
        @keyframes iosRowIn {
            from { opacity: 0; transform: translateY(7px); }
            to   { opacity: 1; transform: translateY(0);   }
        }

        /* ── Tab switch container entrance (simple) ─────────────────────── */
        .tab-entering {
            animation: fadeIn var(--dur-sm) var(--ease-out) both;
        }

        /* ── Tab-scoped card stagger (applied by .tab-entering parent) ──── */
        .tab-entering .form-card:nth-child(1)  { animation: fadeIn var(--dur-sm) var(--ease-out) 0ms  both; }
        .tab-entering .form-card:nth-child(2)  { animation: fadeIn var(--dur-sm) var(--ease-out) 20ms both; }
        .tab-entering .form-card:nth-child(3)  { animation: fadeIn var(--dur-sm) var(--ease-out) 40ms both; }
        .tab-entering .form-card:nth-child(n+4){ animation: fadeIn var(--dur-sm) var(--ease-out) 60ms both; }

        /* ── .ios-appear utility — add to any element for a one-shot pop-in */
        .ios-appear {
            animation: fadeIn var(--dur-sm) var(--ease-out) both;
        }
        .ios-appear-fast {
            animation: fadeIn var(--dur-sm) var(--ease-out) both;
        }
        .ios-scale-in {
            animation: fadeIn var(--dur-sm) var(--ease-out) both;
        }

        /* ── Table row stagger (add .ios-rows-animate to the <table>) ───── */
        .ios-rows-animate tbody tr { animation: none; }
        .ios-rows-animate tbody tr:nth-child(-n+24) { animation: fadeIn var(--dur-sm) var(--ease-out) both; will-change: opacity; }
        .ios-rows-animate tbody tr:nth-child(1)   { animation-delay:   0ms; }
        .ios-rows-animate tbody tr:nth-child(2)   { animation-delay:  14ms; }
        .ios-rows-animate tbody tr:nth-child(3)   { animation-delay:  24ms; }
        .ios-rows-animate tbody tr:nth-child(4)   { animation-delay:  34ms; }
        .ios-rows-animate tbody tr:nth-child(5)   { animation-delay:  44ms; }
        .ios-rows-animate tbody tr:nth-child(6)   { animation-delay:  54ms; }
        .ios-rows-animate tbody tr:nth-child(7)   { animation-delay:  64ms; }
        .ios-rows-animate tbody tr:nth-child(8)   { animation-delay:  74ms; }
        .ios-rows-animate tbody tr:nth-child(n+9) { animation-delay:  84ms; }

        /* ── Modal entrance via .active class ───────────────────────────── */
        .modal.active .modal-content {
            animation: fadeIn var(--dur-sm) var(--ease-out) both;
        }
        .modal.active {
            backdrop-filter: blur(2px);
            -webkit-backdrop-filter: blur(2px);
            background: rgba(2, 6, 23, 0.58);
        }
        .modal.modal-exiting .modal-content {
            animation: fadeOut 120ms var(--ease-in) forwards !important;
        }

        .group-a-row td {
            background: rgba(255, 255, 255, 0.04);
            border-top: 1px solid rgba(255, 255, 255, 0.08);
            border-bottom: 1px solid rgba(0, 0, 0, 0.15);
        }
        .group-b-row td {
            /* Excel: #006600 dark green */
            background: linear-gradient(90deg, rgba(0, 102, 0, 0.75), rgba(0, 160, 0, 0.28));
            border-top: 1px solid rgba(0, 190, 0, 0.65);
            border-bottom: 1px solid rgba(0, 60, 0, 0.65);
            box-shadow: inset 0 0 0 1px rgba(0, 160, 0, 0.18);
        }
        .group-c-row td {
            background: rgba(255, 255, 255, 0.02);
            border-top: 1px solid rgba(255, 255, 255, 0.06);
            border-bottom: 1px solid rgba(0, 0, 0, 0.12);
        }
        .group-d-row td {
            /* Excel: #580298 deep purple */
            background: linear-gradient(90deg, rgba(88, 2, 152, 0.75), rgba(130, 40, 200, 0.30));
            border-top: 1px solid rgba(165, 85, 235, 0.65);
            border-bottom: 1px solid rgba(55, 1, 100, 0.65);
            box-shadow: inset 0 0 0 1px rgba(140, 60, 210, 0.22);
        }
        .group-e-row td {
            background: linear-gradient(90deg, rgba(124, 58, 237, 0.72), rgba(167, 139, 250, 0.32));
            border-top: 1px solid rgba(196, 181, 253, 0.9);
            border-bottom: 1px solid rgba(91, 33, 182, 0.65);
            box-shadow: inset 0 0 0 1px rgba(196, 181, 253, 0.25);
        }
        .group-f-row td {
            background: linear-gradient(90deg, rgba(185, 28, 28, 0.72), rgba(239, 68, 68, 0.32));
            border-top: 1px solid rgba(252, 165, 165, 0.9);
            border-bottom: 1px solid rgba(127, 29, 29, 0.65);
            box-shadow: inset 0 0 0 1px rgba(252, 165, 165, 0.25);
        }
        .group-g-row td {
            background: linear-gradient(90deg, rgba(13, 148, 136, 0.72), rgba(45, 212, 191, 0.32));
            border-top: 1px solid rgba(153, 246, 228, 0.9);
            border-bottom: 1px solid rgba(17, 94, 89, 0.65);
            box-shadow: inset 0 0 0 1px rgba(153, 246, 228, 0.25);
        }
        .group-h-row td {
            background: linear-gradient(90deg, rgba(161, 98, 7, 0.72), rgba(245, 158, 11, 0.32));
            border-top: 1px solid rgba(252, 211, 77, 0.9);
            border-bottom: 1px solid rgba(113, 63, 18, 0.65);
            box-shadow: inset 0 0 0 1px rgba(252, 211, 77, 0.25);
        }
        .group-ungrouped-row td {
            background: linear-gradient(90deg, rgba(71, 85, 105, 0.5), rgba(148, 163, 184, 0.22));
            border-top: 1px solid rgba(148, 163, 184, 0.65);
            border-bottom: 1px solid rgba(71, 85, 105, 0.45);
            box-shadow: inset 0 0 0 1px rgba(148, 163, 184, 0.2);
        }
        #attendanceTable tbody tr.attendance-status-present td {
            background: rgba(34, 197, 94, 0.2) !important;
            border-color: rgba(34, 197, 94, 0.55) !important;
            background-image: none !important;
            color: #eafff1 !important;
        }
        #attendanceTable tbody tr.attendance-status-absent td {
            background: rgba(239, 68, 68, 0.22) !important;
            border-color: rgba(239, 68, 68, 0.6) !important;
            background-image: none !important;
            color: #ffecec !important;
        }
        #attendanceTable tbody tr.attendance-status-leave td {
            background: rgba(202, 138, 4, 0.26) !important;
            border-color: rgba(202, 138, 4, 0.62) !important;
            background-image: none !important;
            color: #fff8e1 !important;
        }
        #attendanceTable tbody tr.attendance-status-late td {
            background: rgba(16, 185, 129, 0.22) !important;
            border-color: rgba(16, 185, 129, 0.6) !important;
            background-image: none !important;
            color: #ecfff7 !important;
        }
        #attendanceTable tbody tr.attendance-status-present td,
        #attendanceTable tbody tr.attendance-status-absent td,
        #attendanceTable tbody tr.attendance-status-leave td,
        #attendanceTable tbody tr.attendance-status-late td {
            mix-blend-mode: normal !important;
        }
        #attendanceTable tbody tr.attendance-status-present select,
        #attendanceTable tbody tr.attendance-status-present input {
            background: rgba(22, 163, 74, 0.24) !important;
            border-color: rgba(34, 197, 94, 0.7) !important;
            color: #f0fff7 !important;
        }
        #attendanceTable tbody tr.attendance-status-absent select,
        #attendanceTable tbody tr.attendance-status-absent input {
            background: rgba(220, 38, 38, 0.24) !important;
            border-color: rgba(239, 68, 68, 0.74) !important;
            color: #fff2f2 !important;
        }
        #attendanceTable tbody tr.attendance-status-leave select,
        #attendanceTable tbody tr.attendance-status-leave input {
            background: rgba(161, 98, 7, 0.28) !important;
            border-color: rgba(202, 138, 4, 0.76) !important;
            color: #fff8df !important;
        }
        #attendanceTable tbody tr.attendance-status-late select,
        #attendanceTable tbody tr.attendance-status-late input {
            background: rgba(5, 150, 105, 0.24) !important;
            border-color: rgba(16, 185, 129, 0.74) !important;
            color: #edfff8 !important;
        }

        #scoreboardTable th.sticky-left,
        #scoreboardTable th.sticky-right {
            font-size: clamp(18px, 1.45vw, 24px);
            font-weight: 800;
        }
        #scoreboardTable th.rank-cell,
        #scoreboardTable th.sticky-left-1,
        #scoreboardTable th.sticky-left-3 {
            font-size: clamp(14px, 1.05vw, 17px) !important;
            letter-spacing: 0.1px;
        }
        #scoreboardTable td.sticky-left-1,
        #scoreboardTable td.sticky-left-2,
        #scoreboardTable td.sticky-left-3 {
            font-size: clamp(15px, 1.25vw, 21px);
            font-weight: 700;
            line-height: 1.2;
        }
        #scoreboardTable td.sticky-left-2 {
            font-size: clamp(14px, 1.15vw, 19px);
            line-height: 1.18;
        }
        #scoreboardTable td.sticky-left-2 .name-stack {
            font-size: inherit;
        }
        #scoreboardTable td.sticky-left-3 {
            font-size: clamp(15px, 1.15vw, 18px);
            text-align: center;
        }
        #scoreboardTable td.sticky-left-1 {
            text-align: center;
            font-size: clamp(14px, 1.05vw, 18px);
        }
        #attendanceStudentReportTable td.att-pct-high {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.28), rgba(5, 150, 105, 0.38));
            color: #dcfce7;
            font-weight: 800;
        }
        #attendanceStudentReportTable td.att-pct-mid {
            background: linear-gradient(135deg, rgba(245, 158, 11, 0.25), rgba(202, 138, 4, 0.38));
            color: #fef3c7;
            font-weight: 800;
        }
        #attendanceStudentReportTable td.att-pct-low {
            background: linear-gradient(135deg, rgba(239, 68, 68, 0.28), rgba(185, 28, 28, 0.4));
            color: #fee2e2;
            font-weight: 800;
        }
        .record-column-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 10px 14px;
            margin: 6px 0 10px;
            align-items: center;
        }
        .record-column-controls label {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            font-size: 13px;
            color: var(--text-muted);
            cursor: pointer;
            margin: 0;
        }

        .record-date-strip-wrap {
            margin: 10px 0 12px;
            padding: 10px;
            border: 1px solid var(--border);
            border-radius: 10px;
            background: rgba(148, 163, 184, 0.06);
        }

        .record-date-strip-head {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .record-date-strip-head .month-label {
            font-size: 12px;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.4px;
            font-weight: 700;
        }

        .record-date-strip-head .active-date-label {
            font-size: 12px;
            color: var(--primary);
            font-weight: 700;
        }

        .record-date-strip {
            display: flex;
            gap: 6px;
            overflow-x: auto;
            padding-bottom: 2px;
            scrollbar-width: thin;
            -webkit-overflow-scrolling: touch;
            scroll-behavior: smooth;
            overscroll-behavior-x: contain;
        }

        .record-date-chip {
            min-width: 46px;
            padding: 6px 8px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg-elevated);
            color: var(--text);
            font-size: 12px;
            font-weight: 700;
            line-height: 1.2;
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 2px;
            cursor: pointer;
            user-select: none;
            transition: border-color var(--dur-xs) var(--ease-out), background-color var(--dur-xs) var(--ease-out), transform var(--dur-xs) var(--spring);
        }

        .record-date-chip:hover {
            border-color: var(--primary);
            transform: translateY(-1px);
        }

        .record-date-chip.active {
            background: rgba(37, 99, 235, 0.22);
            border-color: var(--primary);
            box-shadow: 0 0 0 2px rgba(96, 165, 250, 0.15) inset;
        }

        .record-date-chip .dnum {
            font-size: 13px;
        }

        .record-date-chip .dday {
            font-size: 10px;
            color: var(--text-muted);
            font-weight: 600;
        }
    </style>
</head>
<body>
        <div class="header">
        <div class="container">
            <h1>EXCEL ACADEMY</h1>
            <div class="subhead">STUDENT LEADERSHIP BOARD</div>
            <div class="tagline">Database and Ranking System</div>
        </div>
    </div>

    <div class="container">
        <!-- ALERTS -->
        <div id="alertContainer"></div>
        
        <!-- CENTER VALIDATION MODAL -->
        <div id="validationModal" class="validation-modal hidden">
            <div class="validation-modal-content">
                <div class="validation-modal-header">
                    <h3 id="validationTitle">Validation Required</h3>
                </div>
                <div class="validation-modal-body">
                    <p id="validationMessage">Please review the message above.</p>
                </div>
                <div class="validation-modal-footer">
                    <button onclick="closeValidationModal()" class="btn-primary">OK</button>
                </div>
            </div>
        </div>

        <!-- CONFIRM MODAL (Resources) -->
        <div id="confirmModal" class="validation-modal hidden">
            <div class="validation-modal-content confirm-modal-content">
                <div class="validation-modal-header">
                    <h3 id="confirmTitle">Confirm</h3>
                </div>
                <div class="validation-modal-body confirm-modal-body">
                    <div id="confirmBody"></div>
                </div>
                <div class="validation-modal-footer">
                    <button onclick="closeConfirmModal(false)" class="secondary">Cancel</button>
                    <button onclick="closeConfirmModal(true)" class="btn-primary">Confirm</button>
                </div>
            </div>
        </div>
        
        <button
            id="masterUpdateBtn"
            class="master-update-btn"
            data-allow="true"
            onclick="runMasterUpdate()"
            title="Push/Pull all configured servers for 3 seconds"
        >
            <i class="fas fa-bolt"></i> Master Update (3s)
        </button>

        <!-- PERSISTENT SYNC BAR — visible to all roles -->
        <div id="globalSyncBar" style="
            display:flex;align-items:center;gap:10px;flex-wrap:wrap;
            padding:6px 4px 6px 2px;margin-bottom:4px;
        ">
            <span id="syncStatus" class="sync-pill offline">Offline</span>
            <span id="roleBadge" class="sync-pill">Role: -</span>
            <span id="lastSyncTime" class="sync-meta" style="flex:1;min-width:120px">Last sync: -</span>
            <button id="globalPublishBtn" class="secondary" data-allow="true"
                onclick="forcePublishNow()"
                style="padding:5px 12px;font-size:12px;display:none"
                title="Admin only: publish this device snapshot to server now">
                <i class="fas fa-upload"></i> Force Publish
            </button>
            <button id="globalRefreshBtn" class="secondary" data-allow="true"
                onclick="pullFromServer(true, true)"
                style="padding:5px 12px;font-size:12px;display:none"
                title="Pull latest data from server">
                <i class="fas fa-sync-alt"></i> Refresh
            </button>
        </div>

        <!-- TABS -->
        <div class="tabs">
            <button class="tab-button active" onclick="switchTab('scoreboard')" style="--tab-icon: #38bdf8;">
                <i class="fas fa-table"></i> Scoreboard
            </button>
            <button class="tab-button" onclick="switchTab('add-score')" style="--tab-icon: #22c55e;">
                <i class="fas fa-plus-circle"></i> Record Score
            </button>
            <button class="tab-button" onclick="switchTab('students')" style="--tab-icon: #6366f1;">
                <i class="fas fa-users"></i> Students
            </button>
            <button class="tab-button" onclick="switchTab('fees')" style="--tab-icon: #f59e0b;">
                <i class="fas fa-receipt"></i> Fees
            </button>
            <button class="tab-button" onclick="switchTab('resources')" style="--tab-icon: #14b8a6;">
                <i class="fas fa-boxes-stacked"></i> Resources
            </button>
            <button class="tab-button" onclick="switchTab('syllabus')" style="--tab-icon: #06b6d4;">
                <i class="fas fa-book-open"></i> Syllabus
            </button>
            <button class="tab-button" onclick="switchTab('ranking')" style="--tab-icon: #eab308;">
                <i class="fas fa-trophy"></i> Rankings
            </button>
            <button class="tab-button" onclick="switchTab('group-scoreboard')" style="--tab-icon: #a855f7;">
                <i class="fas fa-layer-group"></i> Group Scoreboard
            </button>
            <button class="tab-button" onclick="switchTab('cr')" style="--tab-icon: #ec4899;">
                <i class="fas fa-user-check"></i> Class Representative (CR)
            </button>
            <button class="tab-button" onclick="switchTab('teachers')" style="--tab-icon: #06b6d4;">
                <i class="fas fa-chalkboard-teacher"></i> Teachers
            </button>
            <button class="tab-button" onclick="switchTab('teacher-voting')" style="--tab-icon: #84cc16;">
                <i class="fas fa-vote-yea"></i> Teacher Voting
            </button>
            <button class="tab-button" onclick="switchTab('party')" style="--tab-icon: #f97316;">
                <i class="fas fa-flag"></i> Party System
            </button>
            <button class="tab-button" onclick="switchTab('office')" style="--tab-icon: #0ea5e9;">
                <i class="fas fa-id-badge"></i> Post Holders
            </button>
            <button class="tab-button" onclick="switchTab('voting')" style="--tab-icon: #8b5cf6;">
                <i class="fas fa-vote-yea"></i> Voting
            </button>
            <button class="tab-button" id="appealsTabButton" onclick="switchTab('appeals')" style="--tab-icon: #ef4444;">
                <i class="fas fa-bullhorn"></i> Appeals
            </button>
            <button class="tab-button" id="notificationsTabButton" onclick="switchTab('notifications')" style="--tab-icon: #f43f5e;">
                <i class="fas fa-bell"></i> Notifications
            </button>
            <button class="tab-button" id="activityLogTabButton" onclick="switchTab('activity-log')" style="--tab-icon: #f59e0b;">
                <i class="fas fa-clipboard-list"></i> Activity Log
            </button>
            <button class="tab-button" onclick="switchTab('attendance')" style="--tab-icon: #10b981;">
                <i class="fas fa-user-check"></i> Attendance
            </button>
            <button class="tab-button" id="profileTabButton" onclick="switchTab('profile')" style="--tab-icon: #0f766e;">
                <i class="fas fa-id-card"></i> Student Profiles
            </button>
            <button class="tab-button" id="homeworkTabButton" onclick="switchTab('homework')" style="--tab-icon: #a78bfa;">
                <i class="fas fa-book-reader"></i> Homework
            </button>
            <button class="tab-button" onclick="switchTab('good-conduct')" style="--tab-icon: #10b981;">
                <i class="fas fa-award"></i> Good Conduct Badge
            </button>
            <button class="tab-button" onclick="switchTab('tools')" style="--tab-icon: #64748b;">
                <i class="fas fa-tools"></i> Tools
            </button>
            <button class="tab-button" id="myDashboardTabButton" onclick="switchTab('my-dashboard')" style="--tab-icon: #6ee7b7;display:none">
                <i class="fas fa-user-circle"></i> My Dashboard
            </button>
            <div class="tab-spacer"></div>
            <button class="tab-button right-tab" onclick="switchTab('leadership')" style="--tab-icon: #fbbf24;">
                <i class="fas fa-crown"></i> Leadership Posts
            </button>
        </div>

        <!-- TAB: SCOREBOARD -->
        <div id="scoreboard-tab" class="tab-content">
            <div class="controls">
                <div class="control-group">
                    <label>📅 Month View</label>
                    <div class="month-nav" id="monthSelectorWrap">
                        <span class="month-nav-label">📅 Period</span>
                        <select id="monthSelector" class="form-control" onchange="loadMonthScoreboard(this.value)" style="min-width:140px;padding:6px 10px;border-radius:6px;border:1px solid var(--border-color,#ccc);background:var(--input-bg,#fff);color:var(--text-primary,#222);font-size:14px;cursor:pointer;"></select>
                    </div>
                </div>
                <div class="control-group">
                    <label>Filter by Class</label>
                    <select id="classFilter" onchange="filterScoreboard()">
                        <option value="">All Classes</option>
                        <option value="2">Class 2</option>
                        <option value="3">Class 3</option>
                        <option value="4">Class 4</option>
                        <option value="5">Class 5</option>
                        <option value="6">Class 6</option>
                        <option value="7">Class 7</option>
                        <option value="8">Class 8</option>
                        <option value="9">Class 9</option>
                        <option value="10">Class 10</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Filter by Group</label>
                    <select id="groupFilter" onchange="filterScoreboard()">
                        <option value="all">All Groups</option>
                        <option value="A">Group A</option>
                        <option value="B">Group B</option>
                        <option value="C">Group C</option>
                        <option value="D">Group D</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Search Student</label>
                    <input type="text" id="searchStudent" placeholder="Name or Roll No..." oninput="debouncedFilterScoreboard()">
                </div>
                <div class="control-group">
                    <label>Status</label>
                    <select id="statusFilter" onchange="filterScoreboard()">
                        <option value="all" selected>All</option>
                        <option value="active">Active</option>
                        <option value="inactive">Inactive</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Columns</label>
                    <label style="display: inline-flex; align-items: center; gap: 6px; font-size: 14px;">
                        <input type="checkbox" id="toggleAWF" onchange="toggleColumn('awf', this.checked)">
                        AWF
                    </label>
                </div>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <h4>Total Students</h4>
                    <div class="value" id="totalStudents">0</div>
                </div>
                <div class="stat-card">
                    <h4>Current Month</h4>
                    <div class="value" id="currentMonth">-</div>
                </div>
                <div class="stat-card">
                    <h4>Avg Score</h4>
                    <div class="value" id="avgScore">0</div>
                </div>
                <div class="stat-card">
                    <h4>Top Scorer</h4>
                    <div class="value" id="topScorer" style="font-size: 16px; word-break: break-word;">-</div>
                </div>
            </div>

            <div class="scoreboard-wrapper">
                <div class="scoreboard-scroll-top" id="scoreboardTopScroll">
                    <div class="scoreboard-scroll-top-spacer" id="scoreboardTopScrollSpacer"></div>
                </div>
                <div class="scoreboard-scroll" id="scoreboardBottomScroll">
                    <table class="scoreboard" id="scoreboardTable">
                        <thead>
                            <tr id="scoreboardHeaderRow">
                                <th class="sticky-left rank-cell" style="width: 70px;">Rank</th>
                                <th class="sticky-left sticky-left-1" style="width: 92px;">Roll No.</th>
                                <th class="sticky-left sticky-left-2" style="width: 320px;">Student Name</th>
                                <th class="sticky-left sticky-left-3" style="width: 60px;">Class</th>
                                <th class="sticky-left sticky-left-4" style="width: 70px;" data-col="fees">Fees</th>
                                <th class="sticky-right sticky-right-1 total-cell" style="width: 150px; background: #fbbf24 !important;">Total<br>Score</th>
                                <th class="sticky-right vote-cell" style="width: 96px;">Vote<br>Power</th>
                            </tr>
                        </thead>
                        <tbody id="scoreboardBody">
                            <tr>
                                <td colspan="7" class="text-center loading">
                                    <div class="spinner"></div> Loading data...
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- TAB: MY DASHBOARD (students only) -->
        <div id="my-dashboard-tab" class="tab-content hidden">

            <!-- Personal Stats -->
            <div class="form-card" id="myStatsCard">
                <h3><i class="fas fa-chart-line"></i> My Performance</h3>
                <div id="myStatsContent"><p style="color:var(--text-muted)">Loading…</p></div>
            </div>

            <!-- Position Badges -->
            <div class="form-card" id="myPositionCard" style="display:none">
                <h3><i class="fas fa-id-badge"></i> My Role &amp; Position</h3>
                <div id="myPositionContent"></div>
            </div>

            <!-- VETO Request -->
            <div class="form-card" id="myVetoCard" style="display:none">
                <h3><i class="fas fa-gavel"></i> Use My VETO</h3>
                <div id="myVetoContent"></div>
            </div>

            <!-- CR / Class View -->
            <div class="form-card" id="myCRCard" style="display:none">
                <h3><i class="fas fa-user-check"></i> My Class — CR View</h3>
                <div id="myCRContent"></div>
            </div>

            <!-- Group View -->
            <div class="form-card" id="myGroupCard" style="display:none">
                <h3><i class="fas fa-layer-group"></i> My Group Standings</h3>
                <div id="myGroupContent"></div>
            </div>

            <!-- Party View -->
            <div class="form-card" id="myPartyCard" style="display:none">
                <h3><i class="fas fa-flag"></i> My Party</h3>
                <div id="myPartyContent"></div>
            </div>

            <!-- My Appeals -->
            <div class="form-card" id="myAppealsCard">
                <h3><i class="fas fa-bullhorn"></i> My Appeals</h3>
                <div id="myAppealsContent"><p style="color:var(--text-muted)">Loading…</p></div>
            </div>

        </div>

        <!-- TAB: ADD SCORE -->
        <div id="add-score-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-plus-circle"></i> Record Daily Score</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Group Filter</label>
                        <select id="scoreGroupFilter" onchange="updateScoreStudentOptions(true)">
                            <option value="all">All Groups</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Class Filter</label>
                        <select id="scoreClassFilter" onchange="updateScoreStudentOptions(true)">
                            <option value="">All Classes</option>
                            <option value="2">Class 2</option>
                            <option value="3">Class 3</option>
                            <option value="4">Class 4</option>
                            <option value="5">Class 5</option>
                            <option value="6">Class 6</option>
                            <option value="7">Class 7</option>
                            <option value="8">Class 8</option>
                            <option value="9">Class 9</option>
                            <option value="10">Class 10</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Status Filter</label>
                        <select id="scoreStatusFilter" onchange="updateScoreStudentOptions(true)">
                            <option value="active" selected>Active Only</option>
                            <option value="all">All Students</option>
                            <option value="inactive">Inactive Only</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Student *</label>
                        <select id="scoreStudent" required>
                            <option value="">Select Student...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Date *</label>
                        <input type="date" id="scoreDate" required>
                    </div>
                    <div class="form-group">
                        <label>Points *</label>
                        <input type="number" id="scorePoints" min="-100" max="100" required placeholder="0">
                    </div>
                    <div class="form-group">
                        <label>Stars (+/-)</label>
                        <input type="text" id="scoreStars" placeholder="0 or ** or -**">
                    </div>
                    <div class="form-group">
                        <label>VETOs (+/-)</label>
                        <input type="text" id="scoreVetos" placeholder="0 or V or -VV">
                    </div>
                    <div class="form-group">
                        <label>Month *</label>
                        <select id="scoreMonth" required>
                            <option value="">Select Month...</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <label>Notes</label>
                    <textarea id="scoreNotes" placeholder="Optional notes..."></textarea>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="clearScoreForm()">Clear</button>
                    <button class="danger" onclick="deleteScore()">Delete Score</button>
                    <button onclick="saveScore()">Save Score</button>
                </div>
                <div id="starTransferModule" style="margin-top: 14px; padding-top: 12px; border-top: 1px dashed var(--border);">
                    <h4 style="margin-bottom: 8px;"><i class="fas fa-exchange-alt"></i> Star Transfer</h4>
                    <p class="section-subtitle" style="margin-bottom: 10px;">
                        Transfer stars between students using the selected Date and Month above.
                    </p>
                    <div class="form-grid">
                        <div class="form-group">
                            <label>From Student</label>
                            <select id="starTransferFrom">
                                <option value="">Select source...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>To Student</label>
                            <select id="starTransferTo">
                                <option value="">Select destination...</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Stars to Transfer</label>
                            <input type="number" id="starTransferCount" min="1" step="1" placeholder="e.g. 1">
                        </div>
                    </div>
                    <div class="form-buttons">
                        <button onclick="transferStarsBetweenStudents()"><i class="fas fa-random"></i> Transfer Stars</button>
                    </div>
                </div>
                <p id="scoreHint" style="color: var(--text-muted); font-size: 12px; margin-top: 10px;">
                    Tip: Saving a score for the same student and date will update the existing entry.
                </p>
            </div>

            <div class="form-card">
                <h3><i class="fas fa-users"></i> Student List (Record Score)</h3>
                <div class="form-grid" style="margin-bottom: 10px;">
                    <div class="form-group">
                        <label>Group Filter</label>
                        <select id="scoreGroupFilterList" onchange="syncRecordScoreGroupFilter()">
                            <option value="all">All Groups</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Class Filter</label>
                        <select id="scoreClassFilterList" onchange="syncRecordScoreGroupFilter(true)">
                            <option value="">All Classes</option>
                            <option value="2">Class 2</option>
                            <option value="3">Class 3</option>
                            <option value="4">Class 4</option>
                            <option value="5">Class 5</option>
                            <option value="6">Class 6</option>
                            <option value="7">Class 7</option>
                            <option value="8">Class 8</option>
                            <option value="9">Class 9</option>
                            <option value="10">Class 10</option>
                        </select>
                    </div>
                </div>
                <p class="section-subtitle">All students shown by default. Use filters above to optimise the list.</p>
                <div class="record-date-strip-wrap">
                    <div class="record-date-strip-head">
                        <span class="month-label" id="recordDateMonthLabel">Month</span>
                        <span class="active-date-label" id="recordDateActiveLabel">Selected: -</span>
                    </div>
                    <div class="record-date-strip" id="recordScoreDateStrip"></div>
                </div>
                <div class="record-column-controls">
                    <span class="section-subtitle" style="margin: 0 8px 0 0;">Optional columns:</span>
                    <label><input type="checkbox" id="recordShowGroup" onchange="applyRecordColumnsVisibility()"> Group</label>
                    <label><input type="checkbox" id="recordShowVotePower" onchange="applyRecordColumnsVisibility()"> Vote Power</label>
                    <label><input type="checkbox" id="recordShowStars" onchange="applyRecordColumnsVisibility()"> Stars</label>
                    <label><input type="checkbox" id="recordShowVetos" onchange="applyRecordColumnsVisibility()"> VETOs</label>
                    <label><input type="checkbox" id="recordShowStatus" onchange="applyRecordColumnsVisibility()"> Status</label>
                </div>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="recordStudentsTable">
                            <thead>
                                <tr>
                                    <th style="width: 105px;">Roll No.</th>
                                    <th style="width: 210px;">Student Name</th>
                                    <th style="width: 90px;">Class</th>
                                    <th style="width: 90px;" data-col="record-group">Group</th>
                                    <th style="width: 120px;" data-col="record-vote-power">Vote Power</th>
                                    <th style="width: 80px;" data-col="record-stars">Stars</th>
                                    <th style="width: 80px;" data-col="record-vetos">VETOs</th>
                                    <th style="width: 120px;" data-col="record-status">Status</th>
                                    <th style="width: 155px;">Points (Enter to Save)</th>
                                    <th style="width: 105px;">Stars +/-</th>
                                    <th style="width: 165px;">Star Reason</th>
                                    <th style="width: 105px;">VETOs +/-</th>
                                    <th style="width: 155px;">VETO Reason</th>
                                    <th style="width: 90px;">Save</th>
                                </tr>
                            </thead>
                            <tbody id="recordStudentsBody">
                                <tr>
                                    <td colspan="14" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: STUDENTS -->
        <div id="students-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-plus"></i> Add New Student</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Roll Number *</label>
                        <input type="text" id="newRoll" placeholder="EA24A01" required>
                    </div>
                    <div class="form-group">
                        <label>Full Name *</label>
                        <input type="text" id="newName" placeholder="Student Name" required>
                    </div>
                    <div class="form-group">
                        <label>Class *</label>
                        <select id="newClass" required>
                            <option value="">Select Class...</option>
                            <option value="2">2</option>
                            <option value="3">3</option>
                            <option value="4">4</option>
                            <option value="5">5</option>
                            <option value="6">6</option>
                            <option value="7">7</option>
                            <option value="8">8</option>
                            <option value="9">9</option>
                            <option value="10">10</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Fees</label>
                        <input type="number" id="newFees" placeholder="500" min="0">
                    </div>
                    <div class="form-group">
                        <label>Vote Power (Auto)</label>
                        <input type="number" id="newVotePower" value="1" placeholder="Auto" readonly>
                    </div>
                    <div class="form-group">
                        <label>Stars</label>
                        <input type="number" id="newStars" placeholder="0" min="0">
                    </div>
                    <div class="form-group">
                        <label>VETOs</label>
                        <input type="number" id="newVetos" placeholder="0" min="0">
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="clearStudentForm()">Clear</button>
                    <button onclick="addNewStudent()">Add Student</button>
                    <button class="secondary" onclick="triggerStudentsImport()">Import Students</button>
                    <button class="secondary" onclick="triggerActiveRosterImport()">Import Active Roster</button>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Search</label>
                    <input type="text" id="studentSearchFilter" placeholder="Name / Roll..." oninput="debouncedLoadStudents()">
                </div>
                <div class="control-group">
                    <label>Class Filter</label>
                    <select id="studentClassFilter" onchange="loadStudents()">
                        <option value="">All Classes</option>
                        <option value="2">Class 2</option>
                        <option value="3">Class 3</option>
                        <option value="4">Class 4</option>
                        <option value="5">Class 5</option>
                        <option value="6">Class 6</option>
                        <option value="7">Class 7</option>
                        <option value="8">Class 8</option>
                        <option value="9">Class 9</option>
                        <option value="10">Class 10</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Group Filter</label>
                    <select id="studentGroupFilter" onchange="loadStudents()">
                        <option value="all">All Groups</option>
                        <option value="A">Group A</option>
                        <option value="B">Group B</option>
                        <option value="C">Group C</option>
                        <option value="D">Group D</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Status Filter</label>
                    <select id="studentStatusFilter" onchange="loadStudents()">
                        <option value="active" selected>Active Only</option>
                        <option value="all">All</option>
                        <option value="inactive">Inactive Only</option>
                    </select>
                </div>
            </div>

            <div class="scoreboard-wrapper">
                <div class="scoreboard-scroll">
                    <table class="scoreboard" id="studentsList">
                        <thead>
                            <tr>
                                <th>Roll No.</th>
                                <th>Student Name</th>
                                <th>Class</th>
                                <th data-col="fees">Fees</th>
                                <th>Status</th>
                                <th>Stars</th>
                                <th>VETOs</th>
                                <th>Vote Power</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="studentsBody">
                            <tr>
                                <td colspan="9" class="text-center loading">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="form-card" style="margin-top: 14px;">
                <h3><i class="fas fa-triangle-exclamation"></i> Duplicate Roll Audit</h3>
                <p class="section-subtitle">Use this list to deactivate unused profiles where the same roll number appears under multiple names.</p>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="duplicateRollTable">
                            <thead>
                                <tr>
                                    <th style="width: 110px;">Roll No.</th>
                                    <th>Student Name</th>
                                    <th style="width: 90px;">Class</th>
                                    <th style="width: 110px;">Status</th>
                                    <th style="width: 160px;">Action</th>
                                </tr>
                            </thead>
                            <tbody id="duplicateRollBody">
                                <tr>
                                    <td colspan="5" class="text-center loading">Scanning...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: FEES -->
        <div id="fees-tab" class="tab-content hidden">
            <div class="controls">
                <div class="control-group">
                    <label>Search Student</label>
                    <input type="text" id="feesSearch" placeholder="Name or Roll..." oninput="debouncedLoadFeesTab()">
                </div>
                <div class="control-group">
                    <label>Filter by Group</label>
                    <select id="feesGroupFilter" onchange="loadFeesTab()">
                        <option value="all">All Groups</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Status</label>
                    <select id="feesStatusFilter" onchange="loadFeesTab()">
                        <option value="active" selected>Active Only</option>
                        <option value="all">All</option>
                        <option value="inactive">Inactive Only</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Payment Status</label>
                    <select id="feesDueFilter" onchange="loadFeesTab()">
                        <option value="all" selected>All</option>
                        <option value="due">Due</option>
                        <option value="past_due">Past Due</option>
                        <option value="paid">Paid</option>
                    </select>
                </div>
            </div>
            <div class="form-buttons" style="margin-bottom: 12px;">
                <button class="secondary" onclick="exportFeesData('xlsx')"><i class="fas fa-file-excel"></i> Export Excel</button>
                <button class="secondary" onclick="exportFeesData('txt')"><i class="fas fa-file-alt"></i> Export TXT</button>
                <button class="secondary" onclick="exportFeesData('docx')"><i class="fas fa-file-word"></i> Export DOCX</button>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <h4>Active Students</h4>
                    <div class="value" id="feesTotalStudents">0</div>
                </div>
                <div class="stat-card">
                    <h4>Overdue</h4>
                    <div class="value" id="feesOverdueCount">0</div>
                </div>
                <div class="stat-card">
                    <h4>Total Collection</h4>
                    <div class="value" id="feesTotalCollection">0</div>
                </div>
            </div>

            <div class="scoreboard-wrapper">
                <div class="scoreboard-scroll">
                    <table class="scoreboard" id="feesTable">
                        <thead>
                            <tr>
                                <th style="width: 110px;">Roll No.</th>
                                <th style="min-width: 170px;">Student Name</th>
                                <th style="width: 70px;">Class</th>
                                <th style="width: 70px;">Group</th>
                                <th style="width: 140px;">Fees</th>
                                <th style="width: 150px;">Start Date</th>
                                <th class="fees-period-col" style="width: 120px;">Period (Months)</th>
                                <th style="width: 140px;">Due Date</th>
                                <th style="width: 140px;">Last Paid</th>
                                <th style="width: 120px;">Status</th>
                                <th style="width: 190px;">Action</th>
                                <th style="min-width: 160px;">Remarks</th>
                            </tr>
                        </thead>
                        <tbody id="feesBody">
                            <tr>
                                <td colspan="11" class="text-center loading">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- TAB: RESOURCES -->
        <div id="resources-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-boxes-stacked"></i> Excel Resource Management</h3>
                <p class="section-subtitle">
                    Manage the resource cabinet, and track student redemption (points) or purchases (cash) with teacher recommendation and admin approval.
                </p>
            </div>

            <div class="form-card" id="resourceCabinetCard">
                <h3><i class="fas fa-warehouse"></i> Resource Cabinet</h3>
                <div class="controls">
                    <div class="control-group">
                        <label>Item Name</label>
                        <input id="resourceItemName" type="text" placeholder="e.g., Notebook">
                    </div>
                    <div class="control-group">
                        <label>A/U (Unit)</label>
                        <input id="resourceItemUnit" type="text" placeholder="e.g., pcs">
                    </div>
                    <div class="control-group">
                        <label>Price/Unit</label>
                        <input id="resourceItemPrice" type="number" min="0" step="0.01" placeholder="e.g., 50 or 50.5">
                    </div>
                    <div class="control-group">
                        <label>Total Held</label>
                        <input id="resourceItemHeld" type="number" min="0" step="1" placeholder="e.g., 100">
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="saveResourceCabinetItem()" data-allow="true"><i class="fas fa-plus"></i> Add/Update Item</button>
                    <button class="secondary" onclick="renderResourceCabinet()" data-allow="true"><i class="fas fa-rotate"></i> Refresh</button>
                </div>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="resourceCabinetTable">
                            <thead>
                                <tr>
                                    <th style="width: 70px;">ID</th>
                                    <th>Item</th>
                                    <th style="width: 120px;">Unit</th>
                                    <th style="width: 140px;">Price/Unit</th>
                                    <th style="width: 140px;">Total Held</th>
                                    <th style="width: 220px;">Action</th>
                                </tr>
                            </thead>
                            <tbody id="resourceCabinetBody">
                                <tr><td colspan="6" class="text-center loading">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="form-card" id="resourceRequestCard">
                <h3><i class="fas fa-cart-shopping"></i> Student Requests</h3>
                <p class="section-subtitle" id="resourceRequestActorLabel"></p>
                <div class="controls">
                    <div class="control-group" data-role-only="admin">
                        <label>Student Filter</label>
                        <select id="resourceStudentStatusFilter" onchange="populateResourceContextClassOptions(); populateResourceContextStudents(); updateResourceContext();">
                            <option value="active" selected>Active</option>
                            <option value="inactive">Inactive</option>
                            <option value="all">All</option>
                        </select>
                    </div>
                    <div class="control-group" data-role-only="admin">
                        <label>Class Filter</label>
                        <select id="resourceStudentClassFilter" onchange="populateResourceContextStudents(); updateResourceContext();">
                            <option value="all" selected>All Classes</option>
                        </select>
                    </div>
                    <div class="control-group" data-role-only="admin">
                        <label>Month</label>
                        <input id="resourceContextMonth" type="month" min="2025-08" onchange="updateResourceContext()">
                    </div>
                    <div class="control-group" data-role-only="admin">
                        <label>Request Date</label>
                        <input id="resourceRequestDate" type="date" onchange="updateResourceContext()">
                    </div>
                    <div class="control-group" data-role-only="admin">
                        <label>Student</label>
                        <select id="resourceContextStudent" onchange="updateResourceContext()"></select>
                    </div>
                    <div class="control-group" data-role-only="admin">
                        <label>Student Name</label>
                        <input id="resourceContextStudentName" type="text" placeholder="-" readonly>
                    </div>
                    <div class="control-group" data-role-only="admin">
                        <label>Urgent (Admin)</label>
                        <select id="resourceRequestUrgent" onchange="updateResourceContext()">
                            <option value="no" selected>No</option>
                            <option value="yes">Yes</option>
                        </select>
                    </div>
                    <div class="control-group" data-role-only="admin">
                        <label>Admin Veto</label>
                        <select id="resourceAdminVeto" onchange="updateResourceRequestPreview()">
                            <option value="off" selected>Off</option>
                            <option value="on">On (Override)</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Mode</label>
                        <select id="resourceRequestMode" onchange="updateResourceRequestPreview()">
                            <option value="redeem_points">Redeem Excess Points</option>
                            <option value="cash_purchase">Cash Purchase</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Item</label>
                        <select id="resourceRequestItem" onchange="updateResourceRequestPreview()"></select>
                    </div>
                    <div class="control-group">
                        <label>Quantity</label>
                        <input id="resourceRequestQty" type="number" min="1" step="1" value="1" onchange="updateResourceRequestPreview()">
                    </div>
                    <div class="control-group">
                        <label>Cash Paid (if cash)</label>
                        <input id="resourceRequestCashPaid" type="number" min="0" step="1" value="0" onchange="updateResourceRequestPreview()">
                    </div>
                </div>
                <div class="stats-grid">
                    <div class="stat-card">
                        <h4>Selected Month</h4>
                        <div class="value" id="resourceMonthLabel">-</div>
                    </div>
                    <div class="stat-card">
                        <h4>Month Total</h4>
                        <div class="value" id="resourceMonthTotalPoints">0</div>
                    </div>
                    <div class="stat-card">
                        <h4>Excess Earned</h4>
                        <div class="value" id="resourceExcessEarned">0</div>
                    </div>
                    <div class="stat-card">
                        <h4>Excess Used</h4>
                        <div class="value" id="resourceExcessUsed">0</div>
                    </div>
                    <div class="stat-card">
                        <h4>Excess Remaining</h4>
                        <div class="value" id="resourceAvailablePoints">0</div>
                    </div>
                    <div class="stat-card">
                        <h4>Estimated Cost</h4>
                        <div class="value" id="resourceEstimatedCost">0</div>
                    </div>
                </div>
                <div class="form-buttons">
                    <button onclick="submitResourceRequest()" data-allow="true"><i class="fas fa-paper-plane"></i> Submit Request</button>
                    <button class="secondary" onclick="clearResourceRequestForm()" data-allow="true"><i class="fas fa-xmark"></i> Cancel</button>
                    <button class="secondary" onclick="loadResourcesTab()" data-allow="true"><i class="fas fa-rotate"></i> Refresh</button>
                    <button class="secondary" onclick="adminQuickCashPurchase('full_paid')" data-role-only="admin" data-allow="true"><i class="fas fa-money-bill-wave"></i> Cash Full Paid</button>
                    <button class="secondary" onclick="adminQuickCashPurchase('half_paid')" data-role-only="admin" data-allow="true"><i class="fas fa-percent"></i> Cash Half Paid</button>
                </div>
                <p class="section-subtitle" id="resourceRequestHint"></p>
            </div>

            <div class="form-card" id="resourceEligibilityCard">
                <h3><i class="fas fa-clipboard-check"></i> Eligibility (Selected Student)</h3>
                <p class="section-subtitle" id="resourceEligibilitySummary"></p>
                <div class="controls" data-role-only="admin">
                    <div class="control-group">
                        <label>Manual Redeem (Points)</label>
                        <input id="resourceManualRedeemPoints" type="number" min="0" step="1" value="0">
                    </div>
                    <div class="control-group">
                        <label>Remark</label>
                        <input id="resourceManualRedeemRemark" type="text" placeholder="e.g., Offline redeemed">
                    </div>
                </div>
                <div class="form-buttons" data-role-only="admin">
                    <button class="secondary" onclick="adminManualRedeem(false)" data-allow="true"><i class="fas fa-pen"></i> Save Manual Redeem</button>
                    <button class="secondary" onclick="adminManualRedeem(true)" data-allow="true"><i class="fas fa-check"></i> Redeem Remaining</button>
                </div>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="resourceEligibilityTable">
                            <thead>
                                <tr>
                                    <th>Item</th>
                                    <th style="width: 110px;">Unit</th>
                                    <th style="width: 120px;">Held</th>
                                    <th style="width: 140px;">Price</th>
                                    <th style="width: 160px;">Points (GST+50%)</th>
                                    <th style="width: 140px;">Redeem?</th>
                                    <th style="width: 140px;">Cash Full</th>
                                    <th style="width: 140px;">Cash Half</th>
                                </tr>
                            </thead>
                            <tbody id="resourceEligibilityBody">
                                <tr><td colspan="8" class="text-center loading">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
 
            <div class="form-card">
                <h3><i class="fas fa-list-check"></i> Requests Queue</h3>
                <div class="controls">
                    <div class="control-group">
                        <label>Filter</label>
                        <select id="resourceQueueFilter" onchange="this.dataset.userSet='1'; renderResourceRequests()">
                            <option value="mine">My Requests</option>
                            <option value="pending_teacher">Pending Teacher</option>
                            <option value="pending_admin">Pending Admin</option>
                            <option value="all">All</option>
                        </select>
                    </div>
                </div>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="resourceRequestsTable">
                            <thead>
                                <tr>
                                    <th style="width: 90px;">Req ID</th>
                                    <th style="width: 120px;">Month</th>
                                    <th style="width: 130px;">Requested</th>
                                    <th style="width: 130px;">Approved</th>
                                    <th style="width: 120px;">Mode</th>
                                    <th>Student</th>
                                    <th style="width: 110px;">Roll</th>
                                    <th>Item</th>
                                    <th style="width: 90px;">Qty</th>
                                    <th style="width: 120px;">Cost/Points</th>
                                    <th style="width: 140px;">Status</th>
                                    <th style="width: 280px;">Action</th>
                                </tr>
                            </thead>
                            <tbody id="resourceRequestsBody">
                                <tr><td colspan="12" class="text-center loading">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="form-card" id="resourceTransactionsCard">
                <h3><i class="fas fa-file-invoice"></i> Transactions (Approved/Fulfilled)</h3>
                <div class="controls">
                    <div class="control-group">
                        <label>Filter</label>
                        <select id="resourceTransactionsFilter" onchange="renderResourceTransactions()">
                            <option value="all" selected>All</option>
                            <option value="completed">Completed</option>
                            <option value="not_completed">Not Completed</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Student</label>
                        <select id="resourceTransactionsStudentFilter" onchange="renderResourceTransactions()">
                            <option value="all" selected>All Students</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Date</label>
                        <input id="resourceTransactionsDateFilter" type="date" onchange="renderResourceTransactions()">
                    </div>
                    <div class="control-group">
                        <label>Month</label>
                        <input id="resourceTransactionsMonthFilter" type="month" min="2025-08" onchange="renderResourceTransactions()">
                    </div>
                </div>
                <div id="resourceTxnStudentPendingSummary" class="section-subtitle" style="display:none;margin:6px 0 10px;padding:8px 10px;border:1px solid rgba(148,163,184,0.25);border-radius:8px;background:rgba(15,23,42,0.6);"></div>
                <div class="form-card" id="resourceSettlementCard" style="display:none;margin:8px 0 12px;padding:12px 14px;">
                    <div style="font-weight:700;margin-bottom:6px;">Pending Settlement Summary</div>
                    <div class="section-subtitle" style="margin-bottom:8px;">Consolidated per-student cash due/return for unsettled transactions.</div>
                    <div class="scoreboard-wrapper">
                        <div class="scoreboard-scroll">
                            <table class="scoreboard" id="resourceSettlementTable">
                                <thead>
                                    <tr>
                                        <th>Student</th>
                                        <th style="width: 110px;">Roll</th>
                                        <th style="width: 70px;">Txns</th>
                                        <th style="width: 110px;">Due</th>
                                        <th style="width: 110px;">Return</th>
                                        <th style="width: 110px;">Net Due</th>
                                    </tr>
                                </thead>
                                <tbody id="resourceSettlementBody">
                                    <tr><td colspan="6" class="text-center loading">Loading...</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </div>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="resourceTransactionsTable">
                            <thead>
                                <tr>
                                    <th style="width: 90px;">Txn ID</th>
                                    <th style="width: 120px;">Month</th>
                                    <th style="width: 120px;">Mode</th>
                                    <th>Student</th>
                                    <th style="width: 110px;">Roll</th>
                                    <th>Item</th>
                                    <th style="width: 90px;">Qty</th>
                                    <th style="width: 120px;">Points</th>
                                    <th style="width: 120px;">Cash</th>
                                    <th style="width: 140px;">Pending/Return</th>
                                    <th style="width: 140px;">Txn Date</th>
                                    <th style="width: 170px;">Action</th>
                                </tr>
                            </thead>
                            <tbody id="resourceTransactionsBody">
                                <tr><td colspan="12" class="text-center loading">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: SYLLABUS -->
        <div id="syllabus-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-book-open"></i> Board-wise Syllabus & Coverage Tracker</h3>
                <p class="section-subtitle">
                    Boards: CBSE, ICSE, WBBSE. Classes: 3-12. Subject chapters/topics are pre-seeded and can be expanded.
                    Teachers/Admin can mark repeated conducted dates; attendance list is fetched from attendance records.
                </p>
            </div>

            <div class="form-card">
                <div class="controls">
                    <div class="control-group">
                        <label>Board</label>
                        <select id="syllabusBoardFilter" onchange="populateSyllabusClassOptions(); populateSyllabusSubjectOptions(); renderSyllabusChapterTable();">
                            <option value="CBSE">CBSE</option>
                            <option value="ICSE">ICSE</option>
                            <option value="WBBSE">WBBSE</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label>Class</label>
                        <select id="syllabusClassFilter" onchange="populateSyllabusSubjectOptions(); renderSyllabusChapterTable();"></select>
                    </div>
                    <div class="control-group">
                        <label>Subject</label>
                        <select id="syllabusSubjectFilter" onchange="renderSyllabusChapterTable();"></select>
                    </div>
                    <div class="control-group">
                        <label>Search Chapter/Topic</label>
                        <input id="syllabusChapterSearch" type="text" placeholder="Type to filter..." oninput="renderSyllabusChapterTable();">
                    </div>
                    <div class="control-group">
                        <label>Default Conducted Date</label>
                        <input id="syllabusDefaultDate" type="date">
                    </div>
                </div>

                <div class="form-buttons">
                    <button class="secondary" onclick="loadSyllabusTab()" data-allow="true"><i class="fas fa-rotate"></i> Refresh</button>
                    <button class="secondary" id="syllabusExpandAllBtn" onclick="toggleSyllabusAttendanceView(true)" data-allow="true"><i class="fas fa-angle-down"></i> Expand Attendance</button>
                    <button class="secondary" id="syllabusCollapseAllBtn" onclick="toggleSyllabusAttendanceView(false)" data-allow="true"><i class="fas fa-angle-up"></i> Collapse Attendance</button>
                </div>
            </div>

            <div class="form-card" id="syllabusAdminToolsCard">
                <h3><i class="fas fa-screwdriver-wrench"></i> Syllabus Admin Tools</h3>
                <div class="controls">
                    <div class="control-group">
                        <label>New Subject</label>
                        <input id="syllabusNewSubject" type="text" placeholder="e.g., Geography">
                    </div>
                    <div class="control-group">
                        <label>New Chapter/Topic</label>
                        <input id="syllabusNewChapter" type="text" placeholder="e.g., Climate and Weather">
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="addSyllabusSubject()" data-allow="true"><i class="fas fa-plus"></i> Add Subject</button>
                    <button class="secondary" onclick="addSyllabusChapter()" data-allow="true"><i class="fas fa-plus"></i> Add Chapter</button>
                </div>
            </div>

            <div class="form-card">
                <h3><i class="fas fa-list-check"></i> Chapter/Topic Coverage</h3>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="syllabusChapterTable">
                            <thead>
                                <tr>
                                    <th style="width: 70px;">#</th>
                                    <th>Chapter / Topic</th>
                                    <th style="width: 220px;">Conducted Dates</th>
                                    <th style="width: 150px;">Last Conducted</th>
                                    <th style="width: 320px;">Attendance (Latest Conducted)</th>
                                    <th style="width: 190px;">Mark Conducted</th>
                                </tr>
                            </thead>
                            <tbody id="syllabusChapterBody">
                                <tr><td colspan="6" class="text-center loading">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: RANKINGS -->
        <div id="ranking-tab" class="tab-content hidden">
            <div class="controls">
                <div class="control-group">
                    <label>Select Month for Ranking</label>
                    <select id="rankingMonth" onchange="loadRankings()">
                        <option value="">Select Month...</option>
                    </select>
                </div>
            </div>

            <div class="scoreboard-wrapper">
                <div class="scoreboard-scroll">
                    <table class="scoreboard" id="rankingsTable">
                        <thead>
                            <tr>
                                <th style="width: 50px;">Rank</th>
                                <th>Student Name</th>
                                <th style="width: 100px;">Class</th>
                                <th style="width: 120px;">Total Score</th>
                                <th style="width: 100px;">Position</th>
                            </tr>
                        </thead>
                        <tbody id="rankingsBody">
                            <tr>
                                <td colspan="5" class="text-center" style="padding: 40px;">
                                    Select a month to view rankings
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- TAB: GROUP SCOREBOARD -->
        <div id="group-scoreboard-tab" class="tab-content hidden">
            <div class="controls">
                <div class="control-group">
                    <label>Select Month</label>
                    <select id="groupMonthFilter" onchange="renderGroupScoreboard()"></select>
                </div>
                <div class="control-group">
                    <label>Filter Group</label>
                    <select id="groupFilterSelect" onchange="renderGroupScoreboard()">
                        <option value="all">All Groups</option>
                        <option value="A">Group A</option>
                        <option value="B">Group B</option>
                        <option value="C">Group C</option>
                        <option value="D">Group D</option>
                        <option value="E">Group E</option>
                        <option value="F">Group F</option>
                        <option value="G">Group G</option>
                        <option value="H">Group H</option>
                        <option value="Z">Group Z</option>
                    </select>
                </div>
            </div>
            <div class="scoreboard-wrapper">
                <div class="scoreboard-scroll">
                    <table class="scoreboard" id="groupScoreboardTable">
                        <thead>
                            <tr>
                                <th style="width: 90px;">Rank</th>
                                <th style="width: 140px;">Group</th>
                                <th style="width: 150px;">Students</th>
                                <th style="width: 140px;">Total Score</th>
                                <th style="width: 140px;">Avg Score</th>
                                <th style="width: 140px;">Vote Power</th>
                                <th style="width: 120px;">Stars</th>
                                <th style="width: 120px;">VETOs</th>
                            </tr>
                        </thead>
                        <tbody id="groupScoreboardBody">
                            <tr>
                                <td colspan="8" class="text-center loading">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
            <div class="scoreboard-wrapper" style="margin-top: 18px;">
                <div class="scoreboard-scroll">
                    <table class="scoreboard" id="groupRosterTable">
                        <thead>
                            <tr>
                                <th style="width: 140px;">Group</th>
                                <th style="width: 120px;">Roll No.</th>
                                <th>Student</th>
                                <th style="width: 90px;">Class</th>
                                <th style="width: 130px;">Total</th>
                                <th style="width: 110px;">Vote</th>
                                <th style="width: 90px;">Stars</th>
                                <th style="width: 90px;">VETOs</th>
                            </tr>
                        </thead>
                        <tbody id="groupRosterBody">
                            <tr>
                                <td colspan="8" class="text-center loading">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- TAB: CLASS REPRESENTATIVES -->
        <div id="cr-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-user-check"></i> Group-wise Class Representatives</h3>
                <p class="section-subtitle">CR selection happens through Voting tab using posts like "CR - Group A". CR gets default +2 VETOs after majority confirmation.</p>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="crGroupTable">
                            <thead>
                                <tr>
                                    <th style="width: 140px;">Post</th>
                                    <th>Current CR</th>
                                    <th style="width: 130px;">Roll</th>
                                    <th style="width: 120px;">Group</th>
                                    <th style="width: 120px;">VETOs</th>
                                    <th style="width: 150px;">Elected On</th>
                                    <th style="width: 160px;">Status</th>
                                    <th style="width: 140px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="crGroupBody">
                                <tr>
                                    <td colspan="8" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Manual CR Assignment form (Admin saves immediately; Teacher submits for Admin approval) -->
            <div class="form-card" id="crEditFormCard">
                <h3><i class="fas fa-edit"></i> Assign / Update Group CR</h3>
                <p class="section-subtitle">Admin: changes take effect immediately. Teacher: changes are submitted for Admin approval before becoming active.</p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Group *</label>
                        <select id="crManualGroup" onchange="autoFillCRPost()">
                            <option value="">Select Group...</option>
                            <option value="A">Group A</option>
                            <option value="B">Group B</option>
                            <option value="C">Group C</option>
                            <option value="D">Group D</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Post Name</label>
                        <input type="text" id="crManualPost" placeholder="Auto-filled from group" readonly style="opacity:0.7;cursor:default;">
                    </div>
                    <div class="form-group">
                        <label>Student *</label>
                        <select id="crManualStudent"></select>
                    </div>
                    <div class="form-group">
                        <label>Elected On</label>
                        <input type="date" id="crManualElectedOn">
                    </div>
                    <div class="form-group">
                        <label>Note <span style="opacity:0.6;">(optional, for admin)</span></label>
                        <input type="text" id="crManualNote" placeholder="Reason for this change...">
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="clearManualGroupCRForm()">Clear</button>
                    <button id="crManualSaveBtn" onclick="saveManualGroupCR()">Save CR</button>
                </div>
            </div>

            <!-- Pending CR Requests (Admin: approve/reject; Teacher: see own request status) -->
            <div class="form-card" id="pendingCRCard" style="display:none;">
                <h3><i class="fas fa-clock"></i> Pending CR Requests</h3>
                <p class="section-subtitle" id="pendingCRSubtitle"></p>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th style="width:100px;">Group</th>
                                    <th>Proposed CR</th>
                                    <th style="width:130px;">Roll</th>
                                    <th style="width:140px;">Elected On</th>
                                    <th style="width:160px;">Requested At</th>
                                    <th style="width:100px;">Status</th>
                                    <th style="width:200px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="pendingCRBody">
                                <tr><td colspan="7" class="text-center" style="padding:20px;">No pending requests</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: PARTY SYSTEM -->
        <div id="party-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-flag"></i> Party System</h3>
                <p class="section-subtitle">Create parties and manage member designations (8 seats per party).</p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Party Code *</label>
                        <select id="partyCode" required>
                            <option value="MAP">MAP (Members of Azzad Party)</option>
                            <option value="BWP">BWP (Brilliant's Wonder Party)</option>
                            <option value="ESP">ESP (Excel's Strength party)</option>
                            <option value="MRP">MRP (Master Republic Party)</option>
                            <option value="SSP">SSP (Senior Secondary Party)</option>
                            <option value="NJP">NJP (National Janata Party)</option>
                        </select>
                    </div>
                </div>
                <div class="form-buttons">
                            <button class="secondary" onclick="clearPartyForm()">Clear</button>
                            <button onclick="saveParty()">Save Party</button>
                        </div>
                    </div>

            <div class="scoreboard-wrapper">
                <div class="scoreboard-scroll">
                    <table class="scoreboard" id="partyTable">
                        <thead>
                            <tr>
                                <th style="width: 160px;">Party</th>
                                <th style="width: 160px;">Seats</th>
                                <th style="width: 140px;">Power</th>
                                <th style="width: 220px;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="partyBody">
                            <tr>
                                <td colspan="4" class="text-center loading">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>

            <div class="form-card">
                <h3><i class="fas fa-user-shield"></i> Party Members</h3>
                <p class="section-subtitle">Assign students to parties. Vote Power is taken from student records and summed as Party Power.</p>
                <div class="party-members-grid">
                    <div class="form-group">
                        <label>Party *</label>
                        <select id="partyMemberParty" onchange="setActivePartyFromSelect()"></select>
                    </div>
                    <div class="form-group">
                        <label>Student *</label>
                        <select id="partyMemberStudent"></select>
                    </div>
                    <div class="form-group">
                        <label>Designation</label>
                        <select id="partyMemberDesignation">
                            <option value="">Select designation...</option>
                            <option value="PP">PP</option>
                            <option value="DPP">DPP</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Selection Date</label>
                        <input type="date" id="partyMemberElectedOn">
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="clearPartyMemberForm()">Clear</button>
                    <button onclick="savePartyMember()">Save Member</button>
                </div>
                <div class="scoreboard-wrapper" style="margin-top: 15px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="partyMembersTable">
                            <thead>
                                <tr>
                                    <th>Student</th>
                                    <th style="width: 120px;">Roll</th>
                                    <th style="width: 120px;">Vote Power</th>
                                    <th style="width: 200px;">Designation</th>
                                    <th style="width: 160px;">Selection</th>
                                    <th style="width: 180px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="partyMembersBody">
                                <tr>
                                    <td colspan="6" class="text-center loading">Select a party to view members</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: LEADERSHIP POSTS -->
        <div id="leadership-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-crown"></i> Leadership Posts</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Post *</label>
                        <select id="leadershipPost" required>
                            <option value="LEADER (L)">LEADER (L)</option>
                            <option value="LEADER OF OPPOSITION (LoP)">LEADER OF OPPOSITION (LoP)</option>
                            <option value="CO-LEADER (CoL)">CO-LEADER (CoL)</option>
                            <option value="CODING & IT CAPTAIN (CITC)">CODING & IT CAPTAIN (CITC)</option>
                            <option value="DISCIPLINE & WELFARE IN-CHARGE (DWI)">DISCIPLINE & WELFARE IN-CHARGE (DWI)</option>
                            <option value="RESOURCE MANAGER (RM)">RESOURCE MANAGER (RM)</option>
                            <option value="SPORTS CAPTAIN (SC)">SPORTS CAPTAIN (SC)</option>
                            <option value="ENGLISH CAPTAIN- SENIOR (ECS)">ENGLISH CAPTAIN- SENIOR (ECS)</option>
                            <option value="CULTURE & CREATIVE ARTS IN-CHARGE (CCAI)">CULTURE & CREATIVE ARTS IN-CHARGE (CCAI)</option>
                            <option value="CLEANLINESS IN-CHARGE (CI)">CLEANLINESS IN-CHARGE (CI)</option>
                            <option value="ENGLISH CAPTAIN- JUNIOR (ECJ)">ENGLISH CAPTAIN- JUNIOR (ECJ)</option>
                            <option value="WELCOME & COMMUNICATION IN-CHARGE (WCI)">WELCOME & COMMUNICATION IN-CHARGE (WCI)</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Roll No.</label>
                        <input type="text" id="leadershipRoll" placeholder="EA24A01" oninput="handleLeadershipRollInput()">
                    </div>
                    <div class="form-group">
                        <label>Post Holder</label>
                        <input type="text" id="leadershipHolder" placeholder="Name">
                    </div>
                    <div class="form-group">
                        <label>Selection Date</label>
                        <input type="date" id="leadershipElectedOn">
                    </div>
                </div>
                <p id="leadershipAutoDetails" style="color: var(--text-muted); margin-top: 8px; min-height: 20px;">Enter roll number to auto-fill holder details.</p>
                <div class="form-buttons">
                    <button class="secondary" onclick="clearLeadershipForm()">Clear</button>
                    <button onclick="saveLeadershipPost()">Save Post</button>
                </div>
            </div>

            <div class="scoreboard-wrapper">
                <div class="scoreboard-scroll">
                    <table class="scoreboard" id="leadershipTable">
                        <thead>
                            <tr>
                                <th>Post</th>
                                <th style="width: 220px;">Post Holder</th>
                                <th style="width: 130px;">Roll</th>
                                <th style="width: 160px;">Selection Date</th>
                                <th style="width: 180px;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="leadershipBody">
                            <tr>
                                <td colspan="5" class="text-center loading">Loading...</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </div>
        </div>

        <!-- TAB: OFFICE HOLDERS -->
        <div id="office-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-id-badge"></i> Post Holders Overview</h3>
                <p class="section-subtitle">Tenure: Co-Leader and all CR posts are 1 month. All other post holders are 2 months (from selection date).</p>
                <div class="form-buttons" style="margin-bottom: 12px;">
                    <button class="secondary" onclick="refreshPostHolderNotifications()" data-teacher-allow="true">Refresh Status</button>
                    <button onclick="endAllPostHolderTenures()" id="endAllTenuresBtn">End Tenure of All Post Holders</button>
                </div>
                <div class="form-grid" style="margin-bottom: 12px;">
                    <div class="form-group">
                        <label>Extend Tenure (Months)</label>
                        <input type="number" id="extendTenureMonths" min="1" max="12" value="1">
                    </div>
                    <div class="form-group">
                        <label>Reason for Extension</label>
                        <input type="text" id="extendTenureReason" placeholder="Reason for extension...">
                    </div>
                    <div class="form-group" style="align-self: end;">
                        <button onclick="extendAllPostHolderTenures()" id="extendAllTenuresBtn">Extend Tenure for All Active Post Holders</button>
                    </div>
                </div>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th>Post</th>
                                    <th style="width: 220px;">Holder</th>
                                    <th style="width: 130px;">Roll</th>
                                    <th style="width: 140px;">Selection</th>
                                    <th style="width: 140px;">Tenure End</th>
                                    <th style="width: 120px;">Status</th>
                                    <th style="width: 180px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="officeLeadershipBody">
                                <tr>
                                    <td colspan="7" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <!-- Group Class Representatives (A/B/C/D) — same data as CR Tab -->
            <div class="form-card">
                <h3><i class="fas fa-user-check"></i> Group Class Representatives (CR)</h3>
                <p class="section-subtitle">Tenure: 1 month. Shared with the CR Tab. Admin edits are immediate; Teacher edits require Admin approval. To assign, use the CR Tab Edit button or go to <strong>Class Representative (CR)</strong> tab.</p>
                <div class="scoreboard-wrapper" style="margin-top: 10px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th style="width: 120px;">Group</th>
                                    <th>Holder</th>
                                    <th style="width: 130px;">Roll</th>
                                    <th style="width: 140px;">Selection</th>
                                    <th style="width: 140px;">Tenure End</th>
                                    <th style="width: 120px;">Status</th>
                                    <th style="width: 180px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="classRepBody">
                                <tr>
                                    <td colspan="7" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="form-card">
                <h3><i class="fas fa-flag"></i> Party Presidents (PP)</h3>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th>Party</th>
                                    <th>President</th>
                                    <th style="width: 120px;">Roll</th>
                                    <th style="width: 140px;">Selection</th>
                                    <th style="width: 140px;">Tenure End</th>
                                    <th style="width: 120px;">Status</th>
                                    <th style="width: 180px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="partyPresidentBody">
                                <tr>
                                    <td colspan="7" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: VOTING -->
        <div id="voting-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-user-plus"></i> Candidate Module</h3>
                <p class="section-subtitle">Add candidates for posts before starting the vote.</p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Post *</label>
                        <select id="candidatePost" onchange="updateCandidateStudentsByPost()"></select>
                    </div>
                    <div class="form-group">
                        <label>Student *</label>
                        <select id="candidateStudent"></select>
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="clearCandidateForm()">Clear</button>
                    <button onclick="saveCandidate()">Add Candidate</button>
                </div>
                <div class="scoreboard-wrapper" style="margin-top: 15px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th>Post</th>
                                    <th>Candidate</th>
                                    <th style="width: 120px;">Roll</th>
                                    <th style="width: 120px;">Class</th>
                                    <th style="width: 160px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="candidateBody">
                                <tr>
                                    <td colspan="5" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="form-card">
                <h3><i class="fas fa-vote-yea"></i> Voting Booth</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Post *</label>
                        <select id="votePost" onchange="loadVotingCandidates()"></select>
                    </div>
                    <div class="form-group">
                        <label>Party (PP)</label>
                        <select id="voteParty"></select>
                    </div>
                    <div class="form-group">
                        <label>PP Roll No.</label>
                        <input type="text" id="voteRoll" placeholder="Enter PP Roll No." oninput="autoVerifyPartyPresident()">
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="verifyPartyPresident()">Verify PP</button>
                    <button onclick="resetVoteSession()">Reset</button>
                </div>
                <div id="voteStatus" class="section-subtitle" style="margin-top: 12px;"></div>
                <div class="scoreboard-wrapper" style="margin-top: 15px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th>Candidate</th>
                                    <th style="width: 120px;">Roll</th>
                                    <th style="width: 120px;">Class</th>
                                    <th style="width: 120px;">Votes</th>
                                    <th style="width: 160px;">Action</th>
                                </tr>
                            </thead>
                            <tbody id="votingBody">
                                <tr>
                                    <td colspan="5" class="text-center loading">Select a post to vote</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div id="voteResult" class="section-subtitle" style="margin-top: 15px;"></div>
            </div>

            <div class="form-card">
                <h3><i class="fas fa-users"></i> Group Voting Booth (Student Vote)</h3>
                <p class="section-subtitle">For CR elections, any student can vote. One vote per student per post.</p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Student Voter *</label>
                        <select id="groupVoteStudent" onchange="updateGroupVoteStudentDetails(); loadGroupVotingCandidates();"></select>
                    </div>
                    <div class="form-group">
                        <label>Post *</label>
                        <select id="groupVotePost" onchange="loadGroupVotingCandidates()"></select>
                    </div>
                    <div class="form-group">
                        <label>Group Filter</label>
                        <select id="groupVoteGroupFilter" onchange="populateGroupVoteStudentSelect(); updateGroupVoteStudentDetails(); loadGroupVotingCandidates();">
                            <option value="">All Groups</option>
                            <option value="A">Group A</option>
                            <option value="B">Group B</option>
                            <option value="C">Group C</option>
                            <option value="D">Group D</option>
                        </select>
                    </div>
                </div>
                <div class="group-vote-info-grid">
                    <div class="group-vote-info-card">
                        <span class="label">Class</span>
                        <span class="value" id="groupVoteStudentClass">-</span>
                    </div>
                    <div class="group-vote-info-card">
                        <span class="label">Group</span>
                        <span class="value" id="groupVoteStudentGroup">-</span>
                    </div>
                    <div class="group-vote-info-card">
                        <span class="label">Party</span>
                        <span class="value" id="groupVoteStudentParty">-</span>
                    </div>
                </div>
                <div class="form-buttons" style="margin-top: 10px;">
                    <button class="secondary" onclick="loadGroupVotingCandidates()">Refresh</button>
                    <button onclick="openGroupVoteDialog()">Open Voting Booth</button>
                </div>
                <div id="groupVoteStatus" class="section-subtitle" style="margin-top: 12px;"></div>
                <div class="scoreboard-wrapper" style="margin-top: 15px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th>Candidate</th>
                                    <th style="width: 120px;">Roll</th>
                                    <th style="width: 120px;">Class</th>
                                    <th style="width: 120px;">Votes</th>
                                    <th style="width: 160px;">Action</th>
                                </tr>
                            </thead>
                            <tbody id="groupVotingBody">
                                <tr>
                                    <td colspan="5" class="text-center loading">Select a post to load candidates</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="form-buttons" style="margin-top: 12px; justify-content: flex-start;">
                    <button class="secondary" onclick="renderGroupVoteResults(getGroupVoteSelectedPost(), true, true)">Conclude Voting</button>
                    <button onclick="renderGroupVoteResults(getGroupVoteSelectedPost(), false, true)">Results</button>
                </div>
                <div id="groupVoteResult" class="section-subtitle" style="margin-top: 15px;"></div>
            </div>

            <div class="form-card hidden" id="pendingElectionCard">
                <h3><i class="fas fa-check-circle"></i> Pending Election Approvals</h3>
                <p class="section-subtitle">Admins must approve clear winners before posts are applied.</p>
                <div class="scoreboard-wrapper" style="margin-top: 12px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th>Post</th>
                                    <th>Candidate</th>
                                    <th style="width: 140px;">Source</th>
                                    <th style="width: 120px;">Status</th>
                                    <th style="width: 170px;">Submitted</th>
                                    <th style="width: 180px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="pendingElectionBody">
                                <tr>
                                    <td colspan="6" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: TEACHERS -->
        <div id="teachers-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-chalkboard-teacher"></i> Teacher Profiles</h3>
                <p class="section-subtitle">Add teachers so they appear in teacher voting.</p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Name *</label>
                        <input type="text" id="teacherName">
                    </div>
                    <div class="form-group">
                        <label>Roll/ID</label>
                        <input type="text" id="teacherRoll">
                    </div>
                    <div class="form-group">
                        <label>Subject</label>
                        <input type="text" id="teacherSubject">
                    </div>
                    <div class="form-group">
                        <label>Active</label>
                        <select id="teacherActive">
                            <option value="true">Active</option>
                            <option value="false">Inactive</option>
                        </select>
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="resetTeacherForm()">Clear</button>
                    <button onclick="saveTeacher()">Save Teacher</button>
                </div>
                <div class="scoreboard-wrapper" style="margin-top: 12px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th style="width: 140px;">Name</th>
                                    <th style="width: 120px;">Roll/ID</th>
                                    <th style="width: 140px;">Subject</th>
                                    <th style="width: 90px;">Active</th>
                                    <th style="width: 140px;">Actions</th>
                                </tr>
                            </thead>
                            <tbody id="teacherBody">
                                <tr><td colspan="5" class="text-center loading">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: TEACHER VOTING -->
        <div id="teacher-voting-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-vote-yea"></i> Teacher Voting Booth</h3>
                <p class="section-subtitle">Teachers vote with vote power = highest student vote power + 5.</p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Teacher *</label>
                        <select id="teacherVoteTeacher" onchange="updateTeacherVotePower(); loadTeacherVotingCandidates();"></select>
                    </div>
                    <div class="form-group">
                        <label>Post *</label>
                        <select id="teacherVotePost" onchange="loadTeacherVotingCandidates()"></select>
                    </div>
                    <div class="form-group">
                        <label>Vote Power</label>
                        <div id="teacherVotePowerDisplay" style="padding: 10px 12px; font-weight:700;">-</div>
                    </div>
                </div>
                <div id="teacherVoteStatus" class="section-subtitle" style="margin-top: 8px;"></div>
                <div class="scoreboard-wrapper" style="margin-top: 12px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th>Candidate</th>
                                    <th style="width: 120px;">Roll</th>
                                    <th style="width: 120px;">Class</th>
                                    <th style="width: 120px;">Weighted Votes</th>
                                    <th style="width: 160px;">Action</th>
                                </tr>
                            </thead>
                            <tbody id="teacherVotingBody">
                                <tr><td colspan="5" class="text-center loading">Select teacher & post</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div class="form-buttons" style="margin-top: 10px; justify-content:flex-start;">
                    <button class="secondary" onclick="renderTeacherVoteResults(getElementValue('teacherVotePost'), true, true)">Conclude Voting</button>
                    <button onclick="renderTeacherVoteResults(getElementValue('teacherVotePost'), false, true)">Results</button>
                </div>
                <div id="teacherVoteResult" class="section-subtitle" style="margin-top: 12px;"></div>
            </div>
        </div>

        <!-- TAB: APPEALS -->
        <div id="appeals-tab" class="tab-content hidden">
            <div class="form-card" id="appealSubmitCard">
                <h3><i class="fas fa-paper-plane"></i> Submit Appeal</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Forward To</label>
                        <select id="appealTargetRole"></select>
                    </div>
                    <div class="form-group">
                        <label>Subject</label>
                        <input type="text" id="appealSubject" placeholder="Short reason/title">
                    </div>
                </div>
                <div class="form-group">
                    <label>Request Message *</label>
                    <textarea id="appealMessage" rows="4" placeholder="Write your request in plain text..."></textarea>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="clearAppealForm()">Clear</button>
                    <button onclick="submitAppeal()">Send Request</button>
                </div>
            </div>
            <div class="form-card hidden" id="appealAdminNotice">
                <h3><i class="fas fa-bullhorn"></i> Admin Actions</h3>
                <p style="color: var(--text-muted); margin-bottom: 0;">
                    Admins cannot submit appeals. Use this panel to review and act on appeals from teachers and students.
                </p>
            </div>

            <div class="form-card">
                <h3><i class="fas fa-inbox"></i> Request Section</h3>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="appealsTable">
                            <thead>
                                <tr>
                                    <th style="width: 90px;">ID</th>
                                    <th style="width: 140px;">From</th>
                                    <th style="width: 120px;">To</th>
                                    <th>Message</th>
                                    <th style="width: 130px;">Status</th>
                                    <th style="width: 150px;">Recommendation</th>
                                    <th style="width: 220px;">Actions</th>
                                    <th style="width: 170px;">Updated</th>
                                </tr>
                            </thead>
                            <tbody id="appealsBody">
                                <tr>
                                    <td colspan="8" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="form-card">
                <h3><i class="fas fa-history"></i> Post Holder History Report</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Month</label>
                        <select id="postHistoryMonth" onchange="loadPostHolderHistoryReport()"></select>
                    </div>
                    <div class="form-group">
                        <label>From Date</label>
                        <input type="date" id="postHistoryFrom" onchange="loadPostHolderHistoryReport()">
                    </div>
                    <div class="form-group">
                        <label>To Date</label>
                        <input type="date" id="postHistoryTo" onchange="loadPostHolderHistoryReport()">
                    </div>
                    <div class="form-group">
                        <label>Status</label>
                        <select id="postHistoryStatus" onchange="loadPostHolderHistoryReport()">
                            <option value="all">All</option>
                            <option value="active">Active</option>
                            <option value="suspended">Suspended</option>
                            <option value="ended">Ended</option>
                        </select>
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="clearPostHistoryFilters()">Clear Filters</button>
                </div>
                <div class="scoreboard-wrapper" style="margin-top: 15px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="postHistoryTable">
                            <thead>
                                <tr>
                                    <th>Post</th>
                                    <th>Holder</th>
                                    <th style="width: 110px;">Roll</th>
                                    <th style="width: 140px;">Start</th>
                                    <th style="width: 140px;">End</th>
                                    <th style="width: 130px;">Duration</th>
                                    <th style="width: 110px;">Status</th>
                                </tr>
                            </thead>
                            <tbody id="postHistoryBody">
                                <tr>
                                    <td colspan="7" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: NOTIFICATIONS -->
        <div id="notifications-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-bell"></i> Notifications</h3>
                <p class="section-subtitle">Live post-holder alerts and system messages.</p>

                <!-- Filter + Refresh bar -->
                <div class="notif-filter-bar">
                    <button id="notifF_all"    onclick="setNotifFilter('all')"    data-allow="true" class="nf-active">All</button>
                    <button id="notifF_danger" onclick="setNotifFilter('danger')" data-allow="true"><i class="fas fa-circle" style="font-size:7px;vertical-align:middle;margin-right:3px"></i>Overdue</button>
                    <button id="notifF_warn"   onclick="setNotifFilter('warn')"   data-allow="true"><i class="fas fa-circle" style="font-size:7px;vertical-align:middle;margin-right:3px"></i>Warning</button>
                    <button id="notifF_info"   onclick="setNotifFilter('info')"   data-allow="true"><i class="fas fa-circle" style="font-size:7px;vertical-align:middle;margin-right:3px"></i>Info</button>
                    <button class="secondary"  onclick="refreshPostHolderNotifications()" data-allow="true" style="margin-left:auto;padding:4px 12px;font-size:12px"><i class="fas fa-sync-alt"></i> Refresh</button>
                </div>

                <!-- Live alerts -->
                <div class="notif-section-header">
                    <span><i class="fas fa-broadcast-tower"></i>Live Alerts</span>
                    <span class="notif-count-badge" id="notifLiveCount">0</span>
                </div>
                <div id="notifLiveList" style="display:grid;gap:7px">
                    <div class="notif-empty"><i class="fas fa-check-circle" style="color:#22c55e"></i><p>All clear — no active alerts.</p></div>
                </div>

                <!-- Inline detail panel (shown on card click) -->
                <div id="notifDetailPanel" class="notif-detail-panel" style="display:none"></div>

                <!-- History log -->
                <div class="notif-section-header" style="margin-top:22px">
                    <span><i class="fas fa-history"></i>Notification Log</span>
                    <button id="notifClearHistBtn" onclick="clearNotificationHistory()" data-allow="true"
                        style="display:none;font-size:11px;padding:2px 10px;border-radius:6px;border:1px solid rgba(239,68,68,0.4);background:rgba(239,68,68,0.1);color:#f87171;cursor:pointer">
                        <i class="fas fa-trash-alt"></i> Clear
                    </button>
                </div>
                <div id="notifHistoryList" style="display:grid;gap:3px">
                    <div class="notif-empty"><i class="fas fa-inbox"></i><p>No log entries yet.</p></div>
                </div>
            </div>
        </div>

        <!-- TAB: ACTIVITY LOG -->
        <div id="activity-log-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-clipboard-list"></i> Activity Log</h3>
                <p class="section-subtitle">Auditable user activity stream. Filter by user, class, student, month, or date range.</p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>User</label>
                        <select id="activityLogUserFilter" onchange="loadActivityLogTab()">
                            <option value="">All Users</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Class</label>
                        <select id="activityLogClassFilter" onchange="loadActivityLogTab()">
                            <option value="">All Classes</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Student</label>
                        <input type="text" id="activityLogStudentFilter" placeholder="Roll or name" oninput="loadActivityLogTab()">
                    </div>
                    <div class="form-group">
                        <label>Month</label>
                        <input type="month" id="activityLogMonthFilter" onchange="loadActivityLogTab()">
                    </div>
                    <div class="form-group">
                        <label>Date From</label>
                        <input type="date" id="activityLogFromDate" onchange="loadActivityLogTab()">
                    </div>
                    <div class="form-group">
                        <label>Date To</label>
                        <input type="date" id="activityLogToDate" onchange="loadActivityLogTab()">
                    </div>
                </div>
                <div class="form-buttons" style="margin-top:8px;">
                    <button class="secondary" onclick="resetActivityLogFilters()" data-allow="true"><i class="fas fa-eraser"></i> Reset Filters</button>
                    <button class="secondary" onclick="loadActivityLogTab()" data-allow="true"><i class="fas fa-sync-alt"></i> Refresh</button>
                </div>
                <div class="scoreboard-wrapper" style="margin-top:12px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard">
                            <thead>
                                <tr>
                                    <th style="width: 170px;">Timestamp</th>
                                    <th style="width: 130px;">User</th>
                                    <th style="width: 80px;">Role</th>
                                    <th style="width: 70px;">Class</th>
                                    <th style="width: 190px;">Student</th>
                                    <th style="width: 130px;">Entity</th>
                                    <th style="width: 110px;">Action</th>
                                    <th style="width: 120px;">Date</th>
                                    <th>Detail</th>
                                </tr>
                            </thead>
                            <tbody id="activityLogBody">
                                <tr><td colspan="9" class="text-center loading">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: ATTENDANCE -->
        <div id="attendance-tab" class="tab-content hidden">
            <div class="form-card" id="markAttendanceCard">
                <h3><i class="fas fa-calendar-check"></i> Mark Attendance</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Date</label>
                        <input type="date" id="attendanceDate" onchange="loadAttendanceTab()">
                    </div>
                    <div class="form-group">
                        <label>Month</label>
                        <select id="attendanceMonth" onchange="loadAttendanceTab()"></select>
                    </div>
                    <div class="form-group">
                        <label>Group Filter</label>
                        <select id="attendanceGroupFilter" onchange="loadAttendanceTab()">
                            <option value="all">All Groups</option>
                            <option value="A">Group A</option>
                            <option value="B">Group B</option>
                            <option value="C">Group C</option>
                            <option value="D">Group D</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Status Filter</label>
                        <select id="attendanceStatusFilter" onchange="loadAttendanceTab()">
                            <option value="active" selected>Active Only</option>
                            <option value="all">All</option>
                            <option value="inactive">Inactive Only</option>
                        </select>
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="markAllAttendance('present')">Mark All Present</button>
                    <button class="secondary" onclick="markAllAttendance('absent')">Mark All Absent</button>
                    <button onclick="saveAttendance()">Save Attendance</button>
                </div>

                <div class="scoreboard-wrapper" style="margin-top: 15px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="attendanceTable">
                            <thead>
                                <tr>
                                    <th style="width: 110px;">Roll</th>
                                    <th>Student</th>
                                    <th style="width: 80px;">Class</th>
                                    <th style="width: 80px;">Group</th>
                                    <th style="width: 180px;">Status</th>
                                    <th style="width: 220px;">Remarks</th>
                                </tr>
                            </thead>
                            <tbody id="attendanceBody">
                                <tr>
                                    <td colspan="6" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="form-card" id="bulkPastAttendanceCard">
                <h3><i class="fas fa-calendar-alt"></i> Bulk Past Attendance (Rapid)</h3>
                <p class="section-subtitle">Separate module for fast previous-month marking. Select dates to mark and apply in one click.</p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Target Month</label>
                        <input type="month" id="bulkAttendanceMonth" onchange="syncBulkDateInputBounds(); populateBulkAttendanceStudentOptions();">
                    </div>
                    <div class="form-group">
                        <label>Group Filter</label>
                        <select id="bulkAttendanceGroupFilter" onchange="populateBulkAttendanceStudentOptions()">
                            <option value="all">All Groups</option>
                            <option value="A">Group A</option>
                            <option value="B">Group B</option>
                            <option value="C">Group C</option>
                            <option value="D">Group D</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Student Status</label>
                        <select id="bulkAttendanceStudentStatus" onchange="populateBulkAttendanceStudentOptions()">
                            <option value="active" selected>Active Only</option>
                            <option value="all">All</option>
                            <option value="inactive">Inactive Only</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Student</label>
                        <select id="bulkAttendanceStudent">
                            <option value="">Select Student...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Selection 1 Status (Required)</label>
                        <select id="bulkAttendanceMarkStatus1" onchange="renderBulkAttendanceCalendar(); renderBulkAttendanceDates();">
                            <option value="absent">Absent</option>
                            <option value="leave">Leave</option>
                            <option value="present">Present</option>
                            <option value="late">Late</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Selection 2 Status (Optional)</label>
                        <select id="bulkAttendanceMarkStatus2" onchange="renderBulkAttendanceCalendar(); renderBulkAttendanceDates();">
                            <option value="">None</option>
                            <option value="absent">Absent</option>
                            <option value="leave">Leave</option>
                            <option value="present">Present</option>
                            <option value="late">Late</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Selection 3 Status (Optional)</label>
                        <select id="bulkAttendanceMarkStatus3" onchange="renderBulkAttendanceCalendar(); renderBulkAttendanceDates();">
                            <option value="">None</option>
                            <option value="absent">Absent</option>
                            <option value="leave">Leave</option>
                            <option value="present">Present</option>
                            <option value="late">Late</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Remarks</label>
                        <input type="text" id="bulkAttendanceRemarks" placeholder="Optional comments">
                    </div>
                    <div class="form-group">
                        <label>Remaining Dates Status</label>
                        <select id="bulkAttendanceDefaultStatus">
                            <option value="present" selected>Present</option>
                            <option value="absent">Absent</option>
                            <option value="leave">Leave</option>
                            <option value="late">Late</option>
                        </select>
                    </div>
                </div>
                <div class="form-buttons" style="margin-bottom: 8px;">
                    <button class="secondary" id="bulkSlot1Btn" onclick="setBulkSelectionSlot(1)">Selection 1</button>
                    <button class="secondary" id="bulkSlot2Btn" onclick="setBulkSelectionSlot(2)">Selection 2</button>
                    <button class="secondary" id="bulkSlot3Btn" onclick="setBulkSelectionSlot(3)">Selection 3</button>
                </div>
                <div id="bulkAttendanceCalendar" class="bulk-calendar"></div>
                <div class="form-buttons">
                    <button class="secondary" onclick="clearBulkAttendanceDates()">Clear Dates</button>
                    <button onclick="applyBulkPastAttendance()">Apply Bulk Attendance</button>
                </div>
                <div id="bulkDateList" class="bulk-date-list"></div>
                <p class="section-subtitle" style="margin-top: 8px;">Logic: selected dates are set to chosen status; all remaining dates of that month are set to selected remaining status.</p>
            </div>

            <div class="form-card" id="attendanceGroupReportCard">
                <h3><i class="fas fa-chart-line"></i> Attendance Report (Group-wise)</h3>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="attendanceReportTable">
                            <thead>
                                <tr>
                                    <th>Group</th>
                                    <th style="width: 120px;">Students</th>
                                    <th style="width: 140px;">Present %</th>
                                    <th style="width: 120px;">Present</th>
                                    <th style="width: 120px;">Absent</th>
                                    <th style="width: 120px;">Late</th>
                                    <th style="width: 120px;">Leave</th>
                                </tr>
                            </thead>
                            <tbody id="attendanceReportBody">
                                <tr>
                                    <td colspan="7" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>

            <div class="form-card" id="attendanceStudentReportCard">
                <h3><i class="fas fa-user-list"></i> Attendance Report (Student-wise)</h3>
                <div class="form-grid" style="margin-bottom: 10px;">
                    <div class="form-group">
                        <label>Month</label>
                        <select id="attendanceStudentReportMonth" onchange="loadAttendanceReport()"></select>
                    </div>
                    <div class="form-group" id="attendanceStudentReportGroupFilterGroup">
                        <label>Group</label>
                        <select id="attendanceStudentReportGroup" onchange="loadAttendanceReport()">
                            <option value="all">All Groups</option>
                        </select>
                    </div>
                    <div class="form-group" id="attendanceStudentReportClassFilterGroup">
                        <label>Class</label>
                        <select id="attendanceStudentReportClass" onchange="loadAttendanceReport()">
                            <option value="">All Classes</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Date From</label>
                        <input type="date" id="attendanceStudentReportFrom" onchange="loadAttendanceReport()">
                    </div>
                    <div class="form-group">
                        <label>Date To</label>
                        <input type="date" id="attendanceStudentReportTo" onchange="loadAttendanceReport()">
                    </div>
                </div>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="attendanceStudentReportTable">
                            <thead>
                                <tr>
                                    <th style="width: 110px;">Roll</th>
                                    <th>Student</th>
                                    <th style="width: 80px;">Class</th>
                                    <th style="width: 90px;">Group</th>
                                    <th style="width: 120px;">Present</th>
                                    <th style="width: 120px;">Absent</th>
                                    <th style="width: 120px;">Late</th>
                                    <th style="width: 120px;">Leave</th>
                                    <th style="width: 120px;">Present %</th>
                                </tr>
                            </thead>
                            <tbody id="attendanceStudentReportBody">
                                <tr>
                                    <td colspan="9" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: STUDENT PROFILES -->
        <div id="profile-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-id-card"></i> Student Profile Overview</h3>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Month</label>
                        <select id="profileMonth" onchange="loadProfileTab()"></select>
                    </div>
                    <div class="form-group">
                        <label>Group Filter</label>
                        <select id="profileGroupFilter" onchange="populateProfileStudents(); loadProfileTab();">
                            <option value="all">All Groups</option>
                            <option value="A">Group A</option>
                            <option value="B">Group B</option>
                            <option value="C">Group C</option>
                            <option value="D">Group D</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Student</label>
                        <select id="profileStudent" onchange="loadProfileTab()">
                            <option value="">Select Student...</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Profile Remark</label>
                        <input type="text" id="profileRemark" placeholder="Add comment for this student">
                    </div>
                </div>
                <div class="form-buttons">
                    <button onclick="saveProfileRemark()">Save Remark</button>
                    <button class="secondary hidden" id="editOwnProfileBtn" data-allow="true" onclick="openSelfProfileEdit()">Edit My Profile</button>
                </div>
                <div id="profileMetrics" class="profile-grid"></div>
            </div>
            <div class="form-card">
                <h3><i class="fas fa-history"></i> Post Holder History (Student)</h3>
                <p id="profilePostHistoryEmpty" class="section-subtitle">Select a student to view post history.</p>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="profilePostHistoryTable">
                            <thead>
                                <tr>
                                    <th>Post</th>
                                    <th style="width: 110px;">Roll</th>
                                    <th style="width: 140px;">Start</th>
                                    <th style="width: 140px;">End</th>
                                    <th style="width: 130px;">Duration</th>
                                    <th style="width: 120px;">Status</th>
                                </tr>
                            </thead>
                            <tbody id="profilePostHistoryBody">
                                <tr>
                                    <td colspan="6" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: HOMEWORK -->
        <div id="homework-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-book-reader"></i> Homework Endorsement</h3>
                <p id="homeworkPendingNotice" class="section-subtitle"></p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Date</label>
                        <input type="date" id="homeworkDate">
                    </div>
                    <div class="form-group">
                        <label>Month</label>
                        <select id="homeworkMonth" onchange="populateHomeworkStudents(); loadHomeworkTable();"></select>
                    </div>
                    <div class="form-group">
                        <label>Group</label>
                        <select id="homeworkGroupFilter" onchange="populateHomeworkStudents(); loadHomeworkTable();">
                            <option value="all">All Groups</option>
                            <option value="A">Group A</option>
                            <option value="B">Group B</option>
                            <option value="C">Group C</option>
                            <option value="D">Group D</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Endorsement Scope</label>
                        <select id="homeworkScope" onchange="toggleHomeworkScope()">
                            <option value="single">Single Student</option>
                            <option value="group">Whole Group</option>
                            <option value="selected">Selected Students</option>
                        </select>
                    </div>
                    <div class="form-group" id="homeworkSingleWrap">
                        <label>Student</label>
                        <select id="homeworkStudentSingle">
                            <option value="">Select Student...</option>
                        </select>
                    </div>
                    <div class="form-group hidden" id="homeworkMultiWrap">
                        <label>Selected Students</label>
                        <select id="homeworkStudentMulti" multiple size="5"></select>
                    </div>
                    <div class="form-group hidden" id="homeworkGroupNoteWrap">
                        <label>Group Target</label>
                        <input type="text" id="homeworkGroupNote" value="All students in selected group" readonly>
                    </div>
                    <div class="form-group">
                        <label>Status</label>
                        <select id="homeworkStatus">
                            <option value="completed">Completed</option>
                            <option value="not_completed">Not Completed</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label>Remarks</label>
                        <input type="text" id="homeworkRemarks" placeholder="Optional homework remarks">
                    </div>
                </div>
                <div class="form-buttons">
                    <button class="secondary" onclick="saveHomeworkEndorsement('completed')">Completed</button>
                    <button class="secondary" onclick="saveHomeworkEndorsement('not_completed')">Not Completed</button>
                    <button onclick="saveHomeworkEndorsement()">Save Endorsement</button>
                    <button class="secondary" onclick="submitHomeworkForPerusal()">Submit for Perusal</button>
                </div>

                <div class="scoreboard-wrapper" style="margin-top: 15px;">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="homeworkTable">
                            <thead>
                                <tr>
                                    <th style="width: 120px;">Date</th>
                                    <th style="width: 110px;">Roll</th>
                                    <th>Student</th>
                                    <th style="width: 90px;">Group</th>
                                    <th style="width: 140px;">Status</th>
                                    <th style="width: 220px;">Remarks</th>
                                    <th style="width: 130px;">Marked By</th>
                                    <th style="width: 150px;">Perusal</th>
                                </tr>
                            </thead>
                            <tbody id="homeworkBody">
                                <tr>
                                    <td colspan="8" class="text-center loading">Loading...</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- TAB: TOOLS -->
        <!-- TAB: GOOD CONDUCT BADGE -->
        <div id="good-conduct-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-award"></i> Good Conduct Badge — Eligibility</h3>
                <p style="color: var(--text-muted); margin-bottom: 8px; font-size: 13px;">
                    Students eligible for the Good Conduct Badge based on attendance and score performance across all months.
                </p>
                <div id="goodConductFormula" style="background: rgba(16, 185, 129, 0.08); border: 1px solid rgba(16, 185, 129, 0.25); border-radius: 8px; padding: 12px 16px; margin-bottom: 16px; font-size: 13px; color: var(--text-muted);">
                    <strong style="color: #6ee7b7;">Formula:</strong>
                    Attendance Rate ≥ 75% across all months &nbsp;|&nbsp;
                    Average Monthly Score ≥ 0 (net positive) &nbsp;|&nbsp;
                    No month with score below −100 &nbsp;|&nbsp;
                    VETO usage ≤ 1 total &nbsp;|&nbsp;
                    Must be Active student
                </div>
                <div class="controls" style="margin-bottom: 12px;">
                    <div class="control-group">
                        <label>Filter</label>
                        <select id="goodConductFilter" onchange="renderGoodConductBadge()">
                            <option value="eligible">Eligible Only</option>
                            <option value="all">All Students (with status)</option>
                        </select>
                    </div>
                </div>
                <div class="scoreboard-wrapper">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="goodConductTable">
                            <thead>
                                <tr>
                                    <th style="width: 50px;">#</th>
                                    <th style="width: 100px;">Roll</th>
                                    <th>Student Name</th>
                                    <th style="width: 80px;">Group</th>
                                    <th style="width: 100px;">Attendance %</th>
                                    <th style="width: 100px;">Avg Score</th>
                                    <th style="width: 100px;">Months</th>
                                    <th style="width: 80px;">VETOs Used</th>
                                    <th style="width: 100px;">Lowest Month</th>
                                    <th style="width: 120px;">Badge Status</th>
                                </tr>
                            </thead>
                            <tbody id="goodConductBody">
                                <tr><td colspan="10" class="text-center loading">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <div id="tools-tab" class="tab-content hidden">
            <div class="form-card">
                <h3><i class="fas fa-file-import"></i> Excel Uploads</h3>
                <p style="color: var(--text-muted); margin-bottom: 15px; font-size: 14px;">
                    Use separate uploads for historical data and the latest active roster.
                </p>
                <div class="form-grid">
                    <div class="form-group">
                        <label>Historical Data Workbook</label>
                        <input type="file" id="excelFile" accept=".xlsx,.xls,.xlsm">
                    </div>
                    <div class="form-group" style="display: flex; align-items: end;">
                        <button onclick="importExcel()">Import Historical Data</button>
                    </div>
                </div>
                <div class="form-grid" style="margin-top: 10px;">
                    <div class="form-group">
                        <label>Latest Active Roster Workbook</label>
                        <input type="file" id="activeRosterFile" accept=".xlsx,.xls,.xlsm">
                    </div>
                    <div class="form-group">
                        <label>Target Month (Optional)</label>
                        <input type="month" id="activeRosterMonth">
                    </div>
                </div>
                <div class="form-buttons" style="margin-top: 6px;">
                    <button class="secondary" onclick="importActiveRosterExcel()">Import Latest Active Roster</button>
                </div>
            </div>

            <div class="form-card">
                <h3><i class="fas fa-wifi"></i> LAN Sync & Backups</h3>
                <p style="color: var(--text-muted); margin-bottom: 8px; font-size: 14px;">
                    Your work is saved locally and LAN sync runs in near real-time. Use Master Update for forced convergence across devices.
                </p>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button onclick="syncNow()"><i class="fas fa-bolt"></i> Master Update (3s)</button>
                    <button class="secondary" data-allow="true" onclick="pullFromServer(true, true)"><i class="fas fa-cloud-download-alt"></i> Pull Latest</button>
                    <button class="secondary" data-allow="true" onclick="downloadServerBackup()"><i class="fas fa-download"></i> Download Server Backup</button>
                    <button class="secondary" data-allow="true" id="installAppBtn" style="display: none;"><i class="fas fa-mobile-alt"></i> Install App</button>
                </div>
                <div class="form-grid" style="margin-top: 12px;">
                    <div class="form-group">
                        <label>Primary Server URL</label>
                        <input type="text" id="primaryServerUrl" placeholder="http://192.168.1.10:5000">
                    </div>
                    <div class="form-group">
                        <label>Backup Server URL</label>
                        <input type="text" id="backupServerUrl" placeholder="http://192.168.1.11:5000">
                    </div>
                </div>
                <div class="form-buttons" style="margin-top: 8px;">
                    <button class="secondary" data-allow="true" onclick="saveServerEndpoints()">Save Server Endpoints</button>
                </div>
                <div style="margin-top: 10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom:6px;">
                        <strong>LAN Server Health</strong>
                        <button class="secondary" data-allow="true" onclick="refreshServerHealth()"><i class="fas fa-heartbeat"></i> Refresh Health</button>
                    </div>
                    <div id="serverHealthPanel" style="border:1px solid rgba(148,163,184,0.25); border-radius:8px; overflow:hidden;">
                        <table class="scoreboard" style="margin:0;">
                            <thead>
                                <tr>
                                    <th>Server</th>
                                    <th>Status</th>
                                    <th>Last Data Stamp</th>
                                    <th>Students</th>
                                    <th>Scores</th>
                                </tr>
                            </thead>
                            <tbody id="serverHealthBody">
                                <tr><td colspan="5" style="text-align:center; color:var(--text-muted);">Health check pending...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <p class="section-subtitle" style="margin-top: 8px;">
                    If server is down, installed app keeps working locally and auto-syncs queued changes when any configured server comes back online.
                </p>
            </div>

            <div class="export-area">
                <button onclick="exportToExcel()"><i class="fas fa-download"></i> Export as Excel</button>
                <button class="secondary" onclick="exportJSON()"><i class="fas fa-code"></i> Export as JSON</button>
                <button class="secondary" onclick="importJSON()"><i class="fas fa-upload"></i> Import JSON</button>
            </div>

            <div class="form-card">
                <h3><i class="fas fa-database"></i> Database Management</h3>
                <p style="color: var(--text-muted); margin-bottom: 15px; font-size: 14px;">
                    Manage your offline database
                </p>
                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                    <button class="secondary" onclick="backupData()"><i class="fas fa-save"></i> Backup Data</button>
                    <button class="secondary" onclick="showStats()"><i class="fas fa-chart-bar"></i> Show Stats</button>
                    <button class="secondary" onclick="loadFeb26Seed()"><i class="fas fa-database"></i> Load Feb 26 Data</button>
                    <button class="danger" onclick="clearAllData()"><i class="fas fa-trash"></i> Clear All Data</button>
                </div>
                <hr style="margin: 16px 0; border-color: rgba(148,163,184,0.2);">
                <h4 style="margin-bottom: 8px;"><i class="fas fa-history"></i> Restore From Backup (Admin)</h4>
                <p style="color: var(--text-muted); margin-bottom: 10px; font-size: 13px;">
                    Preview and restore a server backup. Current live data is auto-backed up before restore.
                </p>
                <div style="display:flex; gap:10px; flex-wrap:wrap; margin-bottom:10px;">
                    <button class="secondary" onclick="loadRestorePoints()"><i class="fas fa-list"></i> Refresh Restore List</button>
                    <button class="secondary" onclick="previewRestorePoint()"><i class="fas fa-eye"></i> Preview Selected</button>
                    <button class="secondary" onclick="toggleRestorePointLock(true)"><i class="fas fa-lock"></i> Lock + Label</button>
                    <button class="secondary" onclick="toggleRestorePointLock(false)"><i class="fas fa-unlock"></i> Unlock</button>
                    <button class="danger" onclick="applyRestorePoint()"><i class="fas fa-undo"></i> Restore Selected</button>
                </div>
                <div class="form-group">
                    <label>Available Restore Points</label>
                    <select id="restorePointSelect"></select>
                </div>
                <pre id="restorePreview" style="margin-top:10px; white-space:pre-wrap; background:rgba(2,6,23,0.55); border:1px solid rgba(148,163,184,0.2); border-radius:8px; padding:10px; font-size:12px; max-height:180px; overflow:auto;"></pre>
            </div>

            <!-- ── Device Monitoring Panel (Admin only) ─────────────────────── -->
            <div class="form-card" id="deviceMonitorCard" style="display:none">
                <h3><i class="fas fa-network-wired"></i> Connected Devices Log</h3>
                <p style="color:var(--text-muted);font-size:13px;margin-bottom:12px">
                    Every login from any device is recorded here with device name, OS, browser, IP and a persistent
                    <strong>Device UUID</strong> (browser-local ID).
                    <em>Note: Browser security prevents reading MAC addresses; the UUID uniquely identifies each browser instance instead.</em>
                </p>
                <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:14px;align-items:center">
                    <button class="secondary" onclick="loadDeviceLog()"><i class="fas fa-sync"></i> Refresh</button>
                    <button class="secondary" onclick="exportDeviceLog('csv')"><i class="fas fa-file-csv"></i> Export CSV</button>
                    <button class="secondary" onclick="exportDeviceLog('json')"><i class="fas fa-code"></i> Export JSON</button>
                    <button class="danger" onclick="clearDeviceLog()" style="margin-left:auto"><i class="fas fa-trash"></i> Clear Log</button>
                </div>
                <div style="display:flex;gap:12px;margin-bottom:14px;flex-wrap:wrap;align-items:center">
                    <input type="text" id="deviceLogFilter" placeholder="Search user, device, OS, IP…" oninput="filterDeviceLog()" style="flex:1;min-width:200px;max-width:320px">
                    <select id="deviceLogRoleFilter" onchange="filterDeviceLog()" style="min-width:130px">
                        <option value="">All Roles</option>
                        <option value="admin">Admin</option>
                        <option value="teacher">Teacher</option>
                        <option value="student">Student</option>
                    </select>
                </div>
                <!-- Summary stats -->
                <div id="deviceSummaryStats" style="display:flex;gap:10px;flex-wrap:wrap;margin-bottom:16px"></div>
                <!-- Unique devices table -->
                <h4 style="margin-bottom:8px;font-size:14px"><i class="fas fa-laptop"></i> Unique Devices (Last Seen)</h4>
                <div class="scoreboard-wrapper" style="margin-bottom:16px">
                    <div class="scoreboard-scroll">
                        <table class="scoreboard" id="deviceSummaryTable">
                            <thead>
                                <tr>
                                    <th>#</th>
                                    <th>Device Name</th>
                                    <th>OS</th>
                                    <th>Browser</th>
                                    <th>Screen</th>
                                    <th>Last User</th>
                                    <th>Role</th>
                                    <th>Last IP</th>
                                    <th>Last Seen</th>
                                    <th>Visits</th>
                                    <th>Device UUID</th>
                                </tr>
                            </thead>
                            <tbody id="deviceSummaryBody">
                                <tr><td colspan="11" class="text-center" style="padding:16px;color:var(--text-muted)">Click <strong>Refresh</strong> to load device data.</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <!-- Full connection log (collapsible) -->
                <details id="deviceFullLogDetails">
                    <summary style="cursor:pointer;font-weight:600;font-size:14px;padding:10px 0;border-top:1px solid var(--border);list-style:none;display:flex;align-items:center;gap:8px">
                        <i class="fas fa-list"></i> Full Connection Log
                        <span id="deviceFullLogCount" style="font-weight:400;font-size:12px;color:var(--text-muted)"></span>
                    </summary>
                    <div class="scoreboard-wrapper" style="margin-top:10px">
                        <div class="scoreboard-scroll">
                            <table class="scoreboard" id="deviceFullLogTable">
                                <thead>
                                    <tr>
                                        <th>#</th>
                                        <th>Timestamp (IST)</th>
                                        <th>User</th>
                                        <th>Role</th>
                                        <th>Event</th>
                                        <th>Device</th>
                                        <th>OS</th>
                                        <th>Browser</th>
                                        <th>Screen</th>
                                        <th>IP</th>
                                        <th style="min-width:260px">Device UUID</th>
                                    </tr>
                                </thead>
                                <tbody id="deviceFullLogBody">
                                    <tr><td colspan="11" class="text-center">—</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                </details>
            </div>
            <!-- ── End Device Monitoring Panel ──────────────────────────────── -->
        </div>
    </div>

    <!-- MODAL FOR DETAILS -->
    <div id="detailsModal" class="modal">
        <div class="modal-content">
                <div class="modal-header">
                    <h2>Student Details</h2>
                    <button class="close-btn" onclick="closeModal()">X</button>
                </div>
            <div id="modalBody"></div>
        </div>
    </div>

    <!-- MODAL: EDIT STUDENT -->
    <div id="editStudentModal" class="modal">
        <div class="modal-content">
                <div class="modal-header">
                    <h2>Edit Student</h2>
                    <button class="close-btn" onclick="closeModal('editStudentModal')">X</button>
                </div>
            <input type="hidden" id="editStudentId">
            <div class="form-grid">
                <div class="form-group">
                    <label>Roll Number *</label>
                    <input type="text" id="editRoll" required>
                </div>
                <div class="form-group">
                    <label>Full Name *</label>
                    <input type="text" id="editName" required>
                </div>
                <div class="form-group">
                    <label>Class *</label>
                    <input type="number" id="editClass" min="1" max="12" required>
                </div>
                <div class="form-group">
                    <label>Fees</label>
                    <input type="number" id="editFees" min="0">
                </div>
                <div class="form-group">
                    <label>Vote Power (Auto)</label>
                    <input type="number" id="editVotePower" readonly>
                </div>
                <div class="form-group">
                    <label>Stars</label>
                    <input type="number" id="editStars" min="0">
                </div>
                <div class="form-group">
                    <label>VETOs</label>
                    <input type="number" id="editVetos" min="0">
                </div>
                <div class="form-group">
                    <label>Active</label>
                    <select id="editActive">
                        <option value="true">Active</option>
                        <option value="false">Inactive</option>
                    </select>
                </div>
            </div>
            <h4 style="margin: 10px 0; color: var(--text-muted);">Profile Details</h4>
            <div class="form-grid">
                <div class="form-group">
                    <label>Father's Name</label>
                    <input type="text" id="editFatherName">
                </div>
                <div class="form-group">
                    <label>Mother's Name</label>
                    <input type="text" id="editMotherName">
                </div>
                <div class="form-group">
                    <label>Date of Birth</label>
                    <input type="date" id="editDob">
                </div>
                <div class="form-group">
                    <label>Blood Group</label>
                    <input type="text" id="editBloodGroup">
                </div>
                <div class="form-group">
                    <label>Aadhaar</label>
                    <input type="text" id="editAadhar">
                </div>
                <div class="form-group">
                    <label>Phone</label>
                    <input type="tel" id="editPhone">
                </div>
                <div class="form-group">
                    <label>Email</label>
                    <input type="email" id="editEmail">
                </div>
                <div class="form-group">
                    <label>Parent Phone</label>
                    <input type="tel" id="editParentPhone">
                </div>
                <div class="form-group">
                    <label>Admission Date</label>
                    <input type="date" id="editAdmissionDate">
                </div>
                <div class="form-group">
                    <label>Academic Year</label>
                    <input type="text" id="editAcademicYear" placeholder="2025-26">
                </div>
                <div class="form-group" style="grid-column: 1 / -1;">
                    <label>Address</label>
                    <textarea id="editAddress" rows="2"></textarea>
                </div>
            </div>
            <div class="form-buttons">
                <button class="secondary" onclick="closeModal('editStudentModal')">Cancel</button>
                <button onclick="saveStudentEdits()">Save Changes</button>
            </div>
        </div>
    </div>

    <!-- MODAL: GROUP VOTING BOOTH -->
    <div id="groupVoteDialog" class="validation-modal hidden">
        <div class="validation-modal-content group-vote-dialog">
            <div class="validation-modal-header">
                <h3 id="groupVoteDialogTitle">Cast Your Vote Now</h3>
            </div>
            <div class="validation-modal-body">
                <p id="groupVoteDialogMeta" style="margin-bottom: 14px;"></p>
                <div id="groupVoteCandidateCards" class="group-vote-cards"></div>
            </div>
            <div class="validation-modal-footer">
                <button class="secondary" onclick="submitGroupVoteChoice('abstain')">Abstain</button>
                <button class="secondary" onclick="submitGroupVoteChoice('nota')">NOTA</button>
                <button class="secondary" onclick="closeGroupVoteDialog()">Close</button>
            </div>
        </div>
    </div>

    <!-- MODAL: GROUP VOTE RESULT -->
    <div id="groupVoteResultModal" class="validation-modal hidden">
        <div class="validation-modal-content result-modal-content">
            <div class="validation-modal-header">
                <h3 id="groupVoteResultTitle">Voting Results</h3>
            </div>
            <div class="validation-modal-body result-modal-body">
                <div class="result-modal-banner" id="groupVoteResultBanner">Results</div>
                <p id="groupVoteResultMessage"></p>
            </div>
            <div class="validation-modal-footer">
                <button class="secondary" onclick="closeGroupVoteResultModal()">Close</button>
            </div>
            <div class="confetti" id="groupVoteResultConfetti" style="display:none;"></div>
            <div class="rain" id="groupVoteResultRain" style="display:none;"></div>
        </div>
    </div>

    <!-- JSON IMPORT INPUT -->
    <input type="file" id="jsonFile" accept=".json" style="display: none;">
    <input type="file" id="studentsExcelFile" accept=".xlsx,.xls,.xlsm" style="display: none;">
    <input type="file" id="activeRosterExcelFile" accept=".xlsx,.xls,.xlsm" style="display: none;">

    <script>
        // ============================================
        // EXCEL ACADEMY SCOREBOARD DATABASE MANAGER
        // ============================================

        const SERVER_SYNC = {
            enabled: window.location.protocol.startsWith('http'),
            dataUrl: '/scoreboard/offline-data',
            backupUrl: '/scoreboard/offline-backup'
        };
        const SERVER_URLS_KEY = 'ea_server_sync_urls';
        const DEFAULT_PRIMARY_SERVER_URL = 'http://192.168.0.183:5000';
        const DEFAULT_BACKUP_SERVER_URL = 'http://192.168.0.163:5000';
        const DEFAULT_RENDER_SERVER_URL = 'https://ea-tutorial-hub.onrender.com';
        // Guardrail: if a snapshot ever drops below this roster size, treat it as corrupt/stale.
        // This prevents the known "20 students" stale snapshot from being applied anywhere.
        const MIN_SAFE_STUDENT_ROSTER = 25;
        const DEFAULT_CR_GROUPS = ['A', 'B', 'C', 'D'];
        const DEFAULT_CR_COMBINED_POSTS = ['CR - Group A & B'];
        const LOCAL_BACKUP_KEY = 'ea_scoreboard_backups';
        const LOCAL_BACKUP_LIMIT = 1;
        const LOCAL_BACKUP_MAX_BYTES = 900000;
        const LOCAL_BACKUP_INTERVAL = 5 * 60 * 1000;
        // Poll fallback for environments where SSE is flaky; keep modest to avoid mobile UI jitter.
        const AUTO_SYNC_INTERVAL_MS = 12 * 1000;

        // ── Device fingerprinting ─────────────────────────────────────────────────────
        const DEVICE_UUID_KEY = 'ea_device_uuid';

        function getOrCreateDeviceUUID() {
            let id = localStorage.getItem(DEVICE_UUID_KEY);
            if (!id) {
                id = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                    const r = Math.random() * 16 | 0;
                    return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
                });
                localStorage.setItem(DEVICE_UUID_KEY, id);
            }
            return id;
        }

        function parseDeviceInfo() {
            const ua = navigator.userAgent;
            // OS
            let os = 'Unknown OS';
            if (/Windows NT 1[01]/.test(ua)) os = 'Windows 10/11';
            else if (/Windows NT 6\.3/.test(ua)) os = 'Windows 8.1';
            else if (/Windows NT 6\.1/.test(ua)) os = 'Windows 7';
            else if (/Android/.test(ua)) {
                const m = ua.match(/Android\s([\d.]+)/);
                os = m ? `Android ${m[1]}` : 'Android';
            }
            else if (/iPhone|iPad|iPod/.test(ua)) {
                const m = ua.match(/OS\s([\d_]+)/);
                os = m ? `iOS ${m[1].replace(/_/g, '.')}` : 'iOS';
            }
            else if (/Mac OS X/.test(ua)) os = 'macOS';
            else if (/Linux/.test(ua)) os = 'Linux';
            // Browser
            let browser = 'Unknown';
            if (/Edg\//.test(ua)) browser = 'Edge';
            else if (/OPR\//.test(ua)) browser = 'Opera';
            else if (/SamsungBrowser\//.test(ua)) browser = 'Samsung';
            else if (/Chrome\//.test(ua)) browser = 'Chrome';
            else if (/Firefox\//.test(ua)) browser = 'Firefox';
            else if (/Safari\//.test(ua)) browser = 'Safari';
            // Device name
            let deviceName = 'Unknown Device';
            if (/iPhone/.test(ua)) deviceName = 'iPhone';
            else if (/iPad/.test(ua)) deviceName = 'iPad';
            else if (/Android/.test(ua)) {
                const m = ua.match(/;\s*([^;()]+)\sBuild\//);
                deviceName = m ? m[1].trim() : 'Android Device';
            }
            else if (/Windows/.test(ua)) deviceName = 'Windows PC';
            else if (/Mac OS X/.test(ua)) deviceName = 'Mac';
            else if (/Linux/.test(ua)) deviceName = 'Linux PC';
            const screen = `${window.screen.width}×${window.screen.height}`;
            return { os, browser, screen, deviceName };
        }

        async function checkinDevice(event = 'login') {
            if (!SERVER_SYNC.enabled) return;
            try {
                const info = parseDeviceInfo();
                await fetch('/scoreboard/device-checkin', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({
                        device_id: getOrCreateDeviceUUID(),
                        device_name: info.deviceName,
                        os: info.os,
                        browser: info.browser,
                        screen: info.screen,
                        event: event
                    })
                });
            } catch (e) { /* non-critical — ignore */ }
        }
        // ── Undo stack ───────────────────────────────────────────────────────────────
        const _MAX_UNDO_STEPS = 15;        // max snapshots kept in memory
        let   _undoStack      = [];        // [{ label, snapshot, ts }, ...]
        // ── Write-ahead log ──────────────────────────────────────────────────────────
        const WAL_KEY = 'ea_sync_wal';     // localStorage key for the pending-sync WAL
        const LIVE_EDIT_GUARD_MS = 6000;
        const ENABLE_REALTIME_SYNC = true;
        const ACTIVE_TAB_KEY = 'ea_active_tab';
        const ACTIVE_SCOREBOARD_MONTH_KEY = 'ea_active_scoreboard_month';
        let lastLocalBackupAt = 0;
        let pendingSyncPayload = null;
        let syncTimer = null;
        let realtimeSyncSource = null;
        let realtimeReconnectTimer = null;
        let pullInFlightPromise = null;
        let pullQueuedToast = false;
        let pullQueuedForceFull = false;
        let pullDebounceTimer = null;
        let pullDebouncedToast = false;
        let pullDebouncedForceFull = false;
        let lastKnownRemoteStamp = 0;
        function isMobileViewport() {
            return window.innerWidth <= 980 || /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent || '');
        }
        let masterUpdateRunning = false;
        let forcePublishRunning = false;
        let adminAutoPublishAttempted = false;
        let pendingPushTimer = null;
        const AUTO_PUSH_DELAY_MS = 800;
        let rosterRecoveryInProgress = false;
        let rosterRecoveryQueuedTab = null;
        let rosterRecoveryLastAttemptAt = 0;
        let installPromptEvent = null;
        let currentUserRole = 'student';
        let currentLoginId = '';
        let currentStudentRoll = '';
        let currentStudentPositions = {};  // populated after session loads for students
        let isSelfProfileEditMode = false;
        let serverTimezone = 'Asia/Kolkata';
        const bulkAttendanceSelectionDates = {
            1: new Set(),
            2: new Set(),
            3: new Set()
        };
        let bulkAttendanceActiveSlot = 1;
        const recordScoreDraftState = {
            date: '',
            month: '',
            rows: {},
            lastEditAt: 0
        };
        const attendanceDraftState = {
            date: '',
            month: '',
            rows: {},
            lastEditAt: 0
        };
        let notificationCache = [];
        let lastNotificationArchiveDigest = '';
        let _notifFilter = 'all';
        let _notifSelectedIdx = -1;
        const SYLLABUS_SEED_VERSION = '2026-02-20.v1';
        const SYLLABUS_BOARDS = ['CBSE', 'ICSE', 'WBBSE'];
        const SYLLABUS_CLASSES = ['3', '4', '5', '6', '7', '8', '9', '10', '11', '12'];
        const SYLLABUS_INTERNET_SOURCES = [
            {
                board: 'CBSE',
                title: 'CBSE Academic Curriculum',
                url: 'https://cbseacademic.nic.in/curriculum_2025.html'
            },
            {
                board: 'CBSE',
                title: 'NCERT Textbooks (Chapter-wise references)',
                url: 'https://ncert.nic.in/textbook.php'
            },
            {
                board: 'ICSE',
                title: 'CISCE Regulations & Syllabus Portal',
                url: 'https://cisce.org/regulations-and-syllabuses-isc-2025/'
            },
            {
                board: 'ICSE',
                title: 'ICSE Chapter-wise reference set',
                url: 'https://www.knowledgeboat.com/learn/icse-class-10-maths'
            },
            {
                board: 'WBBSE',
                title: 'WBBSE/WBCHSE Syllabus & Textbook reference',
                url: 'https://wbbse.wb.gov.in/'
            },
            {
                board: 'WBBSE',
                title: 'WB board chapter references (class 10)',
                url: 'https://www.wbbsesolutions.com/wbbse-class-10-physical-science-solution/'
            }
        ];

        const SYLLABUS_SUBJECTS_BY_BOARD_STAGE = {
            CBSE: {
                primary: ['English', 'Mathematics', 'EVS', 'Hindi', 'Computer Studies', 'General Knowledge'],
                middle: ['English', 'Mathematics', 'Science', 'Social Science', 'Hindi', 'Computer Studies'],
                secondary: ['English', 'Mathematics', 'Science', 'Social Science', 'Hindi', 'Information Technology'],
                senior: ['English Core', 'Physics', 'Chemistry', 'Mathematics', 'Biology', 'Accountancy', 'Business Studies', 'Economics', 'History', 'Political Science', 'Geography', 'Computer Science']
            },
            ICSE: {
                primary: ['English Language', 'English Literature', 'Mathematics', 'Environmental Science', 'Second Language', 'Computer Studies', 'General Knowledge'],
                middle: ['English Language', 'English Literature', 'Mathematics', 'Physics', 'Chemistry', 'Biology', 'History & Civics', 'Geography', 'Second Language', 'Computer Applications'],
                secondary: ['English Language', 'English Literature', 'Mathematics', 'Physics', 'Chemistry', 'Biology', 'History & Civics', 'Geography', 'Second Language', 'Computer Applications'],
                senior: ['English', 'Physics', 'Chemistry', 'Mathematics', 'Biology', 'Accounts', 'Commerce', 'Economics', 'History', 'Political Science', 'Geography', 'Computer Science']
            },
            WBBSE: {
                primary: ['English', 'Mathematics', 'Environmental Studies', 'Bengali', 'Computer Studies', 'General Knowledge'],
                middle: ['English', 'Mathematics', 'Physical Science', 'Life Science', 'History', 'Geography', 'Bengali', 'Computer Applications'],
                secondary: ['English', 'Mathematics', 'Physical Science', 'Life Science', 'History', 'Geography', 'Bengali', 'Computer Applications'],
                senior: ['English', 'Bengali', 'Physics', 'Chemistry', 'Mathematics', 'Biology', 'Accountancy', 'Business Studies', 'Economics', 'History', 'Political Science', 'Geography', 'Computer Science']
            }
        };

        const SYLLABUS_TOPIC_TEMPLATES = {
            'English': {
                primary: ['Reading Comprehension', 'Grammar Basics', 'Vocabulary Building', 'Poetry Appreciation', 'Story Writing', 'Listening & Speaking'],
                middle: ['Reading Comprehension', 'Tenses & Clauses', 'Letter Writing', 'Essay Writing', 'Poetry', 'Drama/Prose'],
                secondary: ['Reading Skills', 'Writing Skills', 'Grammar in Context', 'Literature Prose', 'Poetry', 'Drama'],
                senior: ['Reading Comprehension', 'Creative Writing', 'Literature Prose', 'Poetry', 'Drama', 'Novel Studies']
            },
            'Mathematics': {
                primary: ['Numbers and Operations', 'Shapes and Patterns', 'Measurement', 'Time and Money', 'Data Handling', 'Problem Solving'],
                middle: ['Integers and Fractions', 'Algebraic Expressions', 'Ratio and Proportion', 'Geometry', 'Mensuration', 'Data Handling'],
                secondary: ['Number Systems', 'Algebra', 'Coordinate Geometry', 'Geometry', 'Trigonometry', 'Statistics & Probability'],
                senior: ['Sets and Functions', 'Algebra', 'Calculus', 'Vectors and 3D Geometry', 'Linear Programming', 'Probability']
            },
            'Science': {
                middle: ['Food and Nutrition', 'Materials', 'Motion and Force', 'Light and Sound', 'Life Processes', 'Environment'],
                secondary: ['Chemical Substances', 'Life Processes', 'Control & Coordination', 'Electricity', 'Magnetic Effects', 'Natural Resources']
            },
            'Social Science': {
                middle: ['History: Ancient to Medieval', 'Civics and Governance', 'Geography: Earth and Resources', 'Economics Basics', 'Map Work', 'Project Work'],
                secondary: ['History: Nationalism', 'Geography: Resources', 'Political Science', 'Economics: Development', 'Disaster Management', 'Map Skills']
            },
            'Physics': {
                middle: ['Force and Pressure', 'Light', 'Sound', 'Heat', 'Electricity and Magnetism', 'Energy'],
                secondary: ['Force & Laws of Motion', 'Work, Power & Energy', 'Light', 'Sound', 'Electricity', 'Modern Physics Basics'],
                senior: ['Units & Measurements', 'Mechanics', 'Thermodynamics', 'Waves', 'Electromagnetism', 'Optics', 'Modern Physics']
            },
            'Chemistry': {
                middle: ['Matter and Its Nature', 'Physical and Chemical Changes', 'Elements and Compounds', 'Metals and Non-metals', 'Acids, Bases and Salts', 'Air and Atmosphere'],
                secondary: ['Periodic Classification', 'Chemical Reactions', 'Acids, Bases and Salts', 'Metals and Non-metals', 'Carbon Compounds', 'Practical Chemistry'],
                senior: ['Physical Chemistry', 'Inorganic Chemistry', 'Organic Chemistry', 'Chemical Bonding', 'Electrochemistry', 'Biomolecules']
            },
            'Biology': {
                middle: ['Cell Structure', 'Plant and Animal Tissues', 'Nutrition in Organisms', 'Respiration', 'Reproduction Basics', 'Ecosystems'],
                secondary: ['Cell and Division', 'Life Processes', 'Heredity', 'Control & Coordination', 'Our Environment', 'Health and Diseases'],
                senior: ['Diversity of Living Organisms', 'Genetics', 'Human Physiology', 'Plant Physiology', 'Biotechnology', 'Ecology']
            },
            'History': {
                middle: ['Ancient Civilizations', 'Medieval World', 'Early Modern India', 'Colonial Rule', 'Freedom Movements', 'World Events'],
                secondary: ['Rise of Nationalism', 'Indian Freedom Struggle', 'Post-Independence India', 'World Wars', 'UN and Global Politics', 'Project Work'],
                senior: ['Historiography', 'Indian History Themes', 'World History Themes', 'Source-based Studies', 'Modern South Asia', 'Independent Research']
            },
            'Geography': {
                middle: ['Earth and Globe', 'Landforms', 'Climate', 'Natural Resources', 'Population', 'Map Skills'],
                secondary: ['Resources and Development', 'Agriculture', 'Industries', 'Transport and Communication', 'Disaster Management', 'Map Pointing'],
                senior: ['Physical Geography', 'Human Geography', 'India: Resources', 'Geospatial Skills', 'Field Survey', 'Regional Planning']
            },
            'Economics': {
                secondary: ['Development', 'Sectors of Economy', 'Money and Credit', 'Globalization', 'Consumer Rights', 'Project Work'],
                senior: ['Microeconomics', 'Macroeconomics', 'National Income', 'Government Budget', 'International Trade', 'Indian Economic Development']
            },
            'Computer Science': {
                primary: ['Computer Fundamentals', 'Input and Output Devices', 'Basic Operations', 'Typing and File Handling', 'Internet Basics', 'Digital Safety'],
                middle: ['Algorithms and Flowcharts', 'Programming Basics', 'Data Representation', 'Networking Basics', 'Spreadsheets', 'Presentations'],
                secondary: ['Programming Concepts', 'Data Structures Basics', 'Database Concepts', 'Web Technologies', 'Cyber Safety', 'Practical Assignments'],
                senior: ['Python/Java Programming', 'Data Structures', 'Database Management', 'Computer Networks', 'Boolean Algebra', 'Project']
            }
        };

        const SYLLABUS_CHAPTER_OVERRIDES = {
            CBSE: {
                '10': {
                    'Mathematics': [
                        'Real Numbers',
                        'Polynomials',
                        'Pair of Linear Equations in Two Variables',
                        'Quadratic Equations',
                        'Arithmetic Progressions',
                        'Triangles',
                        'Coordinate Geometry',
                        'Introduction to Trigonometry',
                        'Some Applications of Trigonometry',
                        'Circles',
                        'Areas Related to Circles',
                        'Surface Areas and Volumes',
                        'Statistics',
                        'Probability'
                    ],
                    'Science': [
                        'Chemical Reactions and Equations',
                        'Acids, Bases and Salts',
                        'Metals and Non-metals',
                        'Carbon and its Compounds',
                        'Life Processes',
                        'Control and Coordination',
                        'How do Organisms Reproduce?',
                        'Heredity and Evolution',
                        'Light - Reflection and Refraction',
                        'The Human Eye and the Colourful World',
                        'Electricity',
                        'Magnetic Effects of Electric Current',
                        'Our Environment',
                        'Sustainable Management of Natural Resources'
                    ]
                },
                '12': {
                    'Physics': [
                        'Electric Charges and Fields',
                        'Electrostatic Potential and Capacitance',
                        'Current Electricity',
                        'Moving Charges and Magnetism',
                        'Magnetism and Matter',
                        'Electromagnetic Induction',
                        'Alternating Current',
                        'Electromagnetic Waves',
                        'Ray Optics and Optical Instruments',
                        'Wave Optics',
                        'Dual Nature of Radiation and Matter',
                        'Atoms',
                        'Nuclei',
                        'Semiconductor Electronics'
                    ]
                }
            },
            ICSE: {
                '9': {
                    'Physics': [
                        'Measurements and Experimentation',
                        'Motion in One Dimension',
                        'Laws of Motion',
                        'Pressure in Fluids and Atmospheric Pressure',
                        'Upthrust in Fluids, Archimedes Principle and Floatation',
                        'Heat and Energy',
                        'Reflection of Light',
                        'Propagation of Sound Waves'
                    ]
                },
                '10': {
                    'Mathematics': [
                        'Goods and Services Tax',
                        'Banking',
                        'Shares and Dividends',
                        'Linear Inequations',
                        'Quadratic Equations',
                        'Ratio and Proportion',
                        'Matrices',
                        'Arithmetic Progression',
                        'Coordinate Geometry',
                        'Reflection',
                        'Section and Mid-point Formula',
                        'Equation of a Line',
                        'Similarity',
                        'Loci',
                        'Circles',
                        'Construction',
                        'Trigonometry',
                        'Heights and Distances',
                        'Mensuration',
                        'Probability',
                        'Statistics'
                    ]
                }
            },
            WBBSE: {
                '10': {
                    'Physical Science': [
                        'Physical and Chemical Classification of Matter',
                        'Behavior of Gases',
                        'Chemical Calculations',
                        'Periodic Table and Periodic Properties',
                        'Ionic and Covalent Bond',
                        'Acids, Bases and Salts',
                        'Metallurgy',
                        'Organic Chemistry',
                        'Environment and Pollution',
                        'Light',
                        'Force and Motion',
                        'Work, Power and Energy',
                        'Heat',
                        'Wave and Sound',
                        'Electricity and Magnetism',
                        'Atomic Nucleus'
                    ],
                    'Life Science': [
                        'Control and Coordination in Living Organisms',
                        'Continuity of Life',
                        'Heredity and Common Genetic Diseases',
                        'Evolution and Adaptation',
                        'Environment, Ecology and Ecosystem',
                        'Biodiversity and Conservation'
                    ]
                }
            }
        };

        function deepCloneJson(value) {
            return JSON.parse(JSON.stringify(value === undefined ? null : value));
        }

        function cloneSeed(value) {
            return deepCloneJson(value);
        }

        function getSyllabusStage(classLevel) {
            const n = parseInt(classLevel, 10) || 0;
            if (n >= 3 && n <= 5) return 'primary';
            if (n >= 6 && n <= 8) return 'middle';
            if (n >= 9 && n <= 10) return 'secondary';
            return 'senior';
        }

        function getSubjectTemplateKey(subjectName) {
            const text = String(subjectName || '').trim().toLowerCase();
            if (!text) return '';
            if (text.includes('english')) return 'English';
            if (text.includes('mathematics') || text === 'maths' || text === 'math') return 'Mathematics';
            if (text === 'science') return 'Science';
            if (text.includes('social')) return 'Social Science';
            if (text.includes('physics')) return 'Physics';
            if (text.includes('chemistry')) return 'Chemistry';
            if (text.includes('biology') || text.includes('life science')) return 'Biology';
            if (text.includes('history')) return 'History';
            if (text.includes('geography')) return 'Geography';
            if (text.includes('economics')) return 'Economics';
            if (text.includes('computer')) return 'Computer Science';
            return '';
        }

        function getDefaultTopicsForSubject(subjectName, stage) {
            const key = getSubjectTemplateKey(subjectName);
            const template = key ? SYLLABUS_TOPIC_TEMPLATES[key] : null;
            const topics = template && Array.isArray(template[stage]) ? template[stage] : null;
            if (topics && topics.length) return [...topics];
            return ['Unit 1', 'Unit 2', 'Unit 3', 'Unit 4', 'Unit 5', 'Unit 6'];
        }

        function buildInitialSyllabusCatalog() {
            const catalog = {
                seed_version: SYLLABUS_SEED_VERSION,
                sources: deepCloneJson(SYLLABUS_INTERNET_SOURCES),
                boards: {}
            };

            SYLLABUS_BOARDS.forEach(board => {
                const boardData = { classes: {} };
                SYLLABUS_CLASSES.forEach(classLevel => {
                    const stage = getSyllabusStage(classLevel);
                    const subjects = {};
                    const subjectList = (((SYLLABUS_SUBJECTS_BY_BOARD_STAGE[board] || {})[stage]) || []).slice();
                    subjectList.forEach(subjectName => {
                        subjects[String(subjectName)] = getDefaultTopicsForSubject(subjectName, stage);
                    });
                    boardData.classes[String(classLevel)] = { subjects };
                });
                catalog.boards[board] = boardData;
            });

            Object.entries(SYLLABUS_CHAPTER_OVERRIDES).forEach(([board, classMap]) => {
                Object.entries(classMap || {}).forEach(([classLevel, subjectMap]) => {
                    Object.entries(subjectMap || {}).forEach(([subjectName, chapters]) => {
                        if (!catalog.boards[board]) return;
                        if (!catalog.boards[board].classes[classLevel]) return;
                        catalog.boards[board].classes[classLevel].subjects[subjectName] = (Array.isArray(chapters) ? chapters : [])
                            .map(item => String(item || '').trim())
                            .filter(Boolean);
                    });
                });
            });
            return catalog;
        }

        function normalizeSyllabusCatalogShape(catalog) {
            const fallback = buildInitialSyllabusCatalog();
            if (!catalog || typeof catalog !== 'object') return fallback;
            const normalized = {
                seed_version: String(catalog.seed_version || fallback.seed_version),
                sources: Array.isArray(catalog.sources) ? catalog.sources : deepCloneJson(fallback.sources),
                boards: {}
            };
            SYLLABUS_BOARDS.forEach(board => {
                const srcBoard = catalog.boards && catalog.boards[board] ? catalog.boards[board] : {};
                const srcClasses = srcBoard.classes && typeof srcBoard.classes === 'object' ? srcBoard.classes : {};
                const nextBoard = { classes: {} };
                SYLLABUS_CLASSES.forEach(classLevel => {
                    const srcClass = srcClasses[classLevel] && typeof srcClasses[classLevel] === 'object'
                        ? srcClasses[classLevel]
                        : {};
                    const srcSubjects = srcClass.subjects && typeof srcClass.subjects === 'object'
                        ? srcClass.subjects
                        : {};
                    const nextSubjects = {};
                    Object.entries(srcSubjects).forEach(([subjectName, chapters]) => {
                        const cleanSubject = String(subjectName || '').trim();
                        if (!cleanSubject) return;
                        const nextChapters = (Array.isArray(chapters) ? chapters : [])
                            .map(ch => String(ch || '').trim())
                            .filter(Boolean);
                        if (nextChapters.length) nextSubjects[cleanSubject] = nextChapters;
                    });
                    if (!Object.keys(nextSubjects).length) {
                        const stage = getSyllabusStage(classLevel);
                        const defaults = (((SYLLABUS_SUBJECTS_BY_BOARD_STAGE[board] || {})[stage]) || []).slice();
                        defaults.forEach(subjectName => {
                            nextSubjects[subjectName] = getDefaultTopicsForSubject(subjectName, stage);
                        });
                    }
                    nextBoard.classes[classLevel] = { subjects: nextSubjects };
                });
                normalized.boards[board] = nextBoard;
            });
            return normalized;
        }

        function buildSyllabusTrackingKey(board, classLevel, subject, chapter) {
            return [
                String(board || '').trim().toUpperCase(),
                String(classLevel || '').trim(),
                String(subject || '').trim().toLowerCase(),
                String(chapter || '').trim().toLowerCase()
            ].join('||');
        }

        function normalizeSyllabusTrackingRows(rows) {
            const merged = new Map();
            (Array.isArray(rows) ? rows : []).forEach(item => {
                if (!item || typeof item !== 'object') return;
                const board = String(item.board || '').trim().toUpperCase();
                const classLevel = String(item.class_level || item.class || '').trim();
                const subject = String(item.subject || '').trim();
                const chapter = String(item.chapter || '').trim();
                if (!board || !classLevel || !subject || !chapter) return;
                const key = String(item.key || buildSyllabusTrackingKey(board, classLevel, subject, chapter));
                const conductedDates = Array.from(new Set((Array.isArray(item.conducted_dates) ? item.conducted_dates : [])
                    .map(v => String(v || '').trim())
                    .filter(v => /^\d{4}-\d{2}-\d{2}$/.test(v)))).sort();
                const sessionsByDate = new Map();
                (Array.isArray(item.sessions) ? item.sessions : []).forEach(sess => {
                    if (!sess || typeof sess !== 'object') return;
                    const date = String(sess.date || '').trim();
                    if (!/^\d{4}-\d{2}-\d{2}$/.test(date)) return;
                    const normalizedSession = {
                        date,
                        attended_student_ids: Array.from(new Set((Array.isArray(sess.attended_student_ids) ? sess.attended_student_ids : [])
                            .map(v => parseInt(v, 10))
                            .filter(v => Number.isFinite(v) && v > 0))),
                        attended_rolls: Array.from(new Set((Array.isArray(sess.attended_rolls) ? sess.attended_rolls : [])
                            .map(v => String(v || '').trim().toUpperCase())
                            .filter(Boolean))),
                        attended_names: Array.from(new Set((Array.isArray(sess.attended_names) ? sess.attended_names : [])
                            .map(v => String(v || '').trim())
                            .filter(Boolean))),
                        marked_by: String(sess.marked_by || '').trim(),
                        marked_at: String(sess.marked_at || '').trim()
                    };
                    const prev = sessionsByDate.get(date);
                    if (!prev) {
                        sessionsByDate.set(date, normalizedSession);
                        return;
                    }
                    const prevStamp = Date.parse(prev.marked_at || '') || 0;
                    const nextStamp = Date.parse(normalizedSession.marked_at || '') || 0;
                    sessionsByDate.set(date, nextStamp >= prevStamp ? normalizedSession : prev);
                });
                const normalized = {
                    id: parseInt(item.id, 10) || Date.now() + Math.floor(Math.random() * 1000),
                    key,
                    board,
                    class_level: classLevel,
                    subject,
                    chapter,
                    conducted_dates: conductedDates,
                    sessions: Array.from(sessionsByDate.values()).sort((a, b) => String(a.date).localeCompare(String(b.date))),
                    updated_at: String(item.updated_at || '').trim(),
                    created_at: String(item.created_at || '').trim()
                };
                const prev = merged.get(key);
                if (!prev) {
                    merged.set(key, normalized);
                    return;
                }
                const prevStamp = Date.parse(prev.updated_at || prev.created_at || '') || 0;
                const nextStamp = Date.parse(normalized.updated_at || normalized.created_at || '') || 0;
                const base = nextStamp >= prevStamp ? normalized : prev;
                const other = nextStamp >= prevStamp ? prev : normalized;
                const mergedDates = Array.from(new Set([...(base.conducted_dates || []), ...(other.conducted_dates || [])])).sort();
                const mergedSessionsByDate = new Map();
                [...(base.sessions || []), ...(other.sessions || [])].forEach(sess => {
                    const date = String(sess && sess.date || '').trim();
                    if (!date) return;
                    const prevSession = mergedSessionsByDate.get(date);
                    if (!prevSession) {
                        mergedSessionsByDate.set(date, sess);
                        return;
                    }
                    const p = Date.parse(prevSession.marked_at || '') || 0;
                    const n = Date.parse(sess.marked_at || '') || 0;
                    if (n >= p) mergedSessionsByDate.set(date, sess);
                });
                merged.set(key, {
                    ...base,
                    conducted_dates: mergedDates,
                    sessions: Array.from(mergedSessionsByDate.values()).sort((a, b) => String(a.date).localeCompare(String(b.date)))
                });
            });
            return Array.from(merged.values());
        }

        function mergeSyllabusCatalogSuperset(localCatalog, remoteCatalog) {
            const local = normalizeSyllabusCatalogShape(localCatalog);
            const remote = normalizeSyllabusCatalogShape(remoteCatalog);
            const merged = deepCloneJson(local);
            merged.seed_version = String(remote.seed_version || local.seed_version || SYLLABUS_SEED_VERSION);
            merged.sources = [];
            const sourceSeen = new Set();
            [...(local.sources || []), ...(remote.sources || [])].forEach(item => {
                try {
                    const key = JSON.stringify(item);
                    if (!key || sourceSeen.has(key)) return;
                    sourceSeen.add(key);
                    merged.sources.push(JSON.parse(key));
                } catch (err) {
                    // ignore malformed source rows
                }
            });
            SYLLABUS_BOARDS.forEach(board => {
                const localClasses = (((local.boards || {})[board] || {}).classes || {});
                const remoteClasses = (((remote.boards || {})[board] || {}).classes || {});
                const targetClasses = (((merged.boards || {})[board] || {}).classes || {});
                SYLLABUS_CLASSES.forEach(classLevel => {
                    const localSubjects = (((localClasses[classLevel] || {}).subjects) || {});
                    const remoteSubjects = (((remoteClasses[classLevel] || {}).subjects) || {});
                    const nextSubjects = {};
                    const subjectNames = Array.from(new Set([...Object.keys(localSubjects), ...Object.keys(remoteSubjects)]));
                    subjectNames.forEach(subjectName => {
                        const localChapters = Array.isArray(localSubjects[subjectName]) ? localSubjects[subjectName] : [];
                        const remoteChapters = Array.isArray(remoteSubjects[subjectName]) ? remoteSubjects[subjectName] : [];
                        const mergedChapters = Array.from(new Set([...localChapters, ...remoteChapters].map(ch => String(ch || '').trim()).filter(Boolean)));
                        if (mergedChapters.length) nextSubjects[subjectName] = mergedChapters;
                    });
                    targetClasses[classLevel] = { subjects: nextSubjects };
                });
                merged.boards[board].classes = targetClasses;
            });
            return merged;
        }

        function mergeSyllabusTrackingSuperset(localRows, remoteRows) {
            return normalizeSyllabusTrackingRows([...(Array.isArray(localRows) ? localRows : []), ...(Array.isArray(remoteRows) ? remoteRows : [])]);
        }

        function reclaimLocalStorageSpace() {
            let reclaimed = false;
            try {
                if (localStorage.getItem(LOCAL_BACKUP_KEY)) {
                    localStorage.removeItem(LOCAL_BACKUP_KEY);
                    reclaimed = true;
                }
            } catch (err) {
                // ignore storage access errors
            }
            return reclaimed;
        }

        function normalizeUserRole(roleValue) {
            const role = String(roleValue || '').trim().toLowerCase();
            if (role === 'admin' || role === 'teacher' || role === 'student') return role;
            return 'student';
        }

                const FEB26_SEED = null;

        let FEB26_SEED_CACHE = null;
        let FEB26_SEED_PROMISE = null;

        async function getFeb26Seed() {
            if (FEB26_SEED_CACHE) return FEB26_SEED_CACHE;
            if (!FEB26_SEED_PROMISE) {
                FEB26_SEED_PROMISE = fetch('/scoreboard/seed-data', { cache: 'force-cache', credentials: 'include' })
                    .then(resp => resp.ok ? resp.json() : Promise.reject(new Error('Failed to load seed data')))
                    .then(data => {
                        FEB26_SEED_CACHE = data || { students: [], scores: [], parties: [], leadership: [], month_students: {} };
                        return FEB26_SEED_CACHE;
                    })
                    .catch(() => ({ students: [], scores: [], parties: [], leadership: [], month_students: {} }));
            }
            return FEB26_SEED_PROMISE;
        }

        let XLSX_LOAD_PROMISE = null;
        async function ensureXlsxLoaded() {
            if (window.XLSX) return window.XLSX;
            if (!XLSX_LOAD_PROMISE) {
                XLSX_LOAD_PROMISE = new Promise((resolve, reject) => {
                    const script = document.createElement('script');
                    script.src = 'https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js';
                    script.async = true;
                    script.onload = () => resolve(window.XLSX);
                    script.onerror = () => reject(new Error('Failed to load Excel library'));
                    document.head.appendChild(script);
                });
            }
            return XLSX_LOAD_PROMISE;
        }

        const columnVisibility = {
            fees: false,
            awf: false
        };

        const FEB26_ROSTER_LOCK = [
            'EA24A01','EA24A03','EA24A04','EA24A05','EA24B01','EA24B03','EA24B09','EA24C02','EA24C03','EA24C06',
            'EA24D01','EA24D06','EA24D08','EA24D15','EA24D25','EA25A07','EA25A13','EA25A15','EA25B05','EA25B06',
            'EA25B10','EA25B13','EA25B14','EA25C07','EA25C09','EA25C10','EA25C11','EA25C12','EA25C15','EA25C17',
            'EA25C18','EA25C19','EA25C20','EA25C21','EA25C22','EA25C23','EA25D12','EA25D13','EA25D17','EA25D20',
            'EA25D21','EA25D22','EA25D24','EA25D26','EA26C24','EA26D28'
        ];

        const FEB26_STUDENT_ROSTER = [
            { roll: 'EA24A01', name: 'Ayush Gupta** (CR) (Vv)', class: 4 },
            { roll: 'EA24A03', name: 'Ayat Parveen', class: 4 },
            { roll: 'EA24A04', name: 'Tanu Sinha**', class: 4 },
            { roll: 'EA24A05', name: 'Rashi (v)', class: 3 },
            { roll: 'EA25A07', name: 'Vishes Xalxo***(v)', class: 3 },
            { roll: 'EA25A13', name: 'Afreen Khatun', class: 3 },
            { roll: 'EA25A15', name: 'Ansh Kumar Singh', class: 2 },
            { roll: 'EA24B01', name: 'Pari Gupta****** (v)', class: 6 },
            { roll: 'EA24B03', name: 'Deep Das*', class: 6 },
            { roll: 'EA24B09', name: 'Abdul Arman**** (ECS) (PP)', class: 5 },
            { roll: 'EA25B05', name: 'Rajveer Thakur', class: 6 },
            { roll: 'EA25B06', name: 'Jay Arya***', class: 5 },
            { roll: 'EA25B10', name: 'Shiva Mallick (v)', class: 5 },
            { roll: 'EA25B13', name: 'Rehmetun Khatun (ECJ)', class: 6 },
            { roll: 'EA25B14', name: 'Prem Oraon*****', class: 6 },
            { roll: 'EA24C02', name: 'Sahil Yadav****************** (vvv)', class: 8 },
            { roll: 'EA24C03', name: 'Abhik Mallik', class: 8 },
            { roll: 'EA24C06', name: 'Sakshi*** (v) (CCAI)', class: 8 },
            { roll: 'EA25C07', name: 'Khushi Paswan** (v)', class: 8 },
            { roll: 'EA25C09', name: 'Shomiya Xalxo*** (WCI) (PP)', class: 7 },
            { roll: 'EA25C10', name: 'Adarsh Arya*', class: 8 },
            { roll: 'EA25C11', name: 'Sourav Das*', class: 8 },
            { roll: 'EA25C12', name: 'Shubham Singha (PP)', class: 8 },
            { roll: 'EA25C15', name: 'Nirupam Vaid*', class: 8 },
            { roll: 'EA25C17', name: 'Alen Ghartimagar', class: 8 },
            { roll: 'EA25C18', name: 'N Riya Kumari', class: 8 },
            { roll: 'EA25C19', name: 'Samarth Patel*(CITC)', class: 8 },
            { roll: 'EA25C20', name: 'Rishi Trivedi', class: 8 },
            { roll: 'EA25C21', name: 'Sristi Kumari', class: 7 },
            { roll: 'EA25C22', name: 'Piyush Rajak', class: 8 },
            { roll: 'EA25C23', name: 'Abhinav Khati (CR) (PP)', class: 7 },
            { roll: 'EA26C24', name: 'Rishabh Kumar Singh', class: 7 },
            { roll: 'EA24D01', name: 'Jay Kumar Yadav*** (CR) (V)', class: 10 },
            { roll: 'EA24D06', name: 'Tanmay Biswas*', class: 10 },
            { roll: 'EA24D08', name: 'Sanjana Sutradhar (PP)', class: 9 },
            { roll: 'EA25D12', name: 'Roshan Paswan** (PP)', class: 10 },
            { roll: 'EA25D13', name: 'Aamna Khatoon*', class: 10 },
            { roll: 'EA24D15', name: 'Reeyansh Lama (VVvvv) (CoL) (SC)', class: 9 },
            { roll: 'EA25D17', name: 'Aditya Singh***', class: 10 },
            { roll: 'EA25D20', name: 'Harsh Mallik****** (VVV) (L)', class: 9 },
            { roll: 'EA25D21', name: 'Xavier Herenj***', class: 9 },
            { roll: 'EA25D22', name: 'Mahek Mahato*******', class: 9 },
            { roll: 'EA25D24', name: 'Aansh Mandal****** (DWI)', class: 10 },
            { roll: 'EA24D25', name: 'Nandani Gupta** (v)', class: 9 },
            { roll: 'EA25D26', name: 'Shankar Pradhan (CI)', class: 9 },
            { roll: 'EA26D28', name: 'Riya Singh (RM)', class: 9 }
        ];

        const PARTY_CODE_LABELS = {
            MAP: 'Members of Azzad Party',
            BWP: "Brilliant's Wonder Party",
            ESP: "Excel's Strength party",
            MRP: 'Master Republic Party',
            SSP: 'Senior Secondary Party',
            NJP: 'National Janata Party'
        };

        const ACTIVE_PARTY_CODES = ['MAP', 'BWP', 'ESP', 'MRP', 'SSP', 'NJP'];

        const ACTIVE_LEADERSHIP_POSTS = [
            'LEADER (L)',
            'LEADER OF OPPOSITION (LoP)',
            'CO-LEADER (CoL)',
            'CODING & IT CAPTAIN (CITC)',
            'DISCIPLINE & WELFARE IN-CHARGE (DWI)',
            'RESOURCE MANAGER (RM)',
            'SPORTS CAPTAIN (SC)',
            'ENGLISH CAPTAIN- SENIOR (ECS)',
            'CULTURE & CREATIVE ARTS IN-CHARGE (CCAI)',
            'CLEANLINESS IN-CHARGE (CI)',
            'ENGLISH CAPTAIN- JUNIOR (ECJ)',
            'WELCOME & COMMUNICATION IN-CHARGE (WCI)'
        ];

        function normalizePartyCode(rawCode) {
            const code = String(rawCode || '').trim().toUpperCase();
            if (PARTY_CODE_LABELS[code]) return code;
            const token = code.replace(/[^A-Z]/g, '').slice(0, 3);
            return PARTY_CODE_LABELS[token] ? token : '';
        }

        function ensurePartyCatalogData(data) {
            const existingByCode = new Map();
            (data.parties || []).forEach(party => {
                const code = normalizePartyCode(party.code);
                if (!code) return;
                if (!existingByCode.has(code)) {
                    existingByCode.set(code, party);
                    return;
                }
                // If duplicates exist, prefer the richer entry so members are not dropped.
                const prev = existingByCode.get(code) || {};
                const prevMembers = Array.isArray(prev.members) ? prev.members.length : 0;
                const nextMembers = Array.isArray(party.members) ? party.members.length : 0;
                if (nextMembers > prevMembers) {
                    existingByCode.set(code, party);
                }
            });
            data.parties = ACTIVE_PARTY_CODES.map((code, idx) => {
                const existing = existingByCode.get(code);
                return {
                    id: existing && existing.id ? existing.id : idx + 1,
                    code,
                    full_name: PARTY_CODE_LABELS[code],
                    members: Array.isArray(existing && existing.members) ? existing.members : []
                };
            });
        }

        function ensureLeadershipCatalogData(data) {
            const existingByPost = new Map();
            (data.leadership || []).forEach(post => {
                const key = String(post && post.post ? post.post : '').trim().toUpperCase();
                if (key && !existingByPost.has(key)) {
                    existingByPost.set(key, post);
                }
            });
            data.leadership = ACTIVE_LEADERSHIP_POSTS.map((postTitle, idx) => {
                const existing = existingByPost.get(postTitle.toUpperCase());
                return {
                    id: existing && existing.id ? existing.id : idx + 1,
                    post: postTitle,
                    holder: existing && existing.holder ? existing.holder : '',
                    roll: existing && existing.roll ? normalizeRoll(existing.roll) : '',
                    elected_on: existing && existing.elected_on ? existing.elected_on : ''
                };
            });
        }

        function deriveGroupFromRoll(roll) {
            if (!roll) return '';
            const match = roll.toString().trim().toUpperCase().match(/^EA\d{2}([A-Z])/);
            return match ? match[1] : '';
        }

        function getStudentGroup(student) {
            if (!student) return '';
            if (student.__month_group) return student.__month_group;
            return student.group || deriveGroupFromRoll(student.__month_roll || student.roll);
        }

        function getGroupSortRank(groupValue) {
            const group = String(groupValue || '').trim().toUpperCase();
            if (group === 'A') return 1;
            if (group === 'B') return 2;
            if (group === 'C') return 3;
            if (group === 'D') return 4;
            if (group === 'E') return 5;
            if (group === 'F') return 6;
            if (group === 'G') return 7;
            if (group === 'H') return 8;
            // For any other letter, use charCode offset from 'A'
            if (group.length === 1 && group >= 'A' && group <= 'Z') {
                return group.charCodeAt(0) - 'A'.charCodeAt(0) + 1;
            }
            return 99;
        }

        function compareStudentsByGroup(a, b) {
            const aGroup = getStudentGroup(a);
            const bGroup = getStudentGroup(b);
            const groupDiff = getGroupSortRank(aGroup) - getGroupSortRank(bGroup);
            if (groupDiff !== 0) return groupDiff;
            const aClass = parseInt(a.__month_class !== undefined ? a.__month_class : a.class, 10) || 0;
            const bClass = parseInt(b.__month_class !== undefined ? b.__month_class : b.class, 10) || 0;
            const classDiff = aClass - bClass;
            if (classDiff !== 0) return classDiff;
            const aName = String(a.__month_name || a.base_name || a.name || '');
            const bName = String(b.__month_name || b.base_name || b.name || '');
            return aName.localeCompare(bName);
        }

        function sortStudents(students) {
            return (Array.isArray(students) ? students.slice() : []).sort((a, b) => {
                const groupCompare = compareStudentsByGroup(a, b);
                if (groupCompare !== 0) return groupCompare;
                const aRoll = String((a && (a.__month_roll || a.roll)) || '');
                const bRoll = String((b && (b.__month_roll || b.roll)) || '');
                return aRoll.localeCompare(bRoll);
            });
        }

        function getStudentVotePower(student) {
            const total = student
                ? (student.computed_total_score !== undefined
                    ? parseInt(student.computed_total_score, 10)
                    : getStudentMonthTotal(student.id, getCurrentMonthKey()))
                : 0;
            return computeVotePower(total);
        }

        function computeVotePower(totalScore) {
            const total = Number.isFinite(Number(totalScore)) ? Number(totalScore) : 0;
            const computed = Math.floor(total / 20) + 1;
            return Math.max(-5, Math.min(25, computed));
        }

        function normalizeServerBaseUrl(url) {
            if (!url) return '';
            const trimmed = String(url).trim().replace(/\/+$/, '');
            if (!trimmed) return '';
            if (/^https?:\/\//i.test(trimmed)) return trimmed;
            return `http://${trimmed}`;
        }

        function getConfiguredServerUrls() {
            try {
                const raw = JSON.parse(localStorage.getItem(SERVER_URLS_KEY) || '[]');
                const values = Array.isArray(raw) ? raw : [];
                const normalized = values.map(normalizeServerBaseUrl).filter(Boolean);
                return Array.from(new Set(normalized));
            } catch (err) {
                return [];
            }
        }

        function setConfiguredServerUrls(urls) {
            const cleaned = Array.from(new Set((urls || []).map(normalizeServerBaseUrl).filter(Boolean)));
            localStorage.setItem(SERVER_URLS_KEY, JSON.stringify(cleaned));
            return cleaned;
        }

        function getDefaultServerUrls() {
            return Array.from(new Set([
                normalizeServerBaseUrl(DEFAULT_PRIMARY_SERVER_URL),
                normalizeServerBaseUrl(DEFAULT_BACKUP_SERVER_URL),
                normalizeServerBaseUrl(DEFAULT_RENDER_SERVER_URL)
            ].filter(Boolean)));
        }

        function ensureDefaultServerEndpoints() {
            const configured = getConfiguredServerUrls();
            const defaults = getDefaultServerUrls();
            if (!defaults.length) return configured;
            // Keep the default ordering (Primary then Backup) at the front so the master server
            // remains the canonical sync target even on backup devices.
            const merged = Array.from(new Set([...defaults, ...configured].filter(Boolean)));
            const changed = merged.length !== configured.length || merged.some((url, idx) => configured[idx] !== url);
            if (changed) {
                return setConfiguredServerUrls(merged);
            }
            return merged;
        }

        function getPeerBaseUrls() {
            const configured = ensureDefaultServerEndpoints();
            return configured.length ? configured : getDefaultServerUrls();
        }

        function getSyncBaseUrls() {
            const configured = ensureDefaultServerEndpoints();
            const currentOrigin = normalizeServerBaseUrl(window.location.origin);
            const list = configured.length ? configured : getDefaultServerUrls();
            if (currentOrigin && !list.includes(currentOrigin)) {
                list.unshift(currentOrigin);
            }
            return Array.from(new Set(list.filter(Boolean)));
        }

        async function fetchWithTimeout(url, options = {}, timeoutMs = 5000) {
            const controller = new AbortController();
            const timer = setTimeout(() => controller.abort(), timeoutMs);
            try {
                const response = await fetch(url, { ...options, signal: controller.signal });
                return response;
            } finally {
                clearTimeout(timer);
            }
        }

        async function refreshServerHealth() {
            const body = document.getElementById('serverHealthBody');
            if (!body) return;
            const urls = getSyncBaseUrls();
            if (!urls.length) {
                body.innerHTML = '<tr><td colspan="5" style="text-align:center; color:var(--text-muted);">No server URLs configured.</td></tr>';
                return;
            }
            let rows = [];
            try {
                const resp = await fetch('/scoreboard/offline-server-health', {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ urls })
                });
                const payload = await resp.json();
                if (!resp.ok || !payload.success) {
                    throw new Error(payload.error || 'Health check failed');
                }
                rows = (payload.items || []).map(item => ({
                    baseUrl: item.base_url,
                    status: item.status || 'offline',
                    stamp: item.data_stamp || '-',
                    students: item.students == null ? '-' : item.students,
                    scores: item.scores == null ? '-' : item.scores,
                    error: item.error || ''
                }));
            } catch (err) {
                body.innerHTML = `<tr><td colspan="5" style="text-align:center; color:#f87171;">Health check failed: ${escapeHtml(err.message || 'Unknown error')}</td></tr>`;
                return;
            }

            body.innerHTML = rows.map(r => {
                const statusText = String(r.status || '').toLowerCase();
                const isOnline = statusText === 'online';
                const isDegraded = statusText === 'degraded';
                const statusColor = isOnline ? '#34d399' : (isDegraded ? '#fbbf24' : '#f87171');
                return `
                    <tr>
                        <td>${escapeHtml(r.baseUrl)}</td>
                        <td style="color:${statusColor}; font-weight:700;">${escapeHtml(String(r.status))}</td>
                        <td>${escapeHtml(String(r.stamp || '-'))}</td>
                        <td>${escapeHtml(String(r.students))}</td>
                        <td title="${escapeHtml(String(r.error || ''))}">${escapeHtml(String(r.scores))}</td>
                    </tr>
                `;
            }).join('');
        }

        function saveServerEndpoints() {
            const primary = normalizeServerBaseUrl(getElementValue('primaryServerUrl') || '');
            const backup = normalizeServerBaseUrl(getElementValue('backupServerUrl') || '');
            const urls = setConfiguredServerUrls([primary, backup]);
            showAlert(urls.length ? 'Server endpoints saved' : 'Server endpoints cleared', 'success');
            refreshServerHealth();
        }

        function populateServerEndpointInputs() {
            const configured = ensureDefaultServerEndpoints();
            const defaults = getDefaultServerUrls();
            const urls = Array.from(new Set([...defaults, ...configured].filter(Boolean)));
            const primaryInput = document.getElementById('primaryServerUrl');
            const backupInput = document.getElementById('backupServerUrl');
            if (primaryInput) primaryInput.value = urls[0] || '';
            if (backupInput) backupInput.value = urls[1] || '';
        }

        function safeProp(obj, key) {
            return obj == null ? undefined : obj[key];
        }

        function coalesce(value, fallback) {
            return value == null ? fallback : value;
        }

        function getElementValue(id) {
            const el = document.getElementById(id);
            return el ? el.value : '';
        }

        function setElementValue(id, value) {
            const el = document.getElementById(id);
            if (!el) return;
            el.value = value == null ? '' : value;
        }

        function getElementFile(id) {
            const el = document.getElementById(id);
            return el && el.files && el.files.length ? el.files[0] : null;
        }

        function normalizeText(value) {
            return String(value || '').trim().toLowerCase().replace(/\s+/g, ' ');
        }

        function normalizeStudentNameKey(value) {
            const raw = String(value || '').trim();
            if (!raw) return '';
            const parsed = extractNameMeta(raw);
            const cleaned = stripPostHolderSuffixes(parsed.baseName || raw)
                .replace(/\s{2,}/g, ' ')
                .trim();
            return normalizeText(cleaned);
        }

        function normalizeRoll(value) {
            return String(value || '').trim().toUpperCase();
        }

        function normalizeAttendanceRoll(value) {
            return normalizeRoll(value).replace(/[^A-Z0-9]/g, '');
        }

        function findStudentByRoll(rollValue) {
            const roll = normalizeRoll(rollValue);
            if (!roll) return null;
            return db.getStudents().find(student => normalizeRoll(student.roll) === roll) || null;
        }

        function findStudentByName(nameValue) {
            const target = normalizeStudentNameKey(nameValue);
            if (!target) return null;
            return db.getStudents().find(student => {
                const base = normalizeStudentNameKey(student.base_name || student.name);
                const raw = normalizeStudentNameKey(student.name || student.base_name);
                return base === target || raw === target;
            }) || null;
        }

        function getStudentProfileHint(student) {
            if (!student) return '';
            const group = getStudentGroup(student) || '-';
            const stars = Math.max(0, parseInt(student.stars, 10) || 0);
            const vetos = Math.max(0, parseInt(student.veto_count, 10) || 0);
            return `Class ${student.class || '-'} | Group ${group} | *${stars} | V${vetos}`;
        }

        function resolveLeadershipStudent(post) {
            if (!post) return null;
            if (post.roll) {
                const byRoll = findStudentByRoll(post.roll);
                if (byRoll) return byRoll;
            }
            if (post.holder) {
                const byName = findStudentByName(post.holder);
                if (byName) return byName;
            }
            return null;
        }

        function handleLeadershipRollInput() {
            const rollInput = document.getElementById('leadershipRoll');
            const holderInput = document.getElementById('leadershipHolder');
            const detail = document.getElementById('leadershipAutoDetails');
            if (!rollInput || !holderInput || !detail) return;
            rollInput.value = normalizeRoll(rollInput.value);
            const student = findStudentByRoll(rollInput.value);
            if (!student) {
                detail.textContent = rollInput.value.trim()
                    ? 'Roll not found in students data.'
                    : 'Enter roll number to auto-fill holder details.';
                return;
            }
            holderInput.value = student.base_name || student.name || '';
            detail.textContent = `${formatRollDisplay(student.roll)} | ${getStudentProfileHint(student)}`;
        }

        function getHistoryTrackingStartDate() {
            const monthKey = getCurrentMonthKey();
            return `${monthKey}-01`;
        }

        const suspendedPostHolderCache = { key: '', ids: new Set() };
        const votePowerSuspendedPostHolderCache = { key: '', ids: new Set() };
        const roleDisplayCache = { key: '', ctx: null };

        function buildVotePowerSuspendedPostHolderIdSet(checkDate = '') {
            const dateKey = String(checkDate || formatDateKey(new Date())).trim();
            const monthKey = /^\d{4}-\d{2}-\d{2}$/.test(dateKey) ? dateKey.substring(0, 7) : getCurrentMonthKey();
            if (monthKey !== getCurrentMonthKey()) {
                return new Set();
            }
            const data = db.getData();
            const cacheKey = `${dateKey}::${String(data.updated_at || '')}`;
            if (votePowerSuspendedPostHolderCache.key === cacheKey) {
                return votePowerSuspendedPostHolderCache.ids;
            }

            const students = data.students || [];
            const studentsById = new Map(students.map(s => [parseInt(s.id, 10), s]));
            const rollToId = new Map(students.map(s => [normalizeRoll(s.roll), parseInt(s.id, 10)]));
            const activeHolderIds = new Set();
            const addActiveHolder = (studentId) => {
                const sid = parseInt(studentId, 10);
                if (!sid || !studentsById.has(sid)) return;
                activeHolderIds.add(sid);
            };

            (data.leadership || []).forEach(post => {
                const tenureMonths = getTenureMonthsForAssignment('leadership', post.post);
                const ext = parseInt(post.tenure_extension_months, 10) || 0;
                if (!isAssignmentEffectivelyActive(post.status, post.elected_on, tenureMonths, ext, dateKey)) return;
                const resolved = resolveLeadershipStudent(post);
                if (!resolved || !resolved.id) return;
                addActiveHolder(resolved.id);
            });

            (data.class_reps || []).forEach(rep => {
                const tenureMonths = getTenureMonthsForAssignment('class_rep', rep.post || 'CR');
                const ext = parseInt(rep.tenure_extension_months, 10) || 0;
                if (!isAssignmentEffectivelyActive(rep.status, rep.elected_on, tenureMonths, ext, dateKey)) return;
                addActiveHolder(rep.studentId);
            });

            (data.group_crs || []).forEach(rep => {
                const tenureMonths = getTenureMonthsForAssignment('group_cr', rep.post || 'CR');
                const ext = parseInt(rep.tenure_extension_months, 10) || 0;
                if (!isAssignmentEffectivelyActive(rep.status || 'active', rep.elected_on, tenureMonths, ext, dateKey)) return;
                addActiveHolder(rep.studentId);
            });

            (data.parties || []).forEach(party => {
                (party.members || []).forEach(member => {
                    if (!isPartyPresidentDesignation(member.designation)) return;
                    const tenureMonths = getTenureMonthsForAssignment('party_president', member.designation || 'Party President');
                    const ext = parseInt(member.tenure_extension_months, 10) || 0;
                    const statusInfo = getPostHolderStatusInfo(member.status, member.elected_on, tenureMonths, ext);
                    if (statusInfo.key !== 'active') return;
                    let sid = parseInt(member.studentId, 10);
                    if (!sid || !studentsById.has(sid)) {
                        const byRoll = rollToId.get(normalizeRoll(member.roll || ''));
                        sid = byRoll ? parseInt(byRoll, 10) : 0;
                    }
                    addActiveHolder(sid);
                });
            });

            const votePowerSuspendedIds = new Set();
            activeHolderIds.forEach(sid => {
                const votePower = computeVotePower(getStudentMonthTotal(sid, monthKey));
                if (votePower < 0) votePowerSuspendedIds.add(sid);
            });

            votePowerSuspendedPostHolderCache.key = cacheKey;
            votePowerSuspendedPostHolderCache.ids = votePowerSuspendedIds;
            return votePowerSuspendedIds;
        }

        function isPostHolderVotePowerSuspended(studentId, checkDate = '') {
            const sid = parseInt(studentId, 10);
            if (!sid) return false;
            const dateKey = String(checkDate || formatDateKey(new Date())).trim();
            const ids = buildVotePowerSuspendedPostHolderIdSet(dateKey);
            return ids.has(sid);
        }

        function getEffectivePostHolderStatus(statusValue, studentId = 0, checkDate = '') {
            const normalized = normalizePostHolderStatus(statusValue || 'active');
            if (normalized !== 'active') return normalized;
            const sid = parseInt(studentId, 10);
            if (!sid) return normalized;
            return isPostHolderVotePowerSuspended(sid, checkDate) ? 'suspended' : normalized;
        }

        function buildSuspendedPostHolderIdSet(checkDate = '') {
            const dateKey = String(checkDate || formatDateKey(new Date())).trim();
            const data = db.getData();
            const cacheKey = `${dateKey}::${String(data.updated_at || '')}`;
            if (suspendedPostHolderCache.key === cacheKey) {
                return suspendedPostHolderCache.ids;
            }

            const students = data.students || [];
            const studentById = new Map(students.map(s => [parseInt(s.id, 10), s]));
            const rollToId = new Map(students.map(s => [normalizeRoll(s.roll), parseInt(s.id, 10)]));
            const nameToIds = new Map();
            students.forEach(s => {
                const k = normalizeText(s.base_name || s.name);
                if (!k) return;
                if (!nameToIds.has(k)) nameToIds.set(k, []);
                nameToIds.get(k).push(parseInt(s.id, 10));
            });

            const suspendedIds = new Set();
            const addId = (id) => {
                const sid = parseInt(id, 10);
                if (sid) suspendedIds.add(sid);
            };

            (data.class_reps || []).forEach(rep => {
                if (normalizePostHolderStatus(rep.status) !== 'suspended') return;
                addId(rep.studentId);
            });

            (data.group_crs || []).forEach(rep => {
                if (normalizePostHolderStatus(rep.status) !== 'suspended') return;
                addId(rep.studentId);
            });

            (data.leadership || []).forEach(post => {
                if (normalizePostHolderStatus(post.status) !== 'suspended') return;
                const postRoll = normalizeRoll(post.roll);
                const byRoll = postRoll ? rollToId.get(postRoll) : null;
                if (byRoll) {
                    suspendedIds.add(byRoll);
                    return;
                }
                const matched = nameToIds.get(normalizeText(post.holder)) || [];
                matched.forEach(id => suspendedIds.add(id));
            });

            (data.parties || []).forEach(party => {
                (party.members || []).forEach(member => {
                    const designation = normalizeText(member.designation || '');
                    if (!(designation === 'party president' || designation === 'pp')) return;
                    if (normalizePostHolderStatus(member.status) !== 'suspended') return;
                    if (member.studentId && studentById.has(parseInt(member.studentId, 10))) {
                        suspendedIds.add(parseInt(member.studentId, 10));
                        return;
                    }
                    const roll = normalizeRoll(member.roll);
                    const sid = roll ? rollToId.get(roll) : null;
                    if (sid) suspendedIds.add(sid);
                });
            });

            // Safety net: if history records show an open suspended assignment,
            // keep that student blocked from visual effects/suffixes everywhere.
            (data.post_holder_history || []).forEach(record => {
                if (!record || String(record.end_date || '').trim()) return;
                if (normalizePostHolderStatus(record.status) !== 'suspended') return;
                const sid = parseInt(record.studentId, 10);
                if (sid) {
                    suspendedIds.add(sid);
                    return;
                }
                const roll = normalizeRoll(record.roll || '');
                const byRoll = roll ? rollToId.get(roll) : null;
                if (byRoll) {
                    suspendedIds.add(byRoll);
                    return;
                }
                const byName = nameToIds.get(normalizeText(record.holder_name || '')) || [];
                byName.forEach(id => suspendedIds.add(id));
            });

            const votePowerSuspended = buildVotePowerSuspendedPostHolderIdSet(dateKey);
            votePowerSuspended.forEach(id => suspendedIds.add(id));

            suspendedPostHolderCache.key = cacheKey;
            suspendedPostHolderCache.ids = suspendedIds;
            return suspendedIds;
        }

        function isStudentPostHolderSuspended(student, dateKey = '') {
            if (!student || !student.id) return false;
            const ids = buildSuspendedPostHolderIdSet(dateKey);
            return ids.has(parseInt(student.id, 10));
        }

        function isStudentPostHolderSuspendedById(studentId, dateKey = '') {
            const id = parseInt(studentId, 10);
            if (!id) return false;
            const student = (db.getStudents() || []).find(item => item.id === id);
            return student ? isStudentPostHolderSuspended(student, dateKey) : false;
        }

        function buildRoleDisplayContext(checkDate = '') {
            const dateKey = String(checkDate || formatDateKey(new Date())).trim();
            const data = db.getData();
            const cacheKey = `${dateKey}::${String(data.updated_at || '')}`;
            if (roleDisplayCache.key === cacheKey && roleDisplayCache.ctx) {
                return roleDisplayCache.ctx;
            }

            const students = data.students || [];
            const studentsById = new Map(students.map(s => [parseInt(s.id, 10), s]));
            const suffixesById = new Map();
            const designationsById = new Map();
            const officeHolderIds = new Set();
            const suspendedIds = buildSuspendedPostHolderIdSet(dateKey);

            const addSuffix = (studentId, suffix) => {
                const sid = parseInt(studentId, 10);
                const label = String(suffix || '').trim();
                if (!sid || !label || suspendedIds.has(sid)) return;
                if (!suffixesById.has(sid)) suffixesById.set(sid, new Set());
                suffixesById.get(sid).add(label);
            };
            const addDesignation = (studentId, designation) => {
                const sid = parseInt(studentId, 10);
                const label = String(designation || '').trim();
                if (!sid || !label || suspendedIds.has(sid)) return;
                if (!designationsById.has(sid)) designationsById.set(sid, new Set());
                designationsById.get(sid).add(label);
            };
            const markOfficeHolder = (studentId) => {
                const sid = parseInt(studentId, 10);
                if (!sid || suspendedIds.has(sid)) return;
                officeHolderIds.add(sid);
            };

            (data.leadership || []).forEach(post => {
                const tenureMonths = getTenureMonthsForAssignment('leadership', post.post);
                const ext = parseInt(post.tenure_extension_months, 10) || 0;
                if (!isAssignmentEffectivelyActive(post.status, post.elected_on, tenureMonths, ext, dateKey)) return;
                const resolved = resolveLeadershipStudent(post);
                if (!resolved || !resolved.id) return;
                const sid = parseInt(resolved.id, 10);
                const suffix = getLeadershipSuffix(post.post);
                if (suffix) addSuffix(sid, suffix);
                markOfficeHolder(sid);
            });

            (data.class_reps || []).forEach(rep => {
                const tenureMonths = getTenureMonthsForAssignment('class_rep', rep.post || 'CR');
                const ext = parseInt(rep.tenure_extension_months, 10) || 0;
                if (!isAssignmentEffectivelyActive(rep.status, rep.elected_on, tenureMonths, ext, dateKey)) return;
                const sid = parseInt(rep.studentId, 10);
                if (!sid || !studentsById.has(sid)) return;
                addSuffix(sid, 'CR');
                addDesignation(sid, 'CR');
                markOfficeHolder(sid);
            });

            (data.group_crs || []).forEach(rep => {
                const tenureMonths = getTenureMonthsForAssignment('group_cr', rep.post || 'CR');
                const ext = parseInt(rep.tenure_extension_months, 10) || 0;
                if (!isAssignmentEffectivelyActive(rep.status || 'active', rep.elected_on, tenureMonths, ext, dateKey)) return;
                const sid = parseInt(rep.studentId, 10);
                if (!sid || !studentsById.has(sid)) return;
                addSuffix(sid, 'CR');
                addDesignation(sid, 'CR');
                markOfficeHolder(sid);
            });

            (data.parties || []).forEach(party => {
                (party.members || []).forEach(member => {
                    const tenureMonths = getTenureMonthsForAssignment('party_president', member.designation || 'Party President');
                    const ext = parseInt(member.tenure_extension_months, 10) || 0;
                    // Party Presidents: keep suffix + office-holder visuals as long as they are not suspended/vacant.
                    // Do not auto-expire visuals by tenure, because the system may keep them "active" beyond nominal tenure.
                    const statusInfo = getPostHolderStatusInfo(member.status, member.elected_on, tenureMonths, ext);
                    if (statusInfo.key !== 'active') return;
                    if (!isPartyPresidentDesignation(member.designation)) return;
                    let sid = parseInt(member.studentId, 10);
                    if (!sid || !studentsById.has(sid)) {
                        const roll = normalizeRoll(member.roll);
                        const found = students.find(s => normalizeRoll(s.roll) === roll);
                        sid = found ? parseInt(found.id, 10) : 0;
                    }
                    if (!sid) return;
                    addSuffix(sid, 'PP');
                    addDesignation(sid, 'PP');
                    markOfficeHolder(sid);
                });
            });

            const ctx = { dateKey, suffixesById, designationsById, officeHolderIds, suspendedIds };
            roleDisplayCache.key = cacheKey;
            roleDisplayCache.ctx = ctx;
            return ctx;
        }

        function isOfficeHolderStudent(student, month = '') {
            if (!student || !student.id) return false;
            const monthKey = String(month || '').trim();
            if (monthKey && monthKey !== getCurrentMonthKey()) {
                return false;
            }
            const dateKey = monthKey ? `${monthKey}-15` : formatDateKey(new Date());
            const ctx = buildRoleDisplayContext(dateKey);
            return ctx.officeHolderIds.has(parseInt(student.id, 10));
        }

        function buildCurrentPostHolderAssignments(dataRef = null) {
            const data = dataRef || db.getData();
            const studentMap = new Map((data.students || []).map(student => [student.id, student]));
            const assignments = [];

            (data.leadership || []).forEach(post => {
                const resolved = resolveLeadershipStudent(post);
                const studentId = resolved ? resolved.id : null;
                const roll = resolved ? (resolved.roll || '') : (post.roll || '');
                const holderName = resolved ? (resolved.base_name || resolved.name || '') : String(post.holder || '').trim();
                if (!holderName && !roll) return;
                const isVacant = !resolved && !String(post.holder || '').trim() && !String(post.roll || '').trim();
                assignments.push({
                    assignment_key: `leadership:${String(post.post || '').trim().toLowerCase()}`,
                    source: 'leadership',
                    post: String(post.post || '').trim() || 'Leadership Post',
                    studentId: studentId || null,
                    roll: normalizeRoll(roll),
                    holder_name: holderName,
                    start_date: post.elected_on || '',
                    status: isVacant ? 'vacant' : normalizePostHolderStatus(post.status)
                });
            });

            (data.group_crs || []).forEach(rep => {
                const student = studentMap.get(rep.studentId);
                if (!student) return;
                assignments.push({
                    assignment_key: `group_cr:${String(rep.group || '').trim().toUpperCase()}`,
                    source: 'group_cr',
                    post: `Group CR (Group ${rep.group || '-'})`,
                    studentId: student.id,
                    roll: normalizeRoll(student.roll),
                    holder_name: student.base_name || student.name || '',
                    start_date: rep.elected_on || '',
                    status: normalizePostHolderStatus(rep.status)
                });
            });

            (data.class_reps || []).forEach(rep => {
                const student = studentMap.get(rep.studentId);
                if (!student) return;
                assignments.push({
                    assignment_key: `class_rep:${String(rep.class || '').trim()}`,
                    source: 'class_rep',
                    post: `Class Representative (Class ${rep.class})`,
                    studentId: student.id,
                    roll: normalizeRoll(student.roll),
                    holder_name: student.base_name || student.name || '',
                    start_date: rep.elected_on || '',
                    status: normalizePostHolderStatus(rep.status)
                });
            });

            (data.parties || []).forEach(party => {
                const member = (party.members || []).find(item => isPartyPresidentDesignation(item.designation));
                if (!member) return;
                const student = studentMap.get(member.studentId);
                const holderName = student ? (student.base_name || student.name || '') : '';
                const roll = student ? normalizeRoll(student.roll) : '';
                assignments.push({
                    assignment_key: `party_president:${normalizePartyCode(party.code) || String(party.code || '').trim().toLowerCase()}`,
                    source: 'party_president',
                    post: `Party President (${normalizePartyCode(party.code) || String(party.code || '').toUpperCase()})`,
                    studentId: student ? student.id : null,
                    roll,
                    holder_name: holderName,
                    start_date: member.elected_on || '',
                    status: normalizePostHolderStatus(member.status)
                });
            });

            return assignments.filter(item => item.status !== 'vacant');
        }

        function syncPostHolderHistory(options = {}) {
            const data = db.getData();
            data.post_holder_history = Array.isArray(data.post_holder_history) ? data.post_holder_history : [];
            const nowIso = new Date().toISOString();
            const today = nowIso.split('T')[0];
            const trackingStart = getHistoryTrackingStartDate();
            const assignments = buildCurrentPostHolderAssignments(data);
            const assignmentMap = new Map(assignments.map(item => [item.assignment_key, item]));
            let changed = false;

            const ensureStartDate = (rawDate) => {
                const value = String(rawDate || '').trim();
                if (!value) return trackingStart;
                if (value < trackingStart) return trackingStart;
                return value;
            };

            data.post_holder_history.forEach(record => {
                if (!record || record.end_date) return;
                const assignment = assignmentMap.get(record.assignment_key);
                if (!assignment) {
                    record.end_date = today;
                    record.status = 'ended';
                    record.updated_at = nowIso;
                    changed = true;
                    return;
                }
                const sameStudent = (record.studentId && assignment.studentId && record.studentId === assignment.studentId)
                    || (!record.studentId && !assignment.studentId && normalizeRoll(record.roll) === normalizeRoll(assignment.roll));
                if (!sameStudent) {
                    record.end_date = today;
                    record.status = 'ended';
                    record.updated_at = nowIso;
                    changed = true;
                }
            });

            let nextId = data.post_holder_history.reduce((max, item) => Math.max(max, parseInt(item.id, 10) || 0), 0);
            assignments.forEach(assignment => {
                const openRecord = data.post_holder_history.find(record =>
                    record.assignment_key === assignment.assignment_key &&
                    !record.end_date &&
                    ((record.studentId && assignment.studentId && record.studentId === assignment.studentId)
                        || normalizeRoll(record.roll) === normalizeRoll(assignment.roll))
                );
                if (openRecord) {
                    const nextPost = assignment.post || openRecord.post || '';
                    const nextRoll = normalizeRoll(assignment.roll || openRecord.roll || '');
                    const nextName = assignment.holder_name || openRecord.holder_name || '';
                    const nextStatus = normalizePostHolderStatus(assignment.status);
                    if (openRecord.post !== nextPost || openRecord.roll !== nextRoll || openRecord.holder_name !== nextName || normalizePostHolderStatus(openRecord.status) !== nextStatus) {
                        openRecord.post = nextPost;
                        openRecord.roll = nextRoll;
                        openRecord.holder_name = nextName;
                        openRecord.status = nextStatus;
                        openRecord.updated_at = nowIso;
                        changed = true;
                    }
                    return;
                }

                const startDate = ensureStartDate(assignment.start_date || today);
                nextId += 1;
                data.post_holder_history.push({
                    id: nextId,
                    assignment_key: assignment.assignment_key,
                    source: assignment.source,
                    post: assignment.post || '',
                    studentId: assignment.studentId || null,
                    roll: normalizeRoll(assignment.roll || ''),
                    holder_name: assignment.holder_name || '',
                    start_date: startDate,
                    end_date: '',
                    status: normalizePostHolderStatus(assignment.status),
                    created_at: nowIso,
                    updated_at: nowIso
                });
                changed = true;
            });

            if (!changed || options.persist === false) return false;
            db.saveData(data, options.saveOptions || {});
            return true;
        }

        function isValidRollNo(roll) {
            const value = String(roll || '').trim();
            return /^EA[A-Z0-9]{5}$/i.test(value);
        }

        function isValidStudentName(name) {
            const value = String(name || '').trim();
            if (!value) return false;
            if (value.includes('+')) return false;
            const blocked = ['column', 'team', 'total', 'party', 'post', 'holder', 'power', 'rank'];
            const lowered = value.toLowerCase();
            if (blocked.some(word => lowered === word || lowered.startsWith(`${word} `))) return false;
            if (!/[a-z]/i.test(value)) return false;
            return /^[a-z][a-z\s.'()-]*$/i.test(value);
        }

        function extractNameMeta(name) {
            const text = String(name || '').trim();
            if (!text) {
                return { baseName: '', stars: 0, vetos: 0 };
            }
            const stars = (text.match(/\*/g) || []).length;
            const vetoGroupMatches = text.match(/\((v+)\)/ig) || [];
            const vetos = vetoGroupMatches.reduce((sum, token) => {
                const onlyV = token.replace(/[^v]/ig, '');
                return sum + onlyV.length;
            }, 0);
            const baseName = text
                .replace(/\*+/g, '')
                .replace(/\((v+)\)/ig, '')
                .replace(/\s{2,}/g, ' ')
                .trim();
            return { baseName: baseName || text, stars, vetos };
        }

        function normalizeStudentMeta(student) {
            if (!student) return student;
            const parsed = extractNameMeta(student.name || '');
            if (!student.base_name) {
                student.base_name = parsed.baseName;
            }
            if (!student.raw_name) {
                student.raw_name = String(student.name || student.base_name || '').trim();
            }
            if (student.stars === undefined || student.stars === null || Number.isNaN(parseInt(student.stars, 10))) {
                student.stars = parsed.stars || 0;
            } else {
                student.stars = Math.max(0, parseInt(student.stars, 10) || 0);
            }
            if (student.veto_count === undefined || student.veto_count === null || Number.isNaN(parseInt(student.veto_count, 10))) {
                student.veto_count = parsed.vetos || 0;
            } else {
                student.veto_count = Math.max(0, parseInt(student.veto_count, 10) || 0);
            }
            if (!student.group) {
                student.group = deriveGroupFromRoll(student.roll);
            }
            if (student.active === undefined) {
                student.active = true;
            }
            if (!isValidRollNo(student.roll)) {
                student.roll = String(student.roll || '').trim().toUpperCase();
            } else {
                student.roll = student.roll.trim().toUpperCase();
            }
            return student;
        }

        function getStudentDesignations(studentId, month = '') {
            const monthKey = String(month || '').trim();
            if (monthKey && monthKey !== getCurrentMonthKey()) {
                return [];
            }
            const dateKey = monthKey ? `${monthKey}-15` : formatDateKey(new Date());
            const sid = parseInt(studentId, 10);
            if (!sid) return [];
            const ctx = buildRoleDisplayContext(dateKey);
            const values = ctx.designationsById.get(sid);
            return values ? Array.from(values) : [];
        }

        function stripPostHolderSuffixes(rawName) {
            const text = String(rawName || '').trim();
            if (!text) return text;
            // Strip only trailing role suffix blocks like "(CR) (PP) (L)".
            // Do not remove bracketed text inside the actual student name.
            const stripped = text.replace(/(?:\s*\((?:CR|PP|DPP|L|LoP|CoL|CITC|DWI|RM|SC|ECS|CCAI|CI|ECJ|WCI)\)\s*)+$/i, ' ');
            return stripped.replace(/\s{2,}/g, ' ').trim();
        }

        function getCanonicalStudentBaseName(student) {
            if (!student) return '-';
            const candidates = [
                safeProp(student, '__month_name'),
                safeProp(student, 'raw_name'),
                safeProp(student, 'base_name'),
                safeProp(student, 'name')
            ].map(value => String(value || '').trim()).filter(Boolean);
            for (const candidate of candidates) {
                const cleaned = stripPostHolderSuffixes(candidate);
                if (cleaned) return cleaned;
            }
            return candidates[0] || String(safeProp(student, 'roll') || '-');
        }

        function getLeadershipSuffix(postName) {
            const text = String(postName || '').trim();
            if (!text) return '';
            const paren = text.match(/\(([^)]+)\)/);
            if (paren && paren[1]) return paren[1].trim();
            const lower = text.toLowerCase();
            if (lower.includes('leader of opposition') || lower.includes('lop')) return 'LoP';
            if (lower.includes('co-leader') || lower.includes('co leader') || lower.includes('col')) return 'CoL';
            if (lower.includes('leader')) return 'L';
            return '';
        }

        function getDesignationSuffix(designation) {
            const text = String(designation || '').trim().toLowerCase();
            if (!text) return '';
            if (text === 'party president' || text === 'pp') return 'PP';
            if (text === 'deputy party president' || text === 'dpp') return 'DPP';
            return '';
        }

        function getActivePostSuffixesForStudent(student, dateKey) {
            if (!student || !student.id) return [];
            const ctx = buildRoleDisplayContext(dateKey);
            const values = ctx.suffixesById.get(parseInt(student.id, 10));
            return values ? Array.from(values) : [];
        }

        function getStudentDisplayNamePlain(student, month = '') {
            if (!student) return 'Unknown';
            const rawBase = getCanonicalStudentBaseName(student);
            const monthKey = String(month || '').trim();
            const dateKey = monthKey ? `${monthKey}-15` : formatDateKey(new Date());
            const suspended = isStudentPostHolderSuspended(student, dateKey);
            let base = stripPostHolderSuffixes(rawBase);
            const allowDynamicSuffix = !monthKey || monthKey === getCurrentMonthKey();
            if (!suspended && allowDynamicSuffix) {
                const suffixes = getActivePostSuffixesForStudent(student, dateKey);
                if (suffixes.length) {
                    base = `${base} ${suffixes.map(s => `(${s})`).join(' ')}`.trim();
                }
            }
            const cleaned = String(base || '').trim();
            return cleaned || String(safeProp(student, 'roll') || 'Unknown');
        }

        /**
         * Refresh all views that display student names with post holder suffixes
         * Call this after any post holder status change (suspend, activate, de-appoint)
         * This ensures visual effects (suffixes) and veto quotas update immediately across ALL tabs
         */
        function refreshAllPostHolderViews() {
            console.log('[POST-HOLDER] Refreshing all views for status change');

            // Force cache invalidation
            suspendedPostHolderCache.key = '';
            suspendedPostHolderCache.ids = new Set();
            votePowerSuspendedPostHolderCache.key = '';
            votePowerSuspendedPostHolderCache.ids = new Set();
            roleDisplayCache.key = '';
            roleDisplayCache.ctx = null;

            // Refresh all tabs that display student names with suffixes
            // This ensures immediate visual update across the entire application

            // 1. Scoreboard (PRIMARY - most important)
            try {
                if (typeof loadScoreboard === 'function') {
                    loadScoreboard();
                }
            } catch (e) {
                console.warn('[POST-HOLDER] Error refreshing scoreboard:', e);
            }

            // 2. Office Holders view
            try {
                if (typeof loadOfficeHolders === 'function') {
                    loadOfficeHolders();
                }
            } catch (e) {
                console.warn('[POST-HOLDER] Error refreshing office holders:', e);
            }

            // 3. Leadership tab
            try {
                if (typeof loadLeadership === 'function') {
                    loadLeadership();
                }
            } catch (e) {
                console.warn('[POST-HOLDER] Error refreshing leadership:', e);
            }

            // 4. Class Reps
            try {
                if (typeof loadClassReps === 'function' && document.getElementById('classRepsTableBody')) {
                    loadClassReps();
                }
            } catch (e) {
                console.warn('[POST-HOLDER] Error refreshing class reps:', e);
            }

            // 5. Group CRs
            try {
                if (typeof loadGroupCRs === 'function' && document.getElementById('groupCrsTableBody')) {
                    loadGroupCRs();
                }
            } catch (e) {
                console.warn('[POST-HOLDER] Error refreshing group CRs:', e);
            }

            // 6. Parties (includes party presidents)
            try {
                if (typeof loadParties === 'function' && document.getElementById('partyTableBody')) {
                    loadParties();
                }
            } catch (e) {
                console.warn('[POST-HOLDER] Error refreshing parties:', e);
            }

            // 7. Voting/Candidates
            try {
                if (typeof populateVotingSelects === 'function' && document.getElementById('candidatePost')) {
                    populateVotingSelects();
                    if (typeof loadCandidates === 'function') loadCandidates();
                    if (typeof loadVotingCandidates === 'function') loadVotingCandidates();
                }
            } catch (e) {
                console.warn('[POST-HOLDER] Error refreshing voting:', e);
            }

            console.log('[POST-HOLDER] All views refreshed successfully');
        }

        /**
         * Quick action to suspend a post holder
         * Removes all visual indicators and veto quotas immediately
         */
        function suspendPostHolder(postId, source = 'leadership') {
            if (!confirm('Suspend this post holder?\n\nThey will immediately lose:\n- Visual suffix (L), (CoL), (LoP), (CR), etc.\n- All veto quotas\n\nThis change is reversible.')) {
                return;
            }

            const data = db.getData();
            let updated = false;
            let holderName = '';

            if (source === 'leadership') {
                const post = (data.leadership || []).find(p => p.id === postId);
                if (post) {
                    post.status = 'suspended';
                    holderName = post.holder || post.roll || 'Post holder';
                    updated = true;
                }
            } else if (source === 'class_rep') {
                const rep = (data.class_reps || []).find(r => r.id === postId);
                if (rep) {
                    rep.status = 'suspended';
                    const student = (data.students || []).find(s => s.id === rep.studentId);
                    holderName = student ? (student.base_name || student.name) : 'CR';
                    updated = true;
                }
            } else if (source === 'group_cr') {
                const rep = (data.group_crs || []).find(r => r.id === postId);
                if (rep) {
                    rep.status = 'suspended';
                    const student = (data.students || []).find(s => s.id === rep.studentId);
                    holderName = student ? (student.base_name || student.name) : 'Group CR';
                    updated = true;
                }
            }

            if (updated) {
                savePostHolderData(data);
                showAlert(`${holderName} suspended. Visual effects removed across all tabs.`, 'warning');
            } else {
                showAlert('Post holder not found', 'danger');
            }
        }

        /**
         * Quick action to reactivate a suspended post holder
         * Restores all visual indicators and veto quotas immediately
         */
        function reactivatePostHolder(postId, source = 'leadership') {
            if (!confirm('Reactivate this post holder?\n\nThey will immediately regain:\n- Visual suffix (L), (CoL), (LoP), (CR), etc.\n- All veto quotas')) {
                return;
            }

            const data = db.getData();
            let updated = false;
            let holderName = '';

            if (source === 'leadership') {
                const post = (data.leadership || []).find(p => p.id === postId);
                if (post) {
                    post.status = 'active';
                    holderName = post.holder || post.roll || 'Post holder';
                    updated = true;
                }
            } else if (source === 'class_rep') {
                const rep = (data.class_reps || []).find(r => r.id === postId);
                if (rep) {
                    rep.status = 'active';
                    const student = (data.students || []).find(s => s.id === rep.studentId);
                    holderName = student ? (student.base_name || student.name) : 'CR';
                    updated = true;
                }
            } else if (source === 'group_cr') {
                const rep = (data.group_crs || []).find(r => r.id === postId);
                if (rep) {
                    rep.status = 'active';
                    const student = (data.students || []).find(s => s.id === rep.studentId);
                    holderName = student ? (student.base_name || student.name) : 'Group CR';
                    updated = true;
                }
            }

            if (updated) {
                savePostHolderData(data);
                showAlert(`${holderName} reactivated. Visual effects restored across all tabs.`, 'success');
            } else {
                showAlert('Post holder not found', 'danger');
            }
        }

        /**
         * Make post vacant (de-appoint holder)
         * Removes holder and all visual effects immediately
         */
        function deAppointPostHolder(postId, source = 'leadership') {
            if (!confirm('De-appoint this post holder and make the post vacant?\n\nThis will:\n- Remove the holder from the post\n- Remove all visual effects\n- Make the post available for new assignment')) {
                return;
            }

            const data = db.getData();
            let updated = false;
            let holderName = '';

            if (source === 'leadership') {
                const post = (data.leadership || []).find(p => p.id === postId);
                if (post) {
                    holderName = post.holder || post.roll || 'Post holder';
                    post.status = 'vacant';
                    post.holder = '';
                    post.roll = '';
                    post.studentId = null;
                    updated = true;
                }
            }

            if (updated) {
                savePostHolderData(data);
                showAlert(`${holderName} de-appointed. Post is now vacant.`, 'info');
            } else {
                showAlert('Post not found or cannot be made vacant', 'danger');
            }
        }

        function syncStudentPostHolderSuffixes(data, dateKey = '') {
            const checkDate = String(dateKey || formatDateKey(new Date())).trim();
            const students = data.students || [];
            students.forEach(student => {
                const clean = stripPostHolderSuffixes(student.raw_name || student.base_name || student.name || '');
                // Keep student names stable. Post-holder abbreviations are visual only (renderStudentName).
                // Stars are stored separately in student.stars and must never be altered by post-holder actions.
                student.base_name = clean.trim();
            });
        }

        function renderStudentName(student, month = '') {
            const rawBase = getCanonicalStudentBaseName(student);
            const monthKey = String(month || '').trim();
            const globalStars = Math.max(0, parseInt(safeProp(student, 'stars'), 10) || 0);
            const globalVetos = Math.max(0, parseInt(safeProp(student, 'veto_count'), 10) || 0);
            const isCurrentMonth = monthKey && monthKey === getCurrentMonthKey();
            let stars = globalStars;
            let vetos = globalVetos;
            if (monthKey && safeProp(student, 'id')) {
                const monthProfileStars = !isCurrentMonth ? (parseInt(safeProp(student, '__month_star_count'), 10) || 0) : 0;
                const monthProfileVetos = !isCurrentMonth ? (parseInt(safeProp(student, '__month_veto_count'), 10) || 0) : 0;
                const monthStars = getStudentMonthStarAwardTotal(student.id, monthKey) + monthProfileStars;
                const monthVetos = getStudentMonthVetoAwardTotal(student.id, monthKey) + monthProfileVetos;
                const usedStars = getStudentMonthNegativeDeltaTotal(student.id, monthKey, 'stars');
                const usedVetos = getStudentMonthNegativeDeltaTotal(student.id, monthKey, 'vetos');
                // Show month awards when present; otherwise show global counters adjusted for usage.
                stars = monthStars > 0 ? monthStars : Math.max(0, globalStars - usedStars);
                vetos = monthVetos > 0 ? monthVetos : Math.max(0, globalVetos - usedVetos);
            }
            const designations = safeProp(student, 'id') ? getStudentDesignations(student.id, month) : [];
            const monthDesignations = !isCurrentMonth && Array.isArray(safeProp(student, '__month_designations'))
                ? safeProp(student, '__month_designations')
                : [];
            const officeHolder = isOfficeHolderStudent(student, month);
            const dateKey = monthKey ? `${monthKey}-15` : formatDateKey(new Date());
            const suspended = isStudentPostHolderSuspended(student, dateKey);
            let base = stripPostHolderSuffixes(rawBase);
            const allowDynamicSuffix = !monthKey || monthKey === getCurrentMonthKey();
            if (!suspended && allowDynamicSuffix) {
                const autoSuffixes = getActivePostSuffixesForStudent(student, dateKey);
                if (autoSuffixes.length) {
                    base = `${base} ${autoSuffixes.map(s => `(${s})`).join(' ')}`.trim();
                }
            }
            const visibleBase = String(base || '').trim() || String(safeProp(student, '__month_name') || safeProp(student, 'base_name') || safeProp(student, 'name') || safeProp(student, 'roll') || 'Unknown');

            const badges = [];
            if (stars > 0) badges.push(`<span class="meta-star">*${stars}</span>`);
            if (vetos > 0) badges.push(`<span class="meta-veto">V${vetos}</span>`);
            const designationSet = new Set();
            (designations || []).forEach(d => { if (d) designationSet.add(d); });
            (monthDesignations || []).forEach(d => { if (d) designationSet.add(String(d)); });
            Array.from(designationSet).forEach(designation => badges.push(`<span class="designation-chip">${designation}</span>`));

            const nameClass = officeHolder ? 'student-name-core post-holder-name' : 'student-name-core';
            return `<span class="name-stack"><span class="${nameClass}">${escapeHtml(visibleBase)}</span>${badges.length ? `<span class="student-meta">${badges.join('')}</span>` : ''}</span>`;
        }

        function formatPartyCode(code) {
            const normalized = normalizePartyCode(code);
            if (!normalized) return String(code || '').trim().toUpperCase();
            return `${normalized} (${PARTY_CODE_LABELS[normalized]})`;
        }

        class ScoreboardDB {
            constructor() {
                this.storageKey = 'ea_scoreboard_data';
                this.suppressSync = true;
                this._cacheData = null;
                this._monthScoresCache = new Map();
                this._idb = null;              // IndexedDB handle (async, optional)
                this._idbReady = false;
                this._initIndexedDB();         // starts in background; localStorage is primary
                this.init();
                this.suppressSync = false;
            }

            // ── IndexedDB transparent write-through ──────────────────────────────────
            // localStorage remains the primary, synchronous store. IndexedDB is an
            // asynchronous write-through copy used as a secondary fallback if localStorage
            // ever becomes full or corrupted. No existing data is ever overwritten by IDB.
            _initIndexedDB() {
                try {
                    if (typeof indexedDB === 'undefined') return;
                    const req = indexedDB.open('ea_scoreboard_idb', 1);
                    req.onupgradeneeded = (e) => {
                        const idb = e.target.result;
                        if (!idb.objectStoreNames.contains('snapshots')) {
                            idb.createObjectStore('snapshots');
                        }
                    };
                    req.onsuccess = (e) => {
                        this._idb = e.target.result;
                        this._idbReady = true;
                    };
                    req.onerror = () => { this._idb = null; };
                } catch (e) {
                    this._idb = null;
                }
            }

            _idbWrite(serialized) {
                // Fire-and-forget: write a JSON string to IndexedDB asynchronously.
                if (!this._idb) return;
                try {
                    const tx = this._idb.transaction('snapshots', 'readwrite');
                    tx.objectStore('snapshots').put(serialized, 'main');
                } catch (e) { /* non-fatal: IDB writes are supplemental */ }
            }

            getDefaultData() {
                return {
                    students: [],
                    scores: [],
                    months: [],
                    month_students: {},
                    month_extra_columns: {},
                    month_student_extras: {},
            month_roster_profiles: {},
            parties: [],
            leadership: [],
            class_reps: [],
            group_crs: [],
            election_candidates: [],
            election_votes: [],
            election_individual_votes: [],
            election_teacher_votes: [],
            pending_election_results: [],
            teachers: [],
            role_veto_grants: [],
            role_veto_monthly: {},
            appeals: [],
            attendance: [],
            fee_records: [],
            resource_cabinet: [],
            resource_requests: [],
            resource_transactions: [],
            resource_advantage_deductions: [],
                    syllabus_catalog: {},
                    syllabus_tracking: [],
                    syllabus_seed_version: '',
                    homework: [],
                    post_holder_history: [],
                    notification_history: [],
                    activity_log: [],
                    updated_at: null
                };
            }

            init() {
                try {
                    reclaimLocalStorageSpace();
                    const data = localStorage.getItem(this.storageKey);
                    if (!data) {
                        this.saveData(this.getDefaultData(), { system: true, skipSync: true, skipBackup: true });
                    }
                    this.ensureSchema();
                } catch (err) {
                    // Recover from malformed storage instead of blocking page load.
                    try { localStorage.removeItem(this.storageKey); } catch (e) {}
                    this._cacheData = this.getDefaultData();
                    this._monthScoresCache.clear();
                    this.saveData(this._cacheData, { system: true, skipSync: true, skipBackup: true });
                }
            }

            ensureSchema() {
                const data = this.getData();
                const originalSerialized = JSON.stringify(data || {});
                if (!data.parties) data.parties = [];
                if (!data.leadership) data.leadership = [];
                if (!data.months) data.months = [];
                if (!data.month_students) data.month_students = {};
                if (!data.month_extra_columns) data.month_extra_columns = {};
                if (!data.month_student_extras) data.month_student_extras = {};
                if (!data.month_roster_profiles) data.month_roster_profiles = {};
                if (!data.class_reps) data.class_reps = [];
            if (!data.group_crs) data.group_crs = [];
            if (!data.election_candidates) data.election_candidates = [];
            if (!data.election_votes) data.election_votes = [];
            if (!data.election_individual_votes) data.election_individual_votes = [];
            if (!data.election_teacher_votes) data.election_teacher_votes = [];
            if (!data.pending_election_results) data.pending_election_results = [];
            if (!data.teachers) data.teachers = [];
            if (!data.role_veto_grants) data.role_veto_grants = [];
            if (!data.role_veto_monthly) data.role_veto_monthly = {};
                if (!data.appeals) data.appeals = [];
                if (!data.attendance) data.attendance = [];
                if (!data.fee_records) data.fee_records = [];
                if (!data.resource_cabinet) data.resource_cabinet = [];
                if (!data.resource_requests) data.resource_requests = [];
                if (!data.resource_transactions) data.resource_transactions = [];
                if (!Array.isArray(data.resource_advantage_deductions)) data.resource_advantage_deductions = [];
                if (!data.syllabus_catalog || typeof data.syllabus_catalog !== 'object') data.syllabus_catalog = {};
                if (!data.syllabus_tracking) data.syllabus_tracking = [];
                if (!data.syllabus_seed_version) data.syllabus_seed_version = '';
                if (!data.homework) data.homework = [];
                if (!data.post_holder_history) data.post_holder_history = [];
                if (!data.notification_history) data.notification_history = [];
                if (!data.activity_log) data.activity_log = [];
                data.students = (data.students || [])
                    .map(student => normalizeStudentMeta(student))
                    .filter(student => isValidRollNo(student.roll) && isValidStudentName(student.base_name || student.name));
                data.scores = (data.scores || []).map(score => ({
                    ...score,
                    stars: parseInt(score.stars, 10) || 0,
                    vetos: parseInt(score.vetos, 10) || 0
                }));
                data.parties = data.parties.map(party => ({
                    members: [],
                    ...party,
                    members: (Array.isArray(party.members) ? party.members : []).map(member => ({
                        ...member,
                        status: normalizePostHolderStatus(member.status || 'active')
                    }))
                }));
                data.leadership = data.leadership.map(post => ({
                    elected_on: '',
                    roll: '',
                    ...post,
                    status: normalizePostHolderStatus(post.status || 'active')
                }));
                data.class_reps = (data.class_reps || []).map(rep => ({
                    ...rep,
                    status: normalizePostHolderStatus(rep.status || 'active')
                }));
                data.election_votes = (data.election_votes || []).map(vote => ({
                    ...vote,
                    post: String(vote.post || ''),
                    partyId: parseInt(vote.partyId, 10) || vote.partyId,
                    candidateId: parseInt(vote.candidateId, 10) || vote.candidateId,
                    timestamp: String(vote.timestamp || '')
                }));
            data.election_individual_votes = (data.election_individual_votes || []).map(vote => ({
                ...vote,
                post: String(vote.post || ''),
                voterStudentId: parseInt(vote.voterStudentId, 10) || vote.voterStudentId,
                candidateId: vote.candidateId === null || vote.candidateId === undefined ? null : (parseInt(vote.candidateId, 10) || vote.candidateId),
                voteType: ['candidate', 'abstain', 'nota'].includes(String(vote.voteType || '').toLowerCase())
                    ? String(vote.voteType || '').toLowerCase()
                    : 'candidate',
                timestamp: String(vote.timestamp || '')
            }));
            data.election_teacher_votes = (data.election_teacher_votes || []).map(vote => ({
                ...vote,
                post: String(vote.post || ''),
                teacherId: parseInt(vote.teacherId, 10) || vote.teacherId,
                candidateId: parseInt(vote.candidateId, 10) || vote.candidateId,
                votePower: parseFloat(vote.votePower) || 0,
                timestamp: String(vote.timestamp || '')
            }));
            data.pending_election_results = (data.pending_election_results || []).map(item => ({
                ...item,
                post: String(item.post || ''),
                candidateId: parseInt(item.candidateId, 10) || item.candidateId,
                source: String(item.source || 'student'),
                status: String(item.status || 'pending'),
                timestamp: String(item.timestamp || '')
            }));
            data.teachers = (data.teachers || []).map(teacher => ({
                id: parseInt(teacher.id, 10) || Date.now(),
                name: String(teacher.name || '').trim(),
                roll: String(teacher.roll || '').trim(),
                subject: String(teacher.subject || '').trim(),
                active: teacher.active !== false
            })).filter(t => t.name);
                data.post_holder_history = (data.post_holder_history || []).map(item => ({
                    ...item,
                    status: item.end_date ? 'ended' : normalizePostHolderStatus(item.status || 'active')
                }));
                // Fee records: de-duplicate and merge safely (never lose payment proof).
                data.fee_records = mergeFeeRecordsSuperset([], data.fee_records || []);
                ensurePartyCatalogData(data);
                ensureLeadershipCatalogData(data);

                // Resource Management: ensure stable default shapes (safe normalization only).
                data.resource_cabinet = (Array.isArray(data.resource_cabinet) ? data.resource_cabinet : []).map(item => ({
                    id: parseInt(item && item.id, 10) || 0,
                    name: String(item && item.name || '').trim(),
                    unit: String(item && item.unit || '').trim(),
                    price_per_unit: Number(item && (item.price_per_unit !== undefined && item.price_per_unit !== null ? item.price_per_unit : item.pricePerUnit)) || 0,
                    total_held: parseInt(item && (item.total_held !== undefined && item.total_held !== null ? item.total_held : item.totalHeld), 10) || 0,
                    created_at: String(item && item.created_at || '').trim(),
                    updated_at: String(item && item.updated_at || '').trim()
                })).filter(it => it.name);
                data.resource_requests = (Array.isArray(data.resource_requests) ? data.resource_requests : []).map(req => ({
                    ...req,
                    id: parseInt(req && req.id, 10) || 0,
                    studentId: parseInt(req && req.studentId, 10) || req && req.studentId,
                    item_id: parseInt(req && (req.item_id || req.itemId), 10) || 0,
                    qty: Math.max(1, parseInt(req && (req.qty || req.quantity), 10) || 1),
                    type: String(req && (req.type || req.mode) || '').trim().toLowerCase(),
                    status: String(req && req.status || '').trim().toLowerCase(),
                    created_at: String(req && req.created_at || '').trim(),
                    updated_at: String(req && req.updated_at || '').trim()
                })).filter(r => r.id);
                data.resource_transactions = (Array.isArray(data.resource_transactions) ? data.resource_transactions : []).map(txn => ({
                    ...txn,
                    id: parseInt(txn && txn.id, 10) || 0,
                    studentId: parseInt(txn && txn.studentId, 10) || txn && txn.studentId,
                    item_id: parseInt(txn && (txn.item_id || txn.itemId), 10) || 0,
                    qty: Math.max(1, parseInt(txn && (txn.qty || txn.quantity), 10) || 1),
                    type: String(txn && (txn.type || txn.mode) || '').trim().toLowerCase(),
                    created_at: String(txn && txn.created_at || '').trim(),
                    updated_at: String(txn && txn.updated_at || '').trim()
                })).filter(t => t.id);
                data.resource_advantage_deductions = (Array.isArray(data.resource_advantage_deductions) ? data.resource_advantage_deductions : []).map(d => ({
                    ...d,
                    id: parseInt(d && d.id, 10) || 0,
                    studentId: parseInt(d && d.studentId, 10) || 0,
                    month: String(d && d.month || '').trim(),
                    points_deducted: Math.max(0, parseInt(d && d.points_deducted, 10) || 0),
                    transaction_id: parseInt(d && d.transaction_id, 10) || 0,
                    item_name: String(d && d.item_name || '').trim(),
                    qty: Math.max(1, parseInt(d && d.qty, 10) || 1),
                    created_at: String(d && d.created_at || '').trim(),
                    reversed: Boolean(d && d.reversed)
                })).filter(d => d.id && d.studentId && d.month);
                data.syllabus_catalog = normalizeSyllabusCatalogShape(data.syllabus_catalog || {});
                data.syllabus_tracking = normalizeSyllabusTrackingRows(data.syllabus_tracking || []);
                if (String(data.syllabus_seed_version || '') !== SYLLABUS_SEED_VERSION) {
                    data.syllabus_catalog = mergeSyllabusCatalogSuperset(
                        data.syllabus_catalog,
                        buildInitialSyllabusCatalog()
                    );
                    data.syllabus_seed_version = SYLLABUS_SEED_VERSION;
                }
                data.month_extra_columns = Object.fromEntries(
                    Object.entries(data.month_extra_columns || {}).map(([month, cols]) => {
                        const normalized = (Array.isArray(cols) ? cols : [])
                            .map((col, idx) => {
                                const label = String(col && col.label ? col.label : '').trim();
                                if (!label) return null;
                                const key = String(col && col.key ? col.key : `extra_${idx + 1}`).trim().toLowerCase();
                                return { key, label };
                            })
                            .filter(Boolean);
                        return [month, normalized];
                    })
                );
                data.month_student_extras = Object.fromEntries(
                    Object.entries(data.month_student_extras || {}).map(([month, studentMap]) => {
                        const normalizedStudents = {};
                        Object.entries(studentMap || {}).forEach(([studentKey, values]) => {
                            const safeStudentKey = String(studentKey || '').trim().toUpperCase();
                            if (!safeStudentKey) return;
                            const mapped = {};
                            Object.entries(values || {}).forEach(([k, v]) => {
                                const key = String(k || '').trim().toLowerCase();
                                if (!key) return;
                                if (v === null || v === undefined || String(v).trim() === '') return;
                                mapped[key] = typeof v === 'number' ? v : String(v).trim();
                            });
                            if (Object.keys(mapped).length) {
                                normalizedStudents[safeStudentKey] = mapped;
                            }
                        });
                        return [month, normalizedStudents];
                    })
                );
                data.month_roster_profiles = Object.fromEntries(
                    Object.entries(data.month_roster_profiles || {}).map(([month, profiles]) => {
                        const normalizedProfiles = (Array.isArray(profiles) ? profiles : [])
                            .map(profile => {
                                const roll = String(profile && profile.roll ? profile.roll : '').trim().toUpperCase();
                                if (!roll || !isValidRollNo(roll)) return null;
                                const rawName = String(profile && profile.name ? profile.name : '').trim();
                                const baseName = String(profile && profile.base_name ? profile.base_name : extractNameMeta(rawName).baseName).trim();
                                if (!isValidStudentName(baseName)) return null;
                                const classVal = parseInt(profile && profile.class, 10);
                                const starCount = parseInt(profile && profile.month_star_count, 10);
                                const vetoCount = parseInt(profile && profile.month_veto_count, 10);
                                const designations = Array.isArray(profile && profile.month_designations)
                                    ? profile.month_designations.map(item => String(item || '').trim()).filter(Boolean)
                                    : [];
                                return {
                                    roll,
                                    name: rawName || baseName,
                                    base_name: baseName,
                                    class: Number.isNaN(classVal) ? null : classVal,
                                    month_star_count: Number.isNaN(starCount) ? 0 : Math.max(0, starCount),
                                    month_veto_count: Number.isNaN(vetoCount) ? 0 : Math.max(0, vetoCount),
                                    month_designations: designations
                                };
                            })
                            .filter(Boolean);
                        return [month, normalizedProfiles];
                    })
                );
                // ── Schema versioning ──────────────────────────────────────────────────────
                // Bump APP_SCHEMA_VERSION here whenever a structural migration is added below.
                // Each migration block is guarded by the version it was introduced in, so
                // it runs exactly once per device and never again.
                const APP_SCHEMA_VERSION = 2;
                const storedSchemaVer = parseInt(data._app_schema_version || 0, 10);
                if (storedSchemaVer < APP_SCHEMA_VERSION) {
                    // v1 → v2: ensure every resource_transaction has pending_settlement field
                    if (storedSchemaVer < 2) {
                        // Transactions that existed before the pending_settlement feature was added
                        // are already "done" — leave them as-is (no flag = isCompleted returns true).
                        // This is a no-op migration; we just record the version so future migrations
                        // can reliably detect what state the data was in.
                    }
                    data._app_schema_version = APP_SCHEMA_VERSION;
                }

                // Safety: schema normalization should never trigger an outbound sync by itself.
                if (JSON.stringify(data || {}) !== originalSerialized) {
                    this.saveData(data, { system: true, skipSync: true, skipBackup: true, preserveTimestamp: true });
                }
            }

            getData() {
                if (this._cacheData) {
                    return this._cacheData;
                }
                const raw = localStorage.getItem(this.storageKey);
                if (!raw) {
                    this._cacheData = this.getDefaultData();
                    return this._cacheData;
                }
                try {
                    this._cacheData = JSON.parse(raw);
                } catch (err) {
                    try { localStorage.removeItem(this.storageKey); } catch (e) {}
                    this._cacheData = this.getDefaultData();
                }
                return this._cacheData;
            }

            saveData(data, options = {}) {
                if (!data) return;
                if (!options.system && !canEditData(options)) {
                    showAlert('Read-only access. Changes are not saved.', 'warning');
                    return false;
                }
                if (!options.preserveTimestamp) {
                    data.updated_at = new Date().toISOString();
                }
                this._cacheData = data;
                this._monthScoresCache.clear();
                const serialized = JSON.stringify(data);
                let savedLocally = false;
                try {
                    localStorage.setItem(this.storageKey, serialized);
                    savedLocally = true;
                    this._idbWrite(serialized); // async write-through to IndexedDB (non-blocking)
                } catch (err) {
                    if (reclaimLocalStorageSpace()) {
                        try {
                            localStorage.setItem(this.storageKey, serialized);
                            savedLocally = true;
                            this._idbWrite(serialized);
                        } catch (retryErr) {
                            // fall through to warning below
                        }
                    }
                    if (!savedLocally && !options.system) {
                        showAlert('Local storage is full. Please run Master Update and reload.', 'warning');
                    }
                }
                if (!options.skipBackup) {
                    maybeLocalBackup(data);
                }
                if (!options.skipSync && !this.suppressSync) {
                    scheduleServerPush(data);
                }
                return savedLocally;
            }

            async loadSampleData() {
                const data = this.getData();
                const needsSeed =
                    data.students.length === 0 ||
                    data.scores.length === 0 ||
                    !data.month_students ||
                    Object.keys(data.month_students).length === 0 ||
                    data.parties.length === 0 ||
                    data.leadership.length === 0;
                const seed = needsSeed ? await getFeb26Seed() : null;
                let updated = false;
                if (data.students.length === 0) {
                    data.students = cloneSeed(seed && seed.students ? seed.students : []).map(student => ({
                        ...student,
                        group: deriveGroupFromRoll(student.roll),
                        active: true
                    })).map(student => normalizeStudentMeta(student));
                    updated = true;
                }
                if (data.scores.length === 0) {
                    data.scores = cloneSeed(seed && seed.scores ? seed.scores : []);
                    updated = true;
                }
                if (!data.month_students || Object.keys(data.month_students).length === 0) {
                    data.month_students = cloneSeed((seed && seed.month_students) || {});
                    updated = true;
                }
                if (!data.month_extra_columns) {
                    data.month_extra_columns = {};
                    updated = true;
                }
                if (!data.month_student_extras) {
                    data.month_student_extras = {};
                    updated = true;
                }
                if (!data.month_roster_profiles) {
                    data.month_roster_profiles = {};
                    updated = true;
                }
                if (data.parties.length === 0) {
                    data.parties = cloneSeed(seed && seed.parties ? seed.parties : []).map((party, idx) => ({
                        id: idx + 1,
                        ...party,
                        members: []
                    }));
                    updated = true;
                }
                if (data.leadership.length === 0) {
                    data.leadership = cloneSeed(seed && seed.leadership ? seed.leadership : []).map((post, idx) => ({
                        id: idx + 1,
                        ...post
                    }));
                    updated = true;
                }
                if (!data.class_reps) {
                    data.class_reps = [];
                    updated = true;
                }
                if (!data.election_candidates) {
                    data.election_candidates = [];
                    updated = true;
                }
                if (!data.election_votes) {
                    data.election_votes = [];
                    updated = true;
                }
                if (!data.group_crs) {
                    data.group_crs = [];
                    updated = true;
                }
                if (!data.role_veto_grants) {
                    data.role_veto_grants = [];
                    updated = true;
                }
                if (!data.appeals) {
                    data.appeals = [];
                    updated = true;
                }
                if (!data.attendance) {
                    data.attendance = [];
                    updated = true;
                }
                if (!data.syllabus_catalog || typeof data.syllabus_catalog !== 'object') {
                    data.syllabus_catalog = buildInitialSyllabusCatalog();
                    updated = true;
                }
                if (!data.syllabus_tracking) {
                    data.syllabus_tracking = [];
                    updated = true;
                }
                if (!data.syllabus_seed_version || String(data.syllabus_seed_version) !== SYLLABUS_SEED_VERSION) {
                    data.syllabus_catalog = mergeSyllabusCatalogSuperset(
                        normalizeSyllabusCatalogShape(data.syllabus_catalog || {}),
                        buildInitialSyllabusCatalog()
                    );
                    data.syllabus_seed_version = SYLLABUS_SEED_VERSION;
                    updated = true;
                }
                if (updated) {
                    this.saveData(data, { system: true });
                }
            }

            addStudent(student) {
                const data = this.getData();
                student.id = Date.now();
                normalizeStudentMeta(student);
                data.students.push(student);
                this.saveData(data);
                return student;
            }

            addScore(score) {
                const data = this.getData();
                const applyStarVetoDelta = (studentId, deltaStars, deltaVetos) => {
                    const student = data.students.find(s => s.id === studentId);
                    if (!student) return;
                    normalizeStudentMeta(student);
                    student.stars = Math.max(0, (parseInt(student.stars, 10) || 0) + (deltaStars || 0));
                    // VETO logic removed.
                };
                score.stars = parseInt(score.stars, 10) || 0;
                score.vetos = parseInt(score.vetos, 10) || 0;
                const existing = data.scores.find(s => s.studentId === score.studentId && s.date === score.date);
                if (existing) {
                    const oldStars = parseInt(existing.stars, 10) || 0;
                    const oldVetos = parseInt(existing.vetos, 10) || 0;
                    existing.points = score.points;
                    existing.month = score.month;
                    existing.notes = score.notes || '';
                    existing.stars = score.stars;
                    existing.vetos = score.vetos;
                    existing.recordedBy = score.recordedBy || existing.recordedBy;
                    existing.updated_at = new Date().toISOString();
                    applyStarVetoDelta(score.studentId, score.stars - oldStars, score.vetos - oldVetos);
                    this.saveData(data, { allowTeacher: true });
                    return { score: existing, updated: true };
                }
                score.id = Date.now();
                score.updated_at = new Date().toISOString();
                data.scores.push(score);
                applyStarVetoDelta(score.studentId, score.stars, score.vetos);
                this.saveData(data, { allowTeacher: true });
                return { score, updated: false };
            }

            getScore(studentId, date) {
                const data = this.getData();
                return data.scores.find(s => s.studentId === studentId && s.date === date);
            }

            deleteScore(studentId, date) {
                const data = this.getData();
                const existing = data.scores.find(s => s.studentId === studentId && s.date === date);
                if (existing) {
                    const student = data.students.find(s => s.id === studentId);
                    if (student) {
                        normalizeStudentMeta(student);
                        student.stars = Math.max(0, (parseInt(student.stars, 10) || 0) - (parseInt(existing.stars, 10) || 0));
                        student.veto_count = Math.max(0, (parseInt(student.veto_count, 10) || 0) - (parseInt(existing.vetos, 10) || 0));
                    }
                }
                data.scores = data.scores.filter(s => !(s.studentId === studentId && s.date === date));
                this.saveData(data);
            }

            getStudents() {
                return this.getData().students.map(student => normalizeStudentMeta(student));
            }

            getActiveStudents() {
                return this.getData().students.filter(s => s.active !== false);
            }

            updateStudent(studentId, updates) {
                const data = this.getData();
                const student = data.students.find(s => s.id === studentId);
                if (!student) return null;
                const prevRoll = normalizeRoll(student.roll);
                Object.assign(student, updates);
                normalizeStudentMeta(student);
                const nextRoll = normalizeRoll(student.roll);

                if (prevRoll && nextRoll && prevRoll !== nextRoll) {
                    const monthStudents = data.month_students || {};
                    Object.keys(monthStudents).forEach(monthKey => {
                        const list = Array.isArray(monthStudents[monthKey]) ? monthStudents[monthKey] : [];
                        let touched = false;
                        const mapped = list.map(value => {
                            const roll = normalizeRosterValue(value);
                            if (roll === prevRoll) {
                                touched = true;
                                return nextRoll;
                            }
                            return roll;
                        });
                        if (!touched) return;
                        const deduped = [];
                        const seen = new Set();
                        mapped.forEach(value => {
                            const roll = normalizeRosterValue(value);
                            if (!roll || seen.has(roll)) return;
                            seen.add(roll);
                            deduped.push(roll);
                        });
                        monthStudents[monthKey] = deduped;
                    });

                    const monthProfilesMap = data.month_roster_profiles || {};
                    Object.keys(monthProfilesMap).forEach(monthKey => {
                        const profiles = Array.isArray(monthProfilesMap[monthKey]) ? monthProfilesMap[monthKey] : [];
                        let touched = false;
                        profiles.forEach(profile => {
                            if (!profile || typeof profile !== 'object') return;
                            if (normalizeRosterValue(profile.roll) !== prevRoll) return;
                            profile.roll = nextRoll;
                            touched = true;
                        });
                        if (!touched) return;
                        const byRoll = new Map();
                        profiles.forEach(profile => {
                            if (!profile || typeof profile !== 'object') return;
                            const roll = normalizeRosterValue(profile.roll);
                            if (!roll) return;
                            const prev = byRoll.get(roll) || {};
                            byRoll.set(roll, { ...prev, ...profile, roll });
                        });
                        monthProfilesMap[monthKey] = Array.from(byRoll.values());
                    });
                }
                this.saveData(data);
                return student;
            }

            setStudentActive(studentId, isActive) {
                return this.updateStudent(studentId, { active: isActive });
            }

            getParties() {
                return this.getData().parties || [];
            }

            addParty(party) {
                const data = this.getData();
                const code = normalizePartyCode(party && party.code);
                const existing = (data.parties || []).find(p => normalizePartyCode(p.code) === code);
                if (existing) {
                    // Upsert by code to avoid duplicate-party collapse during sync/schema normalization.
                    if (!Array.isArray(existing.members)) existing.members = [];
                    if (party && party.full_name) existing.full_name = party.full_name;
                    this.saveData(data);
                    return existing;
                }
                party.id = Date.now();
                party.members = party.members || [];
                data.parties.push(party);
                this.saveData(data);
                return party;
            }

            updateParty(partyId, updates) {
                const data = this.getData();
                const party = data.parties.find(p => p.id === partyId);
                if (!party) return null;
                Object.assign(party, updates);
                if (!Array.isArray(party.members)) {
                    party.members = [];
                }
                this.saveData(data);
                return party;
            }

            deleteParty(partyId) {
                const data = this.getData();
                data.parties = data.parties.filter(p => p.id !== partyId);
                this.saveData(data);
            }

            getLeadership() {
                return this.getData().leadership || [];
            }

            addLeadership(post) {
                const data = this.getData();
                post.id = Date.now();
                data.leadership = data.leadership || [];
                data.leadership.push(post);
                this.saveData(data);
                return post;
            }

            updateLeadership(postId, updates) {
                const data = this.getData();
                data.leadership = data.leadership || [];
                const post = data.leadership.find(p => p.id === postId);
                if (!post) return null;
                if (updates.roll && updates.roll.trim()) {
                    const roll = normalizeRoll(updates.roll);
                    if (!isValidRollNo(roll)) {
                        console.warn('Invalid roll number in updateLeadership:', updates.roll);
                        return null;
                    }
                }
                Object.assign(post, updates);
                this.saveData(data);
                return post;
            }

            deleteLeadership(postId) {
                const data = this.getData();
                data.leadership = data.leadership.filter(p => p.id !== postId);
                this.saveData(data);
            }

            getClassReps() {
                return this.getData().class_reps || [];
            }

            addClassRep(rep) {
                const data = this.getData();
                rep.id = Date.now();
                data.class_reps.push(rep);
                this.saveData(data);
                return rep;
            }

            updateClassRep(repId, updates) {
                const data = this.getData();
                const rep = data.class_reps.find(r => r.id === repId);
                if (!rep) return null;
                Object.assign(rep, updates);
                this.saveData(data);
                return rep;
            }

            deleteClassRep(repId) {
                const data = this.getData();
                data.class_reps = data.class_reps.filter(r => r.id !== repId);
                this.saveData(data);
            }

            getCandidates() {
                return this.getData().election_candidates || [];
            }

            addCandidate(candidate) {
                const data = this.getData();
                const entry = { ...candidate, id: Date.now() };
                data.election_candidates.push(entry);
                const saved = this.saveData(data);
                if (!saved) {
                    data.election_candidates = data.election_candidates.filter(c => c.id !== entry.id);
                    return null;
                }
                return entry;
            }

            deleteCandidate(candidateId) {
                const data = this.getData();
                data.election_candidates = data.election_candidates.filter(c => c.id !== candidateId);
                data.election_votes = data.election_votes.filter(v => v.candidateId !== candidateId);
                data.election_individual_votes = (data.election_individual_votes || []).filter(v => v.candidateId !== candidateId);
                data.pending_election_results = (data.pending_election_results || []).filter(r => r.candidateId !== candidateId);
                this.saveData(data);
            }

            getVotes() {
                return this.getData().election_votes || [];
            }

            recordVote(vote) {
                const data = this.getData();
                const existing = data.election_votes.find(v => v.post === vote.post && v.partyId === vote.partyId);
                if (existing) {
                    existing.candidateId = vote.candidateId;
                    existing.timestamp = vote.timestamp;
                } else {
                    vote.id = Date.now();
                    data.election_votes.push(vote);
                }
                this.saveData(data);
                return vote;
            }

            getIndividualVotes() {
                return this.getData().election_individual_votes || [];
            }

            recordIndividualVote(vote) {
                const data = this.getData();
                data.election_individual_votes = data.election_individual_votes || [];
                const existing = data.election_individual_votes.find(v =>
                    String(v.post || '') === String(vote.post || '') &&
                    String(v.voterStudentId) === String(vote.voterStudentId)
                );
                if (existing) {
                    existing.candidateId = vote.candidateId === undefined ? null : vote.candidateId;
                    existing.voteType = String(vote.voteType || 'candidate').toLowerCase();
                    existing.timestamp = vote.timestamp;
                } else {
                    vote.id = Date.now() + Math.floor(Math.random() * 1000);
                    vote.voteType = String(vote.voteType || 'candidate').toLowerCase();
                    data.election_individual_votes.push(vote);
                }
                this.saveData(data);
                return vote;
            }

            getTeacherVotes() {
                return this.getData().election_teacher_votes || [];
            }

            recordTeacherVote(vote) {
                const data = this.getData();
                data.election_teacher_votes = data.election_teacher_votes || [];
                const existing = data.election_teacher_votes.find(v =>
                    String(v.post || '') === String(vote.post || '') &&
                    String(v.teacherId) === String(vote.teacherId)
                );
                if (existing) {
                    Object.assign(existing, vote);
                } else {
                    vote.id = Date.now() + Math.floor(Math.random() * 1000);
                    data.election_teacher_votes.push(vote);
                }
                this.saveData(data);
                return vote;
            }

            getTeachers() {
                return this.getData().teachers || [];
            }

            addTeacher(teacher) {
                const data = this.getData();
                teacher.id = Date.now();
                data.teachers.push(teacher);
                this.saveData(data);
                return teacher;
            }

            updateTeacher(teacherId, updates) {
                const data = this.getData();
                const t = data.teachers.find(item => item.id === teacherId);
                if (!t) return null;
                Object.assign(t, updates);
                this.saveData(data);
                return t;
            }

            deleteTeacher(teacherId) {
                const data = this.getData();
                data.teachers = (data.teachers || []).filter(t => t.id !== teacherId);
                this.saveData(data);
            }

            getPendingResults() {
                return this.getData().pending_election_results || [];
            }

            upsertPendingResult(result) {
                const data = this.getData();
                data.pending_election_results = data.pending_election_results || [];
                const key = (r) => `${String(r.post || '').trim().toLowerCase()}::${String(r.source || '').trim().toLowerCase()}`;
                const existing = data.pending_election_results.find(r => key(r) === key(result));
                if (existing) {
                    Object.assign(existing, result, { updated_at: new Date().toISOString() });
                } else {
                    result.id = Date.now();
                    result.updated_at = new Date().toISOString();
                    data.pending_election_results.push(result);
                }
                this.saveData(data);
                return result;
            }

            decidePendingResult(post, source, status) {
                const data = this.getData();
                const nowIso = new Date().toISOString();
                const matchKey = `${String(post || '').trim().toLowerCase()}::${String(source || '').trim().toLowerCase()}`;
                const record = (data.pending_election_results || []).find(r =>
                    `${String(r.post || '').trim().toLowerCase()}::${String(r.source || '').trim().toLowerCase()}` === matchKey
                );
                if (!record) return false;
                record.status = String(status || 'approved').trim().toLowerCase();
                record.decided_at = nowIso;
                record.updated_at = nowIso;
                this.saveData(data);
                return true;
            }

            removePendingResult(post, source) {
                const data = this.getData();
                const matchKey = `${String(post || '').trim().toLowerCase()}::${String(source || '').trim().toLowerCase()}`;
                data.pending_election_results = (data.pending_election_results || []).filter(r => `${String(r.post || '').trim().toLowerCase()}::${String(r.source || '').trim().toLowerCase()}` !== matchKey);
                this.saveData(data);
            }

            getAppeals() {
                return this.getData().appeals || [];
            }

            addAppeal(appeal) {
                const data = this.getData();
                appeal.id = Date.now();
                data.appeals = data.appeals || [];
                data.appeals.push(appeal);
                this.saveData(data, { allowTeacher: true, allowStudent: true });
                return appeal;
            }

            updateAppeal(appealId, updates) {
                const data = this.getData();
                const appeal = (data.appeals || []).find(a => a.id === appealId);
                if (!appeal) return null;
                Object.assign(appeal, updates);
                appeal.updated_at = new Date().toISOString();
                this.saveData(data, { allowTeacher: true });
                return appeal;
            }

            getAttendance() {
                return this.getData().attendance || [];
            }

            upsertAttendance(record, options = {}) {
                const data = this.getData();
                data.attendance = data.attendance || [];
                const targetDate = String(record.date || '');
                const targetStudent = String(record.studentId);
                const normalizedRoll = normalizeAttendanceRoll(record.roll || '');
                const normalizedRecord = {
                    ...record,
                    date: targetDate,
                    studentId: parseInt(record.studentId, 10) || record.studentId,
                    roll: normalizedRoll,
                    status: normalizeAttendanceStatus(record.status),
                    remarks: String(record.remarks || '')
                };
                const existing = data.attendance.find(item =>
                    String(item.date || '') === targetDate && String(item.studentId) === targetStudent
                );
                if (existing) {
                    Object.assign(existing, normalizedRecord, { updated_at: new Date().toISOString() });
                } else {
                    data.attendance.push({
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        ...normalizedRecord,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    });
                }
                const latestByKey = new Map();
                (data.attendance || []).forEach(item => {
                    const key = `${String(item.date || '')}::${String(item.studentId)}`;
                    const existingItem = latestByKey.get(key);
                    if (!existingItem) {
                        latestByKey.set(key, item);
                        return;
                    }
                    const existingStamp = Date.parse(existingItem.updated_at || existingItem.created_at || '') || 0;
                    const itemStamp = Date.parse(item.updated_at || item.created_at || '') || 0;
                    if (itemStamp >= existingStamp) {
                        latestByKey.set(key, item);
                    }
                });
                data.attendance = Array.from(latestByKey.values());
                this.saveData(data, { allowTeacher: true, skipSync: options.skipSync === true });
            }

            getSyllabusCatalog() {
                const data = this.getData();
                data.syllabus_catalog = normalizeSyllabusCatalogShape(data.syllabus_catalog || {});
                return data.syllabus_catalog;
            }

            getSyllabusTracking() {
                const data = this.getData();
                data.syllabus_tracking = normalizeSyllabusTrackingRows(data.syllabus_tracking || []);
                return data.syllabus_tracking;
            }

            upsertSyllabusCatalog(catalog) {
                if (currentUserRole !== 'admin') return false;
                const data = this.getData();
                const merged = mergeSyllabusCatalogSuperset(
                    normalizeSyllabusCatalogShape(data.syllabus_catalog || {}),
                    normalizeSyllabusCatalogShape(catalog || {})
                );
                data.syllabus_catalog = merged;
                data.syllabus_seed_version = SYLLABUS_SEED_VERSION;
                return this.saveData(data);
            }

            upsertSyllabusTrackingRows(rows, options = {}) {
                const data = this.getData();
                data.syllabus_tracking = mergeSyllabusTrackingSuperset(
                    data.syllabus_tracking || [],
                    Array.isArray(rows) ? rows : []
                );
                return this.saveData(data, { allowTeacher: true, ...options });
            }

            getFeeRecords() {
                return this.getData().fee_records || [];
            }

            upsertFeeRecord(record) {
                const data = this.getData();
                data.fee_records = data.fee_records || [];
                const parsedStudentId = parseInt(record && record.studentId, 10);
                const normalizedStudentId = Number.isFinite(parsedStudentId) ? parsedStudentId : record.studentId;
                const normalizedRecord = {
                    ...record,
                    studentId: normalizedStudentId,
                    updated_at: new Date().toISOString()
                };
                if (!normalizedRecord.created_at) {
                    normalizedRecord.created_at = normalizedRecord.updated_at;
                }
                const studentKey = String(normalizedStudentId);
                const existing = data.fee_records.find(item => String(item.studentId) === studentKey);
                if (existing) {
                    Object.assign(existing, normalizedRecord);
                } else {
                    data.fee_records.push(normalizedRecord);
                }
                return this.saveData(data);
            }

            getHomework() {
                return this.getData().homework || [];
            }

            upsertHomework(record) {
                const data = this.getData();
                data.homework = data.homework || [];
                const existing = data.homework.find(item => item.date === record.date && item.studentId === record.studentId);
                if (existing) {
                    Object.assign(existing, record, { updated_at: new Date().toISOString() });
                } else {
                    data.homework.push({
                        id: Date.now() + Math.floor(Math.random() * 1000),
                        ...record,
                        created_at: new Date().toISOString(),
                        updated_at: new Date().toISOString()
                    });
                }
                this.saveData(data, { allowTeacher: true });
            }

            getPostHolderHistory() {
                return this.getData().post_holder_history || [];
            }

            getGroupCRs() {
                return this.getData().group_crs || [];
            }

            applyElectionOutcome(post, candidateId, electedOn) {
                const data = this.getData();
                const samePost = (a, b) => String(a || '').trim().toLowerCase() === String(b || '').trim().toLowerCase();
                const targetCandidateId = parseInt(candidateId, 10);
                const candidate = (data.election_candidates || []).find(c =>
                    parseInt(c.id, 10) === targetCandidateId && samePost(c.post, post)
                );
                if (!candidate) return false;
                const student = (data.students || []).find(s => s.id === candidate.studentId);
                if (!student) return false;
                normalizeStudentMeta(student);

                const normalizedPost = String(post || '').trim();
                const postLower = normalizedPost.toLowerCase();
                if (/^cr\s*-\s*group\s+[a-z]/i.test(normalizedPost)) {
                    const groupMatch = normalizedPost.match(/^cr\s*-\s*group\s+([a-z])/i);
                    const group = groupMatch ? groupMatch[1].toUpperCase() : '';
                    data.group_crs = data.group_crs || [];
                    const existing = data.group_crs.find(item => item.group === group);
                    if (existing) {
                        existing.studentId = candidate.studentId;
                        existing.post = normalizedPost;
                        existing.elected_on = electedOn;
                        existing.status = 'active';
                        existing.tenure_extension_months = 0;
                        existing.tenure_extensions = [];
                    } else {
                        data.group_crs.push({
                            id: Date.now(),
                            group,
                            post: normalizedPost,
                            studentId: candidate.studentId,
                            elected_on: electedOn,
                            status: 'active',
                            tenure_extension_months: 0,
                            tenure_extensions: []
                        });
                    }
                }

                const leadershipPost = (data.leadership || []).find(l => String(l.post || '').toLowerCase() === postLower);
                if (leadershipPost) {
                    leadershipPost.holder = student.base_name || student.name || leadershipPost.holder;
                    leadershipPost.roll = normalizeRoll(student.roll || leadershipPost.roll || '');
                    leadershipPost.elected_on = electedOn;
                    leadershipPost.status = 'active';
                    leadershipPost.tenure_extension_months = 0;
                    leadershipPost.tenure_extensions = [];
                }
                // Use the safe post-holder save pipeline so suffixes + role VETOs reflect everywhere immediately.
                if (typeof savePostHolderData === 'function') {
                    savePostHolderData(data);
                } else {
                    this.saveData(data);
                    applyMonthlyRoleVetoGrants({ persist: true });
                }
                return true;
            }

            getMonths() {
                const data = this.getData();
                const months = new Set();
                data.scores.forEach(s => {
                    const dateKey = normalizeDateKey(s.date);
                    if (!dateKey) return;
                    months.add(String(dateKey).substring(0, 7));
                });
                Object.keys(data.month_students || {}).forEach(monthKey => months.add(monthKey));
                return Array.from(months).sort().reverse();
            }

            getScoresForMonth(month) {
                if (this._monthScoresCache.has(month)) {
                    return this._monthScoresCache.get(month);
                }
                const data = this.getData();
                const monthScores = data.scores.filter(s => {
                    const dateKey = normalizeDateKey(s.date);
                    if (!dateKey) return false;
                    return String(dateKey).substring(0, 7) === month;
                });
                this._monthScoresCache.set(month, monthScores);
                return monthScores;
            }

            getMonthExtraColumns(month) {
                const data = this.getData();
                const cols = data.month_extra_columns && data.month_extra_columns[month];
                return (Array.isArray(cols) ? cols : []).map(col => ({
                    key: String(col.key || '').trim().toLowerCase(),
                    label: String(col.label || '').trim()
                })).filter(col => {
                    if (!col.key || !col.label) return false;
                    const key = String(col.key || '').trim().toLowerCase();
                    const label = String(col.label || '').trim().toLowerCase();
                    if (key === 'buffer' || label === 'buffer') return false;
                    return true;
                });
            }

            getMonthRosterProfiles(month) {
                const data = this.getData();
                const profiles = data.month_roster_profiles && data.month_roster_profiles[month];
                return Array.isArray(profiles) ? profiles : [];
            }

            getStudentMonthExtraValues(student, month) {
                const data = this.getData();
                const extrasByMonth = data.month_student_extras && data.month_student_extras[month];
                if (!extrasByMonth || typeof extrasByMonth !== 'object') return {};
                const rollKey = String(student && student.roll ? student.roll : '').trim().toUpperCase();
                const nameKey = String(student && (student.base_name || student.name) ? (student.base_name || student.name) : '').trim().toUpperCase();
                return extrasByMonth[rollKey] || extrasByMonth[nameKey] || {};
            }

            getMonthlyScoreboard(month) {
                const scores = this.getScoresForMonth(month);
                const students = this.getStudents();
                const extraColumns = this.getMonthExtraColumns(month);
                const profileMap = getMonthRosterProfileMap(month);
                const attendancePenaltyMap = getAttendancePenaltyByDateForMonth(month);
                const scoreByStudent = new Map();
                const datesSet = new Set();
                scores.forEach(score => {
                    const sid = score.studentId;
                    if (!scoreByStudent.has(sid)) scoreByStudent.set(sid, []);
                    scoreByStudent.get(sid).push(score);
                    const date = normalizeDateKey(score.date);
                    if (!date) return;
                    datesSet.add(date);
                });
                const data = this.getData();
                const extrasByMonth = (data.month_student_extras && data.month_student_extras[month]) || {};
                const leadership = data.leadership || [];
                const groupCRs = data.group_crs || [];

                const leaderRolls = new Set();
                const coLeaderRolls = new Set();
                const leaderNames = new Set();
                const coLeaderNames = new Set();
                leadership.forEach(post => {
                    if (normalizePostHolderStatus(post.status) !== 'active') return;
                    const title = String(post && post.post ? post.post : '').toLowerCase();
                    const roll = normalizeRoll(post && post.roll ? post.roll : '');
                    const holderName = normalizeText(post && post.holder ? post.holder : '');
                    const isCoLeader = title.includes('co-leader') || title.includes('(col)');
                    const isLeader = !isCoLeader && (title.includes('leader') || title.includes('(l)')) && !title.includes('opposition');
                    if (isLeader) {
                        if (roll) leaderRolls.add(roll);
                        if (holderName) leaderNames.add(holderName);
                    } else if (isCoLeader) {
                        if (roll) coLeaderRolls.add(roll);
                        if (holderName) coLeaderNames.add(holderName);
                    }
                });

                const crByStudent = new Map();
                groupCRs.forEach(item => {
                    if (item && item.studentId) {
                        crByStudent.set(item.studentId, String(item.group || '').trim().toUpperCase());
                    }
                });

                const resolveLeadershipRole = (student) => {
                    const roll = normalizeRoll(student && student.roll ? student.roll : '');
                    const name = normalizeText(student && (student.base_name || student.name) ? (student.base_name || student.name) : '');
                    if (roll && leaderRolls.has(roll)) return 'leader';
                    if (roll && coLeaderRolls.has(roll)) return 'co-leader';
                    if (name && leaderNames.has(name)) return 'leader';
                    if (name && coLeaderNames.has(name)) return 'co-leader';
                    return '';
                };

                const rows = students.map(student => {
                    if (!isStudentVisibleForMonth(student, month)) {
                        return null;
                    }
                    const displayStudent = getMonthAwareStudent(student, month, profileMap);
                    const studentScores = scoreByStudent.get(student.id) || [];
                    const pointsByDate = {};
                    const starsByDate = {};
                    const starUsageByDate = {};
                    const vetosByDate = {};
                    const notesByDate = {};
                    const hasEntryByDate = {};
                    let monthlyImportedTotal = 0;
                    let hasHistoricalMonthlyTotal = false;
                    const isHistoricalMonth = String(month || '').trim() < '2026-02';
                    studentScores.forEach(s => {
                        const noteText = String(coalesce(safeProp(s, 'notes'), '')).trim();
                        if (isHistoricalMonth) {
                            const noteLow = noteText.toLowerCase();
                            const isExcelTotal = noteLow.startsWith('excel_total_score') || noteLow.startsWith('excel_total_from_dates');
                            const isExcelDaily = noteLow.startsWith('excel_daily_score');
                            const isExcelStar = noteLow.startsWith('excel_star_usage');
                            // Historical months should render strictly from Excel-imported rows only.
                            // This prevents old legacy rows from inflating totals.
                            if (!isExcelTotal && !isExcelDaily && !isExcelStar) {
                                return;
                            }
                        }
                        // Historical import stores workbook monthly totals as synthetic rows.
                        // Keep them in total/rank, but never render as a daily day-15 cell.
                        if (isHistoricalMonth && (
                            noteText.toLowerCase().startsWith('excel_total_score') ||
                            noteText.toLowerCase().startsWith('excel_total_from_dates')
                        )) {
                            monthlyImportedTotal += (parseInt(s.points, 10) || 0);
                            hasHistoricalMonthlyTotal = true;
                            return;
                        }
                        const date = normalizeDateKey(s.date);
                        if (!date) return;
                        hasEntryByDate[date] = true;
                        pointsByDate[date] = (pointsByDate[date] || 0) + (parseInt(s.points, 10) || 0);
                        const starDelta = parseInt(s.stars, 10) || 0;
                        starsByDate[date] = (starsByDate[date] || 0) + starDelta;
                        if (starDelta < 0) {
                            starUsageByDate[date] = (starUsageByDate[date] || 0) + Math.abs(starDelta);
                        }
                        vetosByDate[date] = (vetosByDate[date] || 0) + (parseInt(s.vetos, 10) || 0);
                        if (noteText) {
                            notesByDate[date] = noteText;
                        }
                    });
                    const attendancePenalties = attendancePenaltyMap.get(parseInt(student.id, 10)) || {};
                    Object.entries(attendancePenalties).forEach(([date, penalty]) => {
                        pointsByDate[date] = (pointsByDate[date] || 0) + (parseInt(penalty, 10) || 0);
                        hasEntryByDate[date] = true;
                        const existingNote = String(notesByDate[date] || '').trim();
                        let penaltyNote = `Attendance Penalty (${penalty})`;
                        if ((parseInt(penalty, 10) || 0) === -20) penaltyNote = 'Attendance: Absent (-20)';
                        if ((parseInt(penalty, 10) || 0) === -5) penaltyNote = 'Attendance: Late (-5)';
                        notesByDate[date] = existingNote ? `${existingNote} | ${penaltyNote}` : penaltyNote;
                        datesSet.add(date);
                    });

                    const starOverrides = {};
                    const starClasses = {};
                    const bonusByDate = {};
                    const starDates = new Set([...Object.keys(pointsByDate), ...Object.keys(starsByDate), ...Object.keys(starUsageByDate)]);
                    const isCurrentMonth = String(month || '').trim() === getCurrentMonthKey();
                    // Star +100 bonus on next day only applies from Feb 2026 onwards.
                    // Historical months (Aug 24 – Jan 26) already have the bonus baked
                    // into their Excel values, so applying it again would double-count.
                    const applyStarBonus = String(month || '').trim() >= '2026-02';
                    starDates.forEach(date => {
                        const points = pointsByDate[date] || 0;
                        const usageCount = starUsageByDate[date] || 0;
                        if (usageCount > 0) {
                            const uses = usageCount;
                            const starText = '*'.repeat(uses);
                            starOverrides[date] = starText;
                            starClasses[date] = 'star-used-red';
                            if (points >= -50 && applyStarBonus) {
                                const nextDate = addDays(date, 1);
                                if (nextDate) {
                                    bonusByDate[nextDate] = (bonusByDate[nextDate] || 0) + (100 * uses);
                                    datesSet.add(nextDate);
                                }
                            }
                        }
                    });

                    const rollKey = String(student && student.roll ? student.roll : '').trim().toUpperCase();
                    const nameKey = String(student && (student.base_name || student.name) ? (student.base_name || student.name) : '').trim().toUpperCase();
                    const monthExtras = extrasByMonth[rollKey] || extrasByMonth[nameKey] || {};
                    const extraValues = extraColumns.map(col => ({
                        key: col.key,
                        value: coalesce(monthExtras[col.key], '')
                    }));

                    return {
                        student: displayStudent,
                        rawStudent: student,
                        pointsByDate,
                        starsByDate,
                        vetosByDate,
                        notesByDate,
                        hasEntryByDate,
                        starOverrides,
                        starClasses,
                        bonusByDate,
                        monthlyImportedTotal,
                        hasHistoricalMonthlyTotal,
                        group: getStudentGroup(student),
                        leadershipRole: resolveLeadershipRole(student),
                        isCR: crByStudent.has(student.id),
                        extraValues
                    };
                }).filter(Boolean);

                let allDates = getMonthDateRange(month);
                if (!allDates.length) {
                    allDates = Array.from(datesSet).sort();
                }
                const scoreboard = rows.map(row => {
                    const dailyScores = [];
                    const dailyDisplay = [];
                    const dailyClasses = [];
                    const dailyTitles = [];
                    const bonusDates = row.bonusByDate || {};
                    const starOverrides = row.starOverrides || {};
                    const starClasses = row.starClasses || {};
                    let monthlyStars = 0;
                    let monthlyVetos = 0;
                    Object.values(row.starsByDate || {}).forEach(v => {
                        const delta = parseInt(v, 10) || 0;
                        if (delta > 0) monthlyStars += delta;
                    });
                    Object.values(row.vetosByDate || {}).forEach(v => {
                        const delta = parseInt(v, 10) || 0;
                        if (delta > 0) monthlyVetos += delta;
                    });

                    const isCurrentMonth = String(month || '').trim() === getCurrentMonthKey();
                    allDates.forEach(date => {
                        let points = row.pointsByDate[date] || 0;
                        const starOverride = starOverrides[date];
                        const starClass = starClasses[date] || '';
                        const starAwardCount = Math.max(0, parseInt(safeProp(row.starsByDate, date), 10) || 0);
                        if (starOverride) {
                            points = 0;
                        }
                        if (bonusDates[date]) {
                            points += bonusDates[date];
                        }

                        const vetoDelta = parseInt(safeProp(row.vetosByDate, date), 10) || 0;
                        const noteText = String(coalesce(safeProp(row.notesByDate, date), '')).trim();

                        let cellDisplay = null;
                        let cellClass = '';
                        if (starOverride) {
                            cellDisplay = starOverride;
                            cellClass = `score-cell ${starClass}`;
                        } else if (vetoDelta < 0) {
                            points = 0;
                            cellDisplay = 'V';
                            cellClass = 'score-cell veto-used';
                        }

                        dailyScores.push(points);
                        if (cellDisplay) {
                            dailyDisplay.push(cellDisplay);
                            dailyClasses.push(cellClass);
                            if (starOverride) {
                                dailyTitles.push(noteText || '');
                            } else {
                                dailyTitles.push(noteText || 'VETO used');
                            }
                        } else {
                            const hasEntry = !!safeProp(row.hasEntryByDate, date);
                            const displayValue = points !== 0 ? points : (hasEntry ? '0' : '-');
                            let scoreClass = '';
                            if (!bonusDates[date]) {
                                scoreClass = points > 0
                                    ? 'score-cell positive'
                                    : points < 0
                                        ? 'score-cell negative'
                                        : (hasEntry ? 'score-cell entered-zero' : 'score-cell');
                            } else {
                                scoreClass = 'score-cell bonus-neutral';
                            }
                            const starText = (starAwardCount > 0 && isCurrentMonth)
                                ? (starAwardCount <= 3 ? '*'.repeat(starAwardCount) : `*x${starAwardCount}`)
                                : '';
                            const displayWithStars = starText ? `${displayValue} <span class="star-added">${starText}</span>` : displayValue;
                            const titleWithStars = starAwardCount > 0
                                ? (noteText ? `${noteText} | Stars awarded: +${starAwardCount}` : `Stars awarded: +${starAwardCount}`)
                                : (noteText || '');
                            if (starAwardCount > 0 && isCurrentMonth) {
                                scoreClass = `${scoreClass} star-awarded star-awarded-green`.trim();
                            }
                            dailyDisplay.push(displayWithStars);
                            dailyClasses.push(scoreClass);
                            dailyTitles.push(titleWithStars);
                        }
                    });

                    const dailySum = dailyScores.reduce((sum, p) => sum + p, 0);
                    let total = dailySum + (parseInt(row.monthlyImportedTotal, 10) || 0);
                    // For historical months, workbook total is authoritative for ranking/total.
                    if (String(month || '').trim() < '2026-02' && row.hasHistoricalMonthlyTotal) {
                        total = parseInt(row.monthlyImportedTotal, 10) || 0;
                    }
                    row.rawStudent.computed_total_score = total;
                    return {
                        student: row.student,
                        dailyScores,
                        dailyDisplay,
                        dailyClasses,
                        dailyTitles,
                        dates: allDates,
                        total,
                        monthlyStars,
                        monthlyVetos,
                        starsByDate: row.starsByDate || {},
                        vetosByDate: row.vetosByDate || {},
                        extraValues: row.extraValues || []
                    };
                }).sort((a, b) => b.total - a.total);

                return scoreboard;
            }

            deleteStudent(studentId) {
                const data = this.getData();
                data.students = data.students.filter(s => s.id !== studentId);
                data.scores = data.scores.filter(s => s.studentId !== studentId);
                data.parties = (data.parties || []).map(party => ({
                    ...party,
                    members: (party.members || []).filter(m => m.studentId !== studentId)
                }));
                data.class_reps = (data.class_reps || []).filter(rep => rep.studentId !== studentId);
                data.election_candidates = (data.election_candidates || []).filter(c => c.studentId !== studentId);
                data.election_votes = (data.election_votes || []).filter(v => v.candidateId && data.election_candidates.some(c => c.id === v.candidateId));
                this.saveData(data);
            }

            clearAll() {
                localStorage.removeItem(this.storageKey);
                this._cacheData = null;
                this._monthScoresCache.clear();
                this.init();
            }
        }

        // Initialize database
        const db = new ScoreboardDB();
        let editingPartyId = null;
        let activePartyId = null;
        let editingPartyMemberId = null;
        let editingLeadershipId = null;
        let editingClassRepId = null;
        let editingTeacherId = null;
        let editingResourceItemId = null;
        const voteSession = {
            verified: false,
            partyId: null,
            post: null
        };
        const groupVoteSession = {
            studentId: null,
            post: null
        };

        // ============================================
        // UI FUNCTIONS
        // ============================================

        // --- Error boundary + requestIdleCallback helpers ---

        // Runs fn() and catches any throw — shows a non-blocking error card inside
        // the affected tab so one broken tab cannot crash the whole session.
        function _safeRender(fn, tabName) {
            try {
                fn();
            } catch (err) {
                console.error('[EA render error: ' + tabName + ']', err);
                const tabEl = document.getElementById(tabName + '-tab');
                if (tabEl && !tabEl.querySelector('.render-error-card')) {
                    const card = document.createElement('div');
                    card.className = 'render-error-card';
                    card.innerHTML = '<b>Display error in this section.</b> Your data is intact. '
                        + '<a href="#" onclick="location.reload();return false;">Reload page</a> to fix.';
                    tabEl.insertBefore(card, tabEl.firstChild);
                }
            }
        }

        // Uses requestIdleCallback when available; falls back to a short setTimeout.
        // Use for tabs that don't need to paint instantly on click.
        const _idle = typeof requestIdleCallback === 'function'
            ? (fn) => requestIdleCallback(fn, { timeout: 400 })
            : (fn) => setTimeout(fn, 60);

        function switchTab(tabName, evt) {
            if (tabName !== 'tools' && localRosterNeedsRecovery()) {
                rosterRecoveryQueuedTab = tabName || 'scoreboard';
                // Force user into a safe recovery view instead of rendering a corrupt tiny roster.
                document.querySelectorAll('.tab-content').forEach(tab => tab.classList.add('hidden'));
                document.querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
                const scoreboardTab = document.getElementById('scoreboard-tab');
                if (scoreboardTab) scoreboardTab.classList.remove('hidden');
                const scoreboardBtn = document.querySelector(`.tab-button[onclick*="switchTab('scoreboard')"]`);
                if (scoreboardBtn) scoreboardBtn.classList.add('active');
                renderRosterRecoveryPlaceholder('Recovering safe roster from Master Server...');
                attemptRosterRecovery();
                return;
            }

            if (!isTabAccessibleForCurrentRole(tabName)) {
                tabName = 'scoreboard';
            }

            // Hide all tabs (remove any lingering entrance class too)
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.add('hidden');
                tab.classList.remove('tab-entering');
            });

            // Remove active from all buttons
            document.querySelectorAll('.tab-button').forEach(btn => {
                btn.classList.remove('active');
            });

            // Show selected tab with iOS slide-up entrance
            const tabId = `${tabName}-tab`;
            const newTabEl = document.getElementById(tabId);
            if (newTabEl) {
                newTabEl.classList.remove('hidden');
                // Trigger iOS entrance animation without synchronous layout thrash.
                // Record Score needs faster response; skip the entrance animation there.
                if (tabName !== 'add-score') {
                    newTabEl.classList.remove('tab-entering');
                    requestAnimationFrame(() => {
                        newTabEl.classList.add('tab-entering');
                    });
                    newTabEl.addEventListener('animationend', () => newTabEl.classList.remove('tab-entering'), { once: true });
                }
                // Ensure Record Score opens aligned at the top (avoid retained scroll offset).
                if (tabName === 'add-score') {
                    requestAnimationFrame(() => {
                        newTabEl.scrollTop = 0;
                        window.scrollTo({ top: 0, left: 0, behavior: 'auto' });
                    });
                }
            }

            // Add active to clicked button
            const targetButton = evt && evt.target ? evt.target.closest('.tab-button') : document.querySelector(`.tab-button[onclick*="switchTab('${tabName}')"]`);
            if (targetButton) {
                targetButton.classList.add('active');
            }

            // Initialize tab-specific content — all content loads are synchronous so
            // the tab is never left blank. _safeRender wraps each call in a try/catch
            // so a broken tab cannot crash the rest of the session.
            if      (tabName === 'scoreboard')       _safeRender(loadScoreboard, 'scoreboard');
            else if (tabName === 'add-score')        _safeRender(initScoreForm, 'add-score');
            else if (tabName === 'students')         _safeRender(loadStudents, 'students');
            else if (tabName === 'fees')             _safeRender(loadFeesTab, 'fees');
            else if (tabName === 'resources')        _safeRender(loadResourcesTab, 'resources');
            else if (tabName === 'syllabus')         _safeRender(loadSyllabusTab, 'syllabus');
            else if (tabName === 'attendance')       _safeRender(loadAttendanceTab, 'attendance');
            else if (tabName === 'cr')               _safeRender(loadCRTab, 'cr');
            else if (tabName === 'leadership')       _safeRender(loadLeadership, 'leadership');
            else if (tabName === 'office')           _safeRender(loadOfficeHolders, 'office');
            else if (tabName === 'party')            _safeRender(loadParties, 'party');
            else if (tabName === 'ranking')          _safeRender(initRankingForm, 'ranking');
            else if (tabName === 'group-scoreboard') _safeRender(loadGroupScoreboard, 'group-scoreboard');
            else if (tabName === 'voting')           _safeRender(loadVotingTab, 'voting');
            else if (tabName === 'teachers')         _safeRender(loadTeachersTab, 'teachers');
            else if (tabName === 'teacher-voting')   _safeRender(loadTeacherVotingTab, 'teacher-voting');
            else if (tabName === 'appeals')          _safeRender(loadAppealsTab, 'appeals');
            else if (tabName === 'notifications')    _safeRender(loadNotificationsTab, 'notifications');
            else if (tabName === 'activity-log')     _safeRender(loadActivityLogTab, 'activity-log');
            else if (tabName === 'profile')          _safeRender(loadProfileTab, 'profile');
            else if (tabName === 'homework')         _safeRender(loadHomeworkTab, 'homework');
            else if (tabName === 'good-conduct')     _safeRender(renderGoodConductBadge, 'good-conduct');
            else if (tabName === 'tools')            _safeRender(loadRestorePoints, 'tools');
            // Badge updates are low-priority background ops — safe to defer via _idle.
            _idle(() => { updateAppealsTabNotification(); updateHomeworkTabNotification(); updateNotificationsTabNotification(); });
            localStorage.setItem(ACTIVE_TAB_KEY, tabName);
        }

        function toggleColumn(key, isVisible) {
            columnVisibility[key] = isVisible;
            applyColumnVisibility();
        }

        function applyColumnVisibility() {
            Object.entries(columnVisibility).forEach(([key, visible]) => {
                document.querySelectorAll(`[data-col="${key}"]`).forEach(el => {
                    el.classList.toggle('col-hidden', !visible);
                });
            });
            const feesToggle = document.getElementById('toggleFees');
            if (feesToggle) {
                feesToggle.checked = columnVisibility.fees;
            }
            const awfToggle = document.getElementById('toggleAWF');
            if (awfToggle) {
                awfToggle.checked = columnVisibility.awf;
            }
            autoAdjustTableFonts();
            setTimeout(syncScoreboardDualScrollbars, 0);
        }

        function applyRecordColumnsVisibility() {
            const toggles = {
                'record-group': !!document.getElementById('recordShowGroup')?.checked,
                'record-vote-power': !!document.getElementById('recordShowVotePower')?.checked,
                'record-stars': !!document.getElementById('recordShowStars')?.checked,
                'record-vetos': !!document.getElementById('recordShowVetos')?.checked,
                'record-status': !!document.getElementById('recordShowStatus')?.checked
            };
            Object.entries(toggles).forEach(([key, visible]) => {
                document.querySelectorAll(`#recordStudentsTable [data-col="${key}"]`).forEach(el => {
                    el.classList.toggle('col-hidden', !visible);
                });
            });
            autoAdjustTableFonts();
        }

        function autoAdjustSingleTableFont(table) {
            if (!table) return;
            const tabContent = table.closest('.tab-content');
            if (tabContent && tabContent.classList.contains('hidden')) return;
            const wrapper = table.closest('.scoreboard-scroll');
            if (!wrapper) return;
            const thCount = table.querySelectorAll('thead th').length || 8;
            const width = wrapper.clientWidth || window.innerWidth;
            const wideScreenBoost = width >= 1600 ? 1.12 : 1;
            const factor = Math.max(0.82, Math.min(1.28, (width / Math.max(960, thCount * 90)))) * wideScreenBoost;
            const size = Math.max(12, Math.min(20, Math.round(13 * factor)));
            // Skip style writes when layout signature is unchanged to avoid reflow churn.
            const widthBucket = Math.round(width / 16);
            const sig = `${thCount}|${widthBucket}|${size}`;
            if (table.dataset.eaFontSig === sig) return;
            table.dataset.eaFontSig = sig;
            table.style.fontSize = `${size}px`;
        }

        function autoAdjustTableFontsNow() {
            ['scoreboardTable', 'recordStudentsTable', 'studentsList', 'duplicateRollTable', 'feesTable', 'resourceCabinetTable', 'resourceRequestsTable', 'resourceTransactionsTable', 'resourceEligibilityTable', 'syllabusChapterTable', 'groupScoreboardTable', 'groupRosterTable', 'crGroupTable', 'appealsTable', 'attendanceTable', 'attendanceReportTable', 'attendanceStudentReportTable', 'homeworkTable', 'postHistoryTable', 'profilePostHistoryTable']
                .forEach(id => autoAdjustSingleTableFont(document.getElementById(id)));
        }

        let autoFontAdjustTimer = null;
        let autoFontAdjustRaf = 0;
        function autoAdjustTableFonts() {
            if (document.hidden) return;
            if (autoFontAdjustTimer) clearTimeout(autoFontAdjustTimer);
            if (autoFontAdjustRaf) cancelAnimationFrame(autoFontAdjustRaf);
            autoFontAdjustTimer = setTimeout(() => {
                autoFontAdjustRaf = requestAnimationFrame(() => {
                    autoAdjustTableFontsNow();
                    autoFontAdjustRaf = 0;
                });
                autoFontAdjustTimer = null;
            }, 60);
        }

        function getActiveTabName() {
            const activeButton = document.querySelector('.tab-button.active');
            if (!activeButton) return 'scoreboard';
            const onclickText = String(activeButton.getAttribute('onclick') || '');
            const match = onclickText.match(/switchTab\('([^']+)'\)/);
            return match ? match[1] : 'scoreboard';
        }

        function refreshActiveTabFromSync(options = {}) {
            const passive = options.passive === true;
            const tabName = getActiveTabName();
            if (passive) {
                window.__EA_SUPPRESS_TABLE_ANIM_UNTIL = Date.now() + 1800;
            }
            // Passive sync (auto/background) should not cause heavy full-tab re-renders
            // on every snapshot. Keep always-fresh behavior for core live tabs only.
            if (passive) {
                if (tabName === 'scoreboard') loadScoreboard();
                else if (tabName === 'add-score') {
                    // Mobile: avoid periodic DOM rebuild while user scrolls long student list.
                    if (!isMobileViewport()) refreshRecordScoreTabFromSync();
                }
                else if (tabName === 'attendance') refreshAttendanceTabFromSync();
                else if (tabName === 'homework') loadHomeworkTab();
            } else {
                if (tabName === 'scoreboard') loadScoreboard();
                else if (tabName === 'add-score') refreshRecordScoreTabFromSync();
                else if (tabName === 'students') loadStudents();
                else if (tabName === 'fees') loadFeesTab();
                else if (tabName === 'resources') loadResourcesTab();
                else if (tabName === 'syllabus') loadSyllabusTab();
                else if (tabName === 'ranking') initRankingForm();
                else if (tabName === 'group-scoreboard') loadGroupScoreboard();
                else if (tabName === 'cr') loadCRTab();
                else if (tabName === 'teachers') loadTeachersTab();
                else if (tabName === 'teacher-voting') loadTeacherVotingTab();
                else if (tabName === 'party') loadParties();
                else if (tabName === 'office') loadOfficeHolders();
                else if (tabName === 'voting') loadVotingTab();
                else if (tabName === 'appeals') loadAppealsTab();
                else if (tabName === 'notifications') loadNotificationsTab();
                else if (tabName === 'activity-log') loadActivityLogTab();
                else if (tabName === 'attendance') refreshAttendanceTabFromSync();
                else if (tabName === 'profile') loadProfileTab();
                else if (tabName === 'homework') loadHomeworkTab();
                else if (tabName === 'leadership') loadLeadership();
            }
            // When not on scoreboard, silently refresh it in background so penalty
            // and score changes are reflected immediately when the user switches to it.
            if (!passive && tabName !== 'scoreboard' && !document.hidden) {
                setTimeout(loadScoreboard, 400);
            }
            updateAppealsTabNotification();
            updateHomeworkTabNotification();
            updateNotificationsTabNotification();
            if (!passive) {
                autoAdjustTableFonts();
            }
        }

        let activeTabRefreshTimer = null;
        let lastPassiveSyncRefreshAt = 0;
        function scheduleActiveTabRefreshFromSync(delayMs = 90, options = {}) {
            const passive = options.passive === true;
            if (passive) {
                const now = Date.now();
                // Guard against jitter when snapshots arrive in bursts (SSE + polling).
                const passiveMinGap = isMobileViewport() ? 4000 : 1800;
                if (now - lastPassiveSyncRefreshAt < passiveMinGap) return;
                lastPassiveSyncRefreshAt = now;
            }
            if (activeTabRefreshTimer) {
                clearTimeout(activeTabRefreshTimer);
            }
            const wait = Math.max(0, parseInt(delayMs, 10) || 0);
            activeTabRefreshTimer = setTimeout(() => {
                activeTabRefreshTimer = null;
                refreshActiveTabFromSync({ passive });
            }, wait);
        }

        function getCurrentMonthKey() {
            return formatDateKey(new Date()).substring(0, 7);
        }

        function getMonthDateBounds(monthKey) {
            const value = String(monthKey || '').trim();
            if (!/^\d{4}-\d{2}$/.test(value)) {
                return { min: '', max: '' };
            }
            const [yearStr, monthStr] = value.split('-');
            const year = parseInt(yearStr, 10);
            const monthIndex = (parseInt(monthStr, 10) || 0) - 1;
            if (!Number.isFinite(year) || monthIndex < 0 || monthIndex > 11) {
                return { min: '', max: '' };
            }
            const min = formatDateKey(new Date(year, monthIndex, 1));
            const max = formatDateKey(new Date(year, monthIndex + 1, 0));
            return { min, max };
        }

        function enforceTeacherCurrentMonthOnlyUi() {
            if (currentUserRole !== 'teacher') return;
            const currentMonth = getCurrentMonthKey();
            const bounds = getMonthDateBounds(currentMonth);

            const scoreMonth = document.getElementById('scoreMonth');
            if (scoreMonth) {
                if (String(scoreMonth.value || '') !== currentMonth) {
                    scoreMonth.value = currentMonth;
                }
                scoreMonth.disabled = true;
            }
            const scoreDate = document.getElementById('scoreDate');
            if (scoreDate) {
                if (bounds.min) scoreDate.min = bounds.min;
                if (bounds.max) scoreDate.max = bounds.max;
                if (!scoreDate.value) {
                    scoreDate.value = formatDateKey(new Date());
                }
                if (!String(scoreDate.value || '').startsWith(currentMonth)) {
                    scoreDate.value = bounds.min || scoreDate.value;
                }
            }

            const attendanceMonth = document.getElementById('attendanceMonth');
            if (attendanceMonth) {
                if (String(attendanceMonth.value || '') !== currentMonth) {
                    attendanceMonth.value = currentMonth;
                }
                attendanceMonth.disabled = true;
            }
            const attendanceDate = document.getElementById('attendanceDate');
            if (attendanceDate) {
                if (bounds.min) attendanceDate.min = bounds.min;
                if (bounds.max) attendanceDate.max = bounds.max;
                if (!attendanceDate.value) {
                    attendanceDate.value = formatDateKey(new Date());
                }
                if (!String(attendanceDate.value || '').startsWith(currentMonth)) {
                    attendanceDate.value = bounds.min || attendanceDate.value;
                }
            }

            const bulkCard = document.getElementById('bulkPastAttendanceCard');
            if (bulkCard) {
                bulkCard.style.display = 'none';
            }
        }

        function teacherValidateCurrentMonth(dateValue, monthValue, label = 'This action') {
            if (currentUserRole !== 'teacher') return true;
            const dateKey = String(dateValue || '').trim();
            const monthKey = String(monthValue || '').trim() || (dateKey ? dateKey.substring(0, 7) : '');
            if (!dateKey) {
                showAlert(`${label} requires a valid date.`, 'warning');
                return false;
            }
            if (monthKey && monthKey !== dateKey.substring(0, 7)) {
                showAlert(`${label} date/month mismatch. Please align the selected month and date.`, 'warning');
                return false;
            }
            const target = new Date(`${dateKey}T00:00:00`);
            if (Number.isNaN(target.getTime())) {
                showAlert(`${label} requires a valid date.`, 'warning');
                return false;
            }
            const today = new Date();
            today.setHours(0, 0, 0, 0);
            const minDate = new Date(today);
            minDate.setDate(today.getDate() - 2);
            if (target < minDate || target > today) {
                const fmt = d => d.toISOString().slice(0, 10);
                showAlert(`${label} is allowed only for dates from ${fmt(minDate)} to ${fmt(today)}.`, 'warning');
                return false;
            }
            return true;
        }

        function isStudentVisibleForMonth(student, month) {
            const currentMonth = getCurrentMonthKey();
            const data = db.getData();
            const roster = data.month_students && data.month_students[month];
            // Read stored profiles and supplement with the hardcoded authoritative roster when stored
            // data has been partially corrupted (e.g. a partial import overwrote the full roster).
            // This mirrors getMonthRosterProfileMap which already does the same FEB26 fallback.
            let rosterProfiles = data.month_roster_profiles && data.month_roster_profiles[month];
            if (String(month).trim() === '2026-02' && Array.isArray(FEB26_STUDENT_ROSTER)) {
                const savedRolls = new Set(
                    (Array.isArray(rosterProfiles) ? rosterProfiles : [])
                        .map(p => p && normalizeRosterValue(p.roll)).filter(Boolean)
                );
                const supplemented = Array.isArray(rosterProfiles) ? [...rosterProfiles] : [];
                FEB26_STUDENT_ROSTER.forEach(p => {
                    const roll = normalizeRosterValue(p.roll || '');
                    if (roll && !savedRolls.has(roll)) supplemented.push(p);
                });
                rosterProfiles = supplemented;
            }
            const rollKey = String(student.roll || '').trim().toUpperCase();
            const nameKey = String(student.base_name || student.name || '').trim().toUpperCase();
            const hasProfileRoster = Array.isArray(rosterProfiles) && rosterProfiles.length > 0;
            const hasLegacyRoster = Array.isArray(roster) && roster.length > 0;
            if (month === currentMonth && (hasProfileRoster || hasLegacyRoster)) {
                const rosterRolls = new Set();
                (Array.isArray(roster) ? roster : []).forEach(value => {
                    const roll = normalizeRosterValue(value);
                    if (roll.startsWith('EA')) rosterRolls.add(roll);
                });
                (Array.isArray(rosterProfiles) ? rosterProfiles : []).forEach(profile => {
                    if (!profile || typeof profile !== 'object') return;
                    const roll = normalizeRosterValue(profile.roll);
                    if (roll.startsWith('EA')) rosterRolls.add(roll);
                });
                const activeCount = Array.isArray(data.students)
                    ? data.students.filter(item => item && item.active !== false).length
                    : 0;
                if (rosterRolls.size > 0 && rosterRolls.size < MIN_SAFE_STUDENT_ROSTER && activeCount >= MIN_SAFE_STUDENT_ROSTER) {
                    return student.active !== false;
                }
            }
            const inProfileRoster = hasProfileRoster && rosterProfiles.some(profile => {
                const profileRoll = normalizeRosterValue(profile.roll);
                if (profileRoll && rollKey) {
                    return profileRoll === rollKey;
                }
                const profileName = normalizeText(profile.base_name || profile.name);
                const studentName = normalizeText(student.base_name || student.name);
                return profileName && studentName && profileName === studentName;
            });
            const inLegacyRoster = hasLegacyRoster && (rollKey ? roster.includes(rollKey) : (nameKey && roster.includes(nameKey)));
            if (month === currentMonth) {
                if (hasProfileRoster) {
                    // Current month scoreboard must still respect deactivation.
                    // Roster decides inclusion set; active flag decides visibility.
                    return (inProfileRoster || inLegacyRoster) && student.active !== false;
                }
                if (roster && roster.length) {
                    return inLegacyRoster && student.active !== false;
                }
                // No roster at all: fall back to the active flag.
                return student.active !== false;
            }
            if (hasProfileRoster) {
                return inProfileRoster || inLegacyRoster;
            }
            if (roster && roster.length) {
                return inLegacyRoster;
            }
            return (data.scores || []).some(score => score.studentId === student.id && score.month === month);
        }

        function isVisibleOutsideScoreboard(student) {
            return student && student.active !== false;
        }

        function getAttendancePenaltyByDateForMonth(month) {
            const targetMonth = String(month || getCurrentMonthKey()).trim();
            const records = db.getAttendance().filter(record => String(record.date || '').startsWith(targetMonth));
            const latestByKey = new Map();
            records.forEach(record => {
                const studentId = parseInt(record.studentId, 10);
                const dateKey = String(record.date || '').trim();
                if (!studentId || !dateKey) return;
                const key = `${studentId}|${dateKey}`;
                const prev = latestByKey.get(key);
                const prevStamp = Date.parse(safeProp(prev, 'updated_at') || safeProp(prev, 'created_at') || '') || 0;
                const nextStamp = Date.parse(safeProp(record, 'updated_at') || safeProp(record, 'created_at') || '') || 0;
                if (!prev || nextStamp >= prevStamp) {
                    latestByKey.set(key, record);
                }
            });

            const penaltyByStudent = new Map();
            latestByKey.forEach(record => {
                const status = normalizeAttendanceStatus(record.status);
                let penaltyPoints = 0;
                if (status === 'absent') penaltyPoints = -20;
                else if (status === 'late') penaltyPoints = -5;
                if (!penaltyPoints) return;
                const studentId = parseInt(record.studentId, 10);
                const dateKey = String(record.date || '').trim();
                if (!studentId || !dateKey) return;
                if (!penaltyByStudent.has(studentId)) penaltyByStudent.set(studentId, {});
                penaltyByStudent.get(studentId)[dateKey] = penaltyPoints;
            });
            return penaltyByStudent;
        }

        function getStudentMonthTotal(studentId, month) {
            const targetMonth = month || getCurrentMonthKey();
            const scores = db.getScoresForMonth(targetMonth).filter(score => score.studentId === studentId);
            const scoreTotal = scores.reduce((sum, score) => sum + (parseInt(score.points, 10) || 0), 0);
            const attendancePenaltyMap = getAttendancePenaltyByDateForMonth(targetMonth);
            const penaltyByDate = attendancePenaltyMap.get(parseInt(studentId, 10)) || {};
            const attendancePenaltyTotal = Object.values(penaltyByDate).reduce((sum, value) => sum + (parseInt(value, 10) || 0), 0);
            return scoreTotal + attendancePenaltyTotal;
        }

        function getStudentMonthPositiveDeltaTotal(studentId, monthKey, field) {
            const sid = parseInt(studentId, 10);
            const month = String(monthKey || '').trim();
            const key = String(field || '').trim().toLowerCase();
            if (!sid || !month || (key !== 'stars' && key !== 'vetos')) return 0;
            return db.getScoresForMonth(month)
                .filter(item => parseInt(item.studentId, 10) === sid)
                .reduce((sum, item) => {
                    const delta = parseInt(item[key], 10) || 0;
                    return sum + (delta > 0 ? delta : 0);
                }, 0);
        }

        function getStudentMonthNegativeDeltaTotal(studentId, monthKey, field) {
            const sid = parseInt(studentId, 10);
            const month = String(monthKey || '').trim();
            const key = String(field || '').trim().toLowerCase();
            if (!sid || !month || (key !== 'stars' && key !== 'vetos')) return 0;
            return db.getScoresForMonth(month)
                .filter(item => parseInt(item.studentId, 10) === sid)
                .reduce((sum, item) => {
                    const delta = parseInt(item[key], 10) || 0;
                    return sum + (delta < 0 ? Math.abs(delta) : 0);
                }, 0);
        }

        function getStudentMonthStarAwardTotal(studentId, monthKey) {
            return getStudentMonthPositiveDeltaTotal(studentId, monthKey, 'stars');
        }

        function getStudentMonthVetoAwardTotal(studentId, monthKey) {
            return getStudentMonthPositiveDeltaTotal(studentId, monthKey, 'vetos');
        }

        function formatRollDisplay(roll) {
            const value = String(roll || '').trim();
            return isValidRollNo(value) ? value.toUpperCase() : '';
        }

        function getMonthRosterProfileMap(month) {
            const profiles = db.getMonthRosterProfiles(month || '');
            const map = new Map();
            const activeByRoll = new Map();
            const studentsByRoll = new Map();
            db.getStudents()
                .forEach(student => {
                    const roll = normalizeRoll(student.roll);
                    if (!roll) return;
                    if (!studentsByRoll.has(roll)) studentsByRoll.set(roll, []);
                    studentsByRoll.get(roll).push(student);
                    if (student.active !== false && !activeByRoll.has(roll)) {
                        activeByRoll.set(roll, student);
                    }
                });
            (profiles || []).forEach(profile => {
                const roll = normalizeRoll(profile && profile.roll);
                if (!roll) return;
                const normalizedProfile = {
                    ...profile,
                    roll,
                    base_name: String(safeProp(profile, 'base_name') || safeProp(profile, 'name') || '').trim() || ''
                };
                if (!map.has(roll)) {
                    map.set(roll, normalizedProfile);
                    return;
                }

                const existing = map.get(roll);
                const activeStudent = activeByRoll.get(roll);
                const existingName = normalizeText(safeProp(existing, 'base_name') || safeProp(existing, 'name'));
                const nextName = normalizeText(safeProp(normalizedProfile, 'base_name') || safeProp(normalizedProfile, 'name'));
                const activeName = normalizeText(safeProp(activeStudent, 'base_name') || safeProp(activeStudent, 'name'));

                if (activeName && nextName === activeName && existingName !== activeName) {
                    map.set(roll, normalizedProfile);
                    return;
                }
                // Default to last visible profile when duplicates exist for same roll.
                map.set(roll, normalizedProfile);
            });

            const data = db.getData();
            const monthRoster = ((data.month_students && data.month_students[month]) || [])
                .map(normalizeRosterValue)
                .filter(Boolean);
            monthRoster.forEach(rosterValue => {
                const roll = normalizeRoll(rosterValue);
                if (!roll || map.has(roll)) return;
                const candidates = studentsByRoll.get(roll) || [];
                const chosen = candidates.find(candidate => candidate.active !== false) || candidates[0];
                if (!chosen) return;
                const fallbackName = String(chosen.base_name || chosen.name || '').trim();
                if (!fallbackName) return;
                map.set(roll, {
                    roll,
                    name: String(chosen.raw_name || chosen.name || fallbackName).trim() || fallbackName,
                    base_name: fallbackName,
                    class: parseInt(chosen.class, 10) || null
                });
            });

            const hasRosterProfiles = (profiles || []).length > 0;
            if (!hasRosterProfiles && String(month || '') === getCurrentMonthKey()) {
                activeByRoll.forEach((student, roll) => {
                    const activeName = String(student.base_name || student.name || '').trim();
                    if (!activeName) return;
                    const current = map.get(roll);
                    const currentName = normalizeText(safeProp(current, 'base_name') || safeProp(current, 'name'));
                    const expectedName = normalizeText(activeName);
                    if (!current || currentName !== expectedName) {
                        map.set(roll, {
                            roll,
                            name: activeName,
                            base_name: activeName,
                            class: student.class || null
                        });
                    }
                });
            }

            if (String(month || '') === '2026-02' || String(month || '') === '2026-2') {
                FEB26_STUDENT_ROSTER.forEach(profile => {
                    const roll = normalizeRoll(profile.roll);
                    if (!roll) return;
                    map.set(roll, {
                        roll,
                        name: String(profile.name || '').trim() || '',
                        base_name: extractNameMeta(String(profile.name || '').trim()).baseName,
                        class: parseInt(profile.class, 10) || null
                    });
                });
            }
            return map;
        }

        function getMonthAwareStudent(student, month, profileMap = null) {
            if (!student) return student;
            const effectiveMap = profileMap || getMonthRosterProfileMap(month);
            const currentRoll = normalizeRoll(student.roll);
            let profile = effectiveMap.get(currentRoll);
            if (!profile) {
                const targetName = normalizeText(student.base_name || student.name || '');
                if (targetName) {
                    for (const candidate of effectiveMap.values()) {
                        const candidateName = normalizeText(candidate.base_name || candidate.name || '');
                        if (candidateName && candidateName === targetName) {
                            profile = candidate;
                            break;
                        }
                    }
                }
            }
            if (!profile) return student;
            const profileRoll = normalizeRoll(profile.roll) || currentRoll;
            const parsed = extractNameMeta(profile.base_name || profile.name || '');
            const displayName = String(profile.base_name || parsed.baseName || student.base_name || student.name || '').trim();
            if (!displayName) return student;
            const monthClass = parseInt(profile.class, 10);
            return {
                ...student,
                roll: profileRoll || student.roll,
                class: Number.isNaN(monthClass) ? student.class : monthClass,
                group: deriveGroupFromRoll(profileRoll || student.roll) || student.group,
                name: displayName,
                base_name: displayName,
                raw_name: String(profile.name || displayName),
                __month_roll: profileRoll || student.roll,
                __month_name: displayName,
                __month_group: deriveGroupFromRoll(profileRoll || student.roll) || student.group || '',
                __month_class: Number.isNaN(monthClass) ? student.class : monthClass,
                __month_star_count: parseInt(profile.month_star_count, 10) || 0,
                __month_veto_count: parseInt(profile.month_veto_count, 10) || 0,
                __month_designations: Array.isArray(profile.month_designations) ? profile.month_designations : []
            };
        }

        function populateScoreGroupFilter() {
            const groupFilterSelect = document.getElementById('scoreGroupFilter');
            const listGroupFilter = document.getElementById('scoreGroupFilterList');
            if (!groupFilterSelect) return;
            const date = getElementValue('scoreDate');
            let month = getElementValue('scoreMonth') || (date ? date.substring(0, 7) : getCurrentMonthKey());
            if (currentUserRole === 'teacher' && date) {
                month = String(date).substring(0, 7);
                const monthEl = document.getElementById('scoreMonth');
                if (monthEl) monthEl.value = month;
            }
            const statusFilter = getElementValue('scoreStatusFilter') || 'active';
            const selected = groupFilterSelect.value || 'all';
            const groups = Array.from(new Set(
                filterStudentsByStatus(db.getStudents(), statusFilter, month)
                    .map(student => getStudentGroup(student))
                    .filter(Boolean)
            )).sort((a, b) => String(a).localeCompare(String(b)));
            if (selected !== 'all' && !groups.includes(selected)) {
                groups.unshift(selected);
            }
            groupFilterSelect.innerHTML = '<option value="all">All Groups</option>' +
                groups.map(group => `<option value="${group}">Group ${group}</option>`).join('');
            groupFilterSelect.value = selected || 'all';
            if (listGroupFilter) {
                const listSelected = listGroupFilter.value || groupFilterSelect.value || 'all';
                if (listSelected !== 'all' && !groups.includes(listSelected)) {
                    groups.unshift(listSelected);
                }
                listGroupFilter.innerHTML = groupFilterSelect.innerHTML;
                listGroupFilter.value = listSelected || 'all';
            }
        }

        function syncRecordScoreGroupFilter(syncClass = false) {
            const groupFilterSelect = document.getElementById('scoreGroupFilter');
            const listGroupFilter = document.getElementById('scoreGroupFilterList');
            if (groupFilterSelect && listGroupFilter) {
                groupFilterSelect.value = listGroupFilter.value || 'all';
            }
            if (syncClass) {
                const classSelect = document.getElementById('scoreClassFilter');
                const listClassSelect = document.getElementById('scoreClassFilterList');
                if (classSelect && listClassSelect) {
                    classSelect.value = listClassSelect.value || '';
                }
            }
            updateScoreStudentOptions(true);
        }

        function canEditData(options = {}) {
            const role = normalizeUserRole(currentUserRole);
            if (role === 'admin') return true;
            if (role === 'teacher') return options.allowTeacher === true;
            if (role === 'student') return options.allowStudent === true;
            return false;
        }

        function setTabVisibility(tabName, visible) {
            const button = document.querySelector(`.tab-button[onclick*=\"switchTab('${tabName}')\"]`);
            if (button) button.style.display = visible ? '' : 'none';
            const tab = document.getElementById(`${tabName}-tab`);
            if (tab && !visible) tab.classList.add('hidden');
        }

        function isTabAccessibleForCurrentRole(tabName) {
            const isAdmin = currentUserRole === 'admin';
            const isTeacher = currentUserRole === 'teacher';
            const isStudent = !isAdmin && !isTeacher;
            if (tabName === 'my-dashboard') return isStudent;
            if (tabName === 'scoreboard') return true;
            if (tabName === 'group-scoreboard') return true;
            if (tabName === 'cr') return isAdmin || isTeacher;
            if (tabName === 'appeals') return true;
            if (tabName === 'notifications') return isAdmin || isTeacher;
            if (tabName === 'activity-log') return isAdmin;
            if (tabName === 'attendance') return true;
            if (tabName === 'syllabus') return true;
            if (tabName === 'good-conduct') return true;
            if (tabName === 'profile') return true;
            if (tabName === 'homework') return isAdmin || isTeacher;
            if (tabName === 'fees') return isAdmin;
            if (tabName === 'resources') return true;
            if (tabName === 'add-score') return isAdmin || isTeacher;
            if (tabName === 'students') return isAdmin;
            if (tabName === 'party') return isAdmin;
            if (tabName === 'office') return isAdmin || isTeacher;
            if (tabName === 'teacher-voting') return isAdmin || isTeacher;
            if (tabName === 'voting') return isAdmin;
            if (tabName === 'leadership') return isAdmin;
            if (tabName === 'tools') return isAdmin;
            if (tabName === 'ranking') return isAdmin;
            if (tabName === 'teachers') return isAdmin;
            return false;
        }

        function restoreLastActiveTab() {
            const savedTab = localStorage.getItem(ACTIVE_TAB_KEY) || 'scoreboard';
            const nextTab = isTabAccessibleForCurrentRole(savedTab) ? savedTab : 'scoreboard';
            switchTab(nextTab);
        }

        function applyRolePermissions() {
            const isAdmin = currentUserRole === 'admin';
            const isTeacher = currentUserRole === 'teacher';

            setTabVisibility('scoreboard', true);
            setTabVisibility('ranking', isAdmin);
            setTabVisibility('group-scoreboard', true);
            setTabVisibility('cr', true);
            setTabVisibility('teachers', isAdmin);
            setTabVisibility('teacher-voting', isAdmin || isTeacher);
            setTabVisibility('add-score', isAdmin || isTeacher);
            setTabVisibility('students', isAdmin);
            setTabVisibility('fees', isAdmin);
            setTabVisibility('resources', true);
            setTabVisibility('syllabus', true);
            setTabVisibility('party', isAdmin);
            setTabVisibility('office', isAdmin || isTeacher);
            setTabVisibility('voting', isAdmin);
            setTabVisibility('appeals', true);
            setTabVisibility('notifications', isAdmin || isTeacher);
            setTabVisibility('activity-log', isAdmin);
            setTabVisibility('attendance', isAdmin || isTeacher);
            setTabVisibility('good-conduct', isAdmin || isTeacher);
            setTabVisibility('profile', isAdmin || isTeacher);
            setTabVisibility('homework', isAdmin || isTeacher);
            setTabVisibility('leadership', isAdmin);
            setTabVisibility('tools', isAdmin);
            setTabVisibility('cr', isAdmin || isTeacher);

            // Device monitor card — admin only
            const devCard = document.getElementById('deviceMonitorCard');
            if (devCard) devCard.style.display = isAdmin ? '' : 'none';

            // Global Refresh button — visible to all logged-in users (admin/teacher/student)
            const refreshBtn = document.getElementById('globalRefreshBtn');
            if (refreshBtn) refreshBtn.style.display = SERVER_SYNC.enabled ? '' : 'none';
            // Force Publish button — admin only
            const publishBtn = document.getElementById('globalPublishBtn');
            if (publishBtn) publishBtn.style.display = (SERVER_SYNC.enabled && isAdmin) ? '' : 'none';

            const isStudent = !isAdmin && !isTeacher;
            setTabVisibility('my-dashboard', isStudent);
            if (isStudent) {
                // Detect positions and load dashboard on first call
                currentStudentPositions = detectStudentPositions();
                setTimeout(loadMyDashboard, 200);
            }
            // Student login: attendance tab is report-only; hide marking modules.
            ['markAttendanceCard', 'bulkPastAttendanceCard', 'attendanceGroupReportCard'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = isStudent ? 'none' : '';
            });
            // Student login: report filters should not expose group/class selectors.
            ['attendanceStudentReportGroupFilterGroup', 'attendanceStudentReportClassFilterGroup'].forEach(id => {
                const el = document.getElementById(id);
                if (el) el.style.display = isStudent ? 'none' : '';
            });
            if (isStudent) {
                document.querySelectorAll(
                    '#markAttendanceCard input, #markAttendanceCard select, #markAttendanceCard textarea, #markAttendanceCard button,' +
                    ' #bulkPastAttendanceCard input, #bulkPastAttendanceCard select, #bulkPastAttendanceCard textarea, #bulkPastAttendanceCard button'
                ).forEach(el => {
                    el.disabled = true;
                });
            }

            if (!isAdmin && !isTeacher) {
                // Students: limited edit mode (own profile + appeals + scoreboard filters)
                document.querySelectorAll('input, select, textarea, button').forEach(el => {
                    if (el.dataset.allow === 'true') return;
                    if (el.classList && el.classList.contains('tab-button')) return;
                    if (el.closest('#scoreboard-tab')) return;
                    if (el.closest('#group-scoreboard-tab')) return;
                    if (el.closest('#appeals-tab')) return;
                    if (el.closest('#profile-tab')) return;
                    if (el.closest('#resources-tab')) return;
                    if (el.closest('#syllabus-tab')) return;
                    if (el.closest('#attendance-tab')) return;
                    el.disabled = true;
                });
            }

            if (isTeacher) {
                // Teachers: full operational access on teacher-visible tabs.
                // Keep admin-only tabs hidden via setTabVisibility above.
                document.querySelectorAll('input, select, textarea, button').forEach(el => {
                    if (el.dataset.allow === 'true') return;
                    if (el.classList && el.classList.contains('tab-button')) return;
                    if (
                        el.closest('#add-score-tab') ||
                        el.closest('#scoreboard-tab') ||
                        el.closest('#group-scoreboard-tab') ||
                        el.closest('#cr-tab') ||
                        el.closest('#teacher-voting-tab') ||
                        el.closest('#appeals-tab') ||
                        el.closest('#attendance-tab') ||
                        el.closest('#profile-tab') ||
                        el.closest('#homework-tab') ||
                        el.closest('#resources-tab') ||
                        el.closest('#syllabus-tab') ||
                        el.closest('#office-tab')
                    ) {
                        el.disabled = false;
                        return;
                    }
                    el.disabled = true;
                });
                // Honor explicit admin-only markers in mixed tabs.
                document.querySelectorAll('[data-teacher-allow="false"]').forEach(el => {
                    el.disabled = true;
                });
            }

            enforceTeacherCurrentMonthOnlyUi();
        }

        // localStorage keys for remembering the last logged-in profile per browser.
        // Each browser on each device gets its own localStorage (origin-scoped),
        // so different browsers on the same IP naturally get separate profiles.
        const EA_PROFILE_ROLE_KEY = 'ea_profile_role';
        const EA_PROFILE_LOGIN_KEY = 'ea_profile_login_id';
        const EA_PROFILE_ROLL_KEY = 'ea_profile_student_roll';
        const EA_PROFILE_TIMESTAMP_KEY = 'ea_profile_saved_at';

        function saveProfileToLocal(role, loginId, studentRoll) {
            try {
                localStorage.setItem(EA_PROFILE_ROLE_KEY, role || 'student');
                localStorage.setItem(EA_PROFILE_LOGIN_KEY, loginId || '');
                localStorage.setItem(EA_PROFILE_ROLL_KEY, studentRoll || '');
                localStorage.setItem(EA_PROFILE_TIMESTAMP_KEY, new Date().toISOString());
            } catch (e) { /* localStorage full or blocked */ }
        }

        function restoreProfileFromLocal() {
            try {
                const savedRole = localStorage.getItem(EA_PROFILE_ROLE_KEY);
                const savedLogin = localStorage.getItem(EA_PROFILE_LOGIN_KEY);
                const savedRoll = localStorage.getItem(EA_PROFILE_ROLL_KEY);
                if (savedRole && savedLogin) {
                    currentUserRole = normalizeUserRole(savedRole);
                    currentLoginId = savedLogin;
                    currentStudentRoll = savedRoll || '';
                    return true;
                }
            } catch (e) { /* localStorage blocked */ }
            return false;
        }

        function clearProfileFromLocal() {
            try {
                localStorage.removeItem(EA_PROFILE_ROLE_KEY);
                localStorage.removeItem(EA_PROFILE_LOGIN_KEY);
                localStorage.removeItem(EA_PROFILE_ROLL_KEY);
                localStorage.removeItem(EA_PROFILE_TIMESTAMP_KEY);
            } catch (e) { /* ignore */ }
        }

        async function loadSessionContext(maxAttempts = 3) {
            if (!SERVER_SYNC.enabled) {
                // Offline: try to restore last known profile from this browser
                restoreProfileFromLocal();
                return false;
            }
            const attempts = Math.max(1, parseInt(maxAttempts, 10) || 1);
            for (let attempt = 1; attempt <= attempts; attempt++) {
                const timeoutMs = 3500 + ((attempt - 1) * 2000);
                try {
                    const sessionResp = await fetchWithTimeout('/scoreboard/session', { cache: 'no-store', credentials: 'include' }, timeoutMs);
                    if (!sessionResp.ok) {
                        continue;
                    }
                    const session = await sessionResp.json();
                    currentUserRole = normalizeUserRole(session.role || currentUserRole || 'student');
                    currentLoginId = session.login_id || currentLoginId || '';
                    currentStudentRoll = session.student_roll || '';
                    serverTimezone = session.server_timezone || serverTimezone;
                    // Remember this profile for future visits from this browser
                    saveProfileToLocal(currentUserRole, currentLoginId, currentStudentRoll);
                    return true;
                } catch (err) {
                    // Retry below. Do not force role downgrade here.
                }
                if (attempt < attempts) {
                    await new Promise(resolve => setTimeout(resolve, 250));
                }
            }
            // Server session unavailable — restore last known profile from this browser
            const restored = restoreProfileFromLocal();
            if (restored) {
                console.log(`Session unavailable. Restored profile: ${currentUserRole} (${currentLoginId})`);
            }
            return false;
        }

        function updateSyncStatus(state, message) {
            const badge = document.getElementById('syncStatus');
            const meta = document.getElementById('lastSyncTime');
            if (!badge) return;
            badge.classList.remove('online', 'offline', 'syncing');
            badge.classList.add(state);
            badge.textContent = message || (state === 'online' ? 'Online' : state === 'syncing' ? 'Syncing' : 'Offline');
            if (meta && state !== 'syncing' && message && message.includes('Last')) {
                meta.textContent = message;
            }
        }

        function setLastSyncTime(iso) {
            const meta = document.getElementById('lastSyncTime');
            if (!meta) return;
            if (!iso) {
                meta.textContent = 'Last sync: -';
                return;
            }
            const time = new Date(iso);
            if (Number.isNaN(time.getTime())) {
                meta.textContent = `Last sync: ${iso}`;
                return;
            }
            try {
                const label = time.toLocaleString('en-IN', { timeZone: serverTimezone, timeZoneName: 'short' });
                meta.textContent = `Last sync: ${label}`;
            } catch (err) {
                meta.textContent = `Last sync: ${time.toLocaleString()}`;
            }
            // Warn when server data is more than 12 hours old — prompts user to refresh or admin to push
            const staleMs = 12 * 60 * 60 * 1000;
            const syncBadge = document.getElementById('syncStatus');
            if (syncBadge && (Date.now() - time.getTime()) > staleMs) {
                syncBadge.classList.remove('online');
                syncBadge.classList.add('stale');
                syncBadge.textContent = 'Data Stale';
                meta.title = 'Server data is more than 12 hours old. Ask Admin to run Master Update, or click Refresh.';
            }
        }

        function updateRoleBadge() {
            const badge = document.getElementById('roleBadge');
            if (!badge) return;
            badge.textContent = `Role: ${currentUserRole}${currentLoginId ? ` (${currentLoginId})` : ''}`;
        }

        function maybeLocalBackup(data) {
            const now = Date.now();
            if (now - lastLocalBackupAt < LOCAL_BACKUP_INTERVAL) return;
            lastLocalBackupAt = now;
            try {
                const rawPayload = JSON.stringify(data);
                if (rawPayload.length > LOCAL_BACKUP_MAX_BYTES) {
                    // Keep operational cache, drop heavy local backup snapshots.
                    localStorage.removeItem(LOCAL_BACKUP_KEY);
                    return;
                }
                const existing = JSON.parse(localStorage.getItem(LOCAL_BACKUP_KEY) || '[]');
                existing.unshift({ ts: new Date().toISOString(), data });
                if (existing.length > LOCAL_BACKUP_LIMIT) {
                    existing.length = LOCAL_BACKUP_LIMIT;
                }
                const serialized = JSON.stringify(existing);
                if (serialized.length > LOCAL_BACKUP_MAX_BYTES) {
                    localStorage.removeItem(LOCAL_BACKUP_KEY);
                    return;
                }
                localStorage.setItem(LOCAL_BACKUP_KEY, serialized);
            } catch (err) {
                // ignore backup errors to avoid blocking saves
            }
        }

        function scheduleServerPush(data) {
            if (!SERVER_SYNC.enabled) return;
            pendingSyncPayload = data;
            if (currentUserRole === 'admin' || currentUserRole === 'teacher') {
                if (pendingPushTimer) {
                    clearTimeout(pendingPushTimer);
                }
                pendingPushTimer = setTimeout(() => {
                    pendingPushTimer = null;
                    pushToServer(pendingSyncPayload || db.getData(), { silent: true });
                }, AUTO_PUSH_DELAY_MS);
            }
        }

        function buildSyncUrl(baseUrl, path) {
            return `${baseUrl}${path}`;
        }

        function getCurrentSyncBaseUrl() {
            return normalizeServerBaseUrl(window.location.origin);
        }

        function getPrimarySyncBaseUrl() {
            // Primary must come from configured peer list (defaults first), not the current origin.
            const peers = getPeerBaseUrls();
            return peers[0] || getCurrentSyncBaseUrl();
        }

        function parseSyncStamp(value) {
            if (!value) return 0;
            const stamp = Date.parse(value);
            return Number.isFinite(stamp) ? stamp : 0;
        }

        function getDataStamp(data, fallbackUpdatedAt = '') {
            if (!data) return parseSyncStamp(fallbackUpdatedAt);
            return parseSyncStamp(data.server_updated_at || data.updated_at || fallbackUpdatedAt);
        }

        function getStudentRosterCount(payload) {
            const students = Array.isArray(payload && payload.students) ? payload.students : [];
            return students.length;
        }

        function getActiveStudentCount(payload) {
            const students = Array.isArray(payload && payload.students) ? payload.students : [];
            return students.filter(student => student && student.active !== false).length;
        }

        function getCurrentMonthRosterVisibilityCount(payload, monthKey = getCurrentMonthKey()) {
            if (!payload || typeof payload !== 'object') return 0;
            const month = String(monthKey || '').trim();
            if (!month) return 0;
            const rolls = new Set();
            const monthStudents = payload.month_students && payload.month_students[month];
            if (Array.isArray(monthStudents)) {
                monthStudents.forEach(value => {
                    const roll = normalizeRoll(value || '');
                    if (roll && roll.startsWith('EA')) rolls.add(roll);
                });
            }
            const monthProfiles = payload.month_roster_profiles && payload.month_roster_profiles[month];
            if (Array.isArray(monthProfiles)) {
                monthProfiles.forEach(profile => {
                    if (!profile || typeof profile !== 'object') return;
                    const roll = normalizeRoll(profile.roll || '');
                    if (roll && roll.startsWith('EA')) rolls.add(roll);
                });
            }
            return rolls.size;
        }

        function isLikelyCorruptRoster(payload, minCount = MIN_SAFE_STUDENT_ROSTER) {
            const count = getStudentRosterCount(payload);
            return count > 0 && count < minCount;
        }

        function localRosterNeedsRecovery() {
            if (!SERVER_SYNC.enabled) return false;
            const data = db && typeof db.getData === 'function' ? db.getData() : null;
            return isLikelyCorruptRoster(data);
        }

        function renderRosterRecoveryPlaceholder(message) {
            const tbody = document.getElementById('scoreboardBody');
            if (!tbody) return;
            tbody.innerHTML = `
                <tr>
                    <td colspan="7" class="text-center loading" style="padding: 24px;">
                        <div class="spinner"></div>
                        ${escapeHtml(message || 'Recovering safe roster from Master Server...')}
                    </td>
                </tr>
            `;
        }

        async function attemptRosterRecovery() {
            if (!SERVER_SYNC.enabled) return;
            const now = Date.now();
            if (rosterRecoveryInProgress) return;
            if (now - (rosterRecoveryLastAttemptAt || 0) < 2500) return;
            rosterRecoveryLastAttemptAt = now;
            rosterRecoveryInProgress = true;

            const targetTab = rosterRecoveryQueuedTab || 'scoreboard';
            renderRosterRecoveryPlaceholder('Recovering safe roster from Master Server...');
            updateSyncStatus('syncing', 'Recovering');

            try {
                await pullFromServer(false, true);  // forceFull: skip ?since to guarantee fresh snapshot
            } catch (err) {
                // ignore; status updates handled by pullFromServer
            } finally {
                rosterRecoveryInProgress = false;
            }

            if (!localRosterNeedsRecovery()) {
                const nextTab = rosterRecoveryQueuedTab || targetTab || 'scoreboard';
                rosterRecoveryQueuedTab = null;
                switchTab(nextTab);
                return;
            }

            // Still unsafe: keep the UI in recovery mode and prevent using corrupt roster.
            showAlert('Roster looks incomplete (possible stale snapshot). Master server sync is required to continue safely.', 'warning');
            renderRosterRecoveryPlaceholder('Waiting for Master Server (safe roster required)...');
        }

        function mergeScoreRowsSuperset(existingScores, incomingScores, options = {}) {
            const preferIncomingOnTie = options.preferIncomingOnTie === true;
            const merged = new Map();
            let maxId = 0;
            const addRow = (row) => {
                if (!row || typeof row !== 'object') return;
                const studentId = String(coalesce(row.studentId, '')).trim();
                const date = normalizeDateKey(row.date);
                const month = String(coalesce(row.month, date ? String(date).slice(0, 7) : '')).trim();
                if (!studentId || !date || !month) return;
                const key = `${studentId}|${date}|${month}`;
                const points = parseInt(row.points, 10) || 0;
                const stars = parseInt(row.stars, 10) || 0;
                const vetos = parseInt(row.vetos, 10) || 0;
                const next = { ...row, studentId: parseInt(studentId, 10) || row.studentId, date, month, points, stars, vetos };
                const prev = merged.get(key);
                if (prev) {
                    // Keep the most recently modified record; fall back to higher id as tiebreaker.
                    const prevStamp = parseSyncStamp(prev.updated_at || '');
                    const nextStamp = parseSyncStamp(next.updated_at || '');
                    if (nextStamp > prevStamp) {
                        merged.set(key, next);
                    } else if (nextStamp === prevStamp) {
                        const prevId = parseInt(prev.id, 10) || 0;
                        const nextId = parseInt(next.id, 10) || 0;
                        if (preferIncomingOnTie || nextId > prevId) {
                            merged.set(key, next);
                        }
                    }
                    // else keep prev (it is the same age or newer)
                } else {
                    merged.set(key, next);
                }
                const idNum = parseInt(next.id, 10);
                if (idNum > maxId) maxId = idNum;
            };
            (Array.isArray(existingScores) ? existingScores : []).forEach(addRow);
            (Array.isArray(incomingScores) ? incomingScores : []).forEach(addRow);
            const usedIds = new Set();
            return Array.from(merged.values()).map(row => {
                let idNum = parseInt(row.id, 10);
                if (!idNum || usedIds.has(idNum)) {
                    maxId += 1;
                    idNum = maxId;
                }
                usedIds.add(idNum);
                return { ...row, id: idNum };
            });
        }

        function getScoreMonthKey(row) {
            if (!row || typeof row !== 'object') return '';
            const month = String(coalesce(row.month, '')).trim();
            if (/^\d{4}-\d{2}$/.test(month)) return month;
            const dateKey = normalizeDateKey(row.date);
            return dateKey ? String(dateKey).slice(0, 7) : '';
        }

        function isTrustedHistoricalExcelRow(row) {
            const note = String(coalesce(row && row.notes, '')).trim().toLowerCase();
            return (
                note.startsWith('excel_total_score') ||
                note.startsWith('excel_total_from_dates') ||
                note.startsWith('excel_daily_score') ||
                note.startsWith('excel_star_usage')
            );
        }

        function ensureUniqueScoreIds(rows) {
            const used = new Set();
            let maxId = 0;
            const normalized = (Array.isArray(rows) ? rows : []).map(row => ({ ...row }));
            normalized.forEach(row => {
                const idNum = parseInt(row.id, 10) || 0;
                if (idNum > maxId) maxId = idNum;
            });
            normalized.forEach(row => {
                let idNum = parseInt(row.id, 10) || 0;
                if (!idNum || used.has(idNum)) {
                    maxId += 1;
                    idNum = maxId;
                }
                used.add(idNum);
                row.id = idNum;
            });
            return normalized;
        }

        function mergeScoreRowsWithHistoricalLocalGuard(existingScores, incomingScores, options = {}) {
            const preferIncomingOnTie = options.preferIncomingOnTie === true;
            const historicalCutoff = String(options.historicalCutoff || '2026-02').trim();
            const allowHistoricalOverride = options.allowHistoricalOverride === true;
            const localRows = Array.isArray(existingScores) ? existingScores : [];
            const incomingRows = Array.isArray(incomingScores) ? incomingScores : [];

            const localHasTrustedHistorical = localRows.some(row => {
                const mk = getScoreMonthKey(row);
                return !!mk && mk < historicalCutoff && isTrustedHistoricalExcelRow(row);
            });

            const localHistorical = localRows.filter(row => {
                const mk = getScoreMonthKey(row);
                return !!mk && mk < historicalCutoff;
            });
            const incomingHistorical = incomingRows.filter(row => {
                const mk = getScoreMonthKey(row);
                return !!mk && mk < historicalCutoff;
            });
            const localActive = localRows.filter(row => {
                const mk = getScoreMonthKey(row);
                return !!mk && mk >= historicalCutoff;
            });
            const incomingActive = incomingRows.filter(row => {
                const mk = getScoreMonthKey(row);
                return !!mk && mk >= historicalCutoff;
            });

            const mergedActive = mergeScoreRowsSuperset(localActive, incomingActive, { preferIncomingOnTie });
            const mergedHistorical = (allowHistoricalOverride || !localHasTrustedHistorical)
                ? mergeScoreRowsSuperset(localHistorical, incomingHistorical, { preferIncomingOnTie })
                : mergeScoreRowsSuperset(localHistorical, [], { preferIncomingOnTie: false });

            return ensureUniqueScoreIds([...mergedHistorical, ...mergedActive]);
        }

        function mergeNotificationHistorySuperset(existingHistory, incomingHistory) {
            const merged = new Map();
            const buildKey = (item) => {
                if (!item || typeof item !== 'object') return '';
                const fp = String(item.fingerprint || '').trim().toLowerCase();
                if (fp) return fp;
                const title = String(item.title || '').trim().toLowerCase();
                const detail = String(item.detail || '').trim().toLowerCase();
                const meta = String(item.meta || '').trim().toLowerCase();
                return `${title}||${detail}||${meta}`;
            };
            const addItem = (item) => {
                const key = buildKey(item);
                if (!key) return;
                const prev = merged.get(key);
                if (!prev) {
                    merged.set(key, { ...item });
                    return;
                }
                const prevStamp = parseSyncStamp(prev.logged_at);
                const nextStamp = parseSyncStamp(item.logged_at);
                if (nextStamp >= prevStamp) {
                    merged.set(key, { ...item });
                }
            };
            (Array.isArray(existingHistory) ? existingHistory : []).forEach(addItem);
            (Array.isArray(incomingHistory) ? incomingHistory : []).forEach(addItem);
            return Array.from(merged.values());
        }

        function mergePendingResultsSuperset(existingResults, incomingResults) {
            const merged = new Map();
            const buildKey = (item) => {
                if (!item || typeof item !== 'object') return '';
                const post = String(item.post || '').trim().toLowerCase();
                const source = String(item.source || '').trim().toLowerCase();
                if (!post || !source) return '';
                return `${post}::${source}`;
            };
            const addItem = (item) => {
                const key = buildKey(item);
                if (!key) return;
                const prev = merged.get(key);
                if (!prev) {
                    merged.set(key, { ...item });
                    return;
                }
                const prevStamp = parseSyncStamp(prev.decided_at || prev.updated_at || prev.created_at || '');
                const nextStamp = parseSyncStamp(item.decided_at || item.updated_at || item.created_at || '');
                if (nextStamp >= prevStamp) {
                    merged.set(key, { ...item });
                }
            };
            (Array.isArray(existingResults) ? existingResults : []).forEach(addItem);
            (Array.isArray(incomingResults) ? incomingResults : []).forEach(addItem);
            return Array.from(merged.values());
        }

        function mergeAttendanceSuperset(existingAttendance, incomingAttendance, existingStudents = [], incomingStudents = []) {
            const merged = new Map();
            const normalizeStatus = (value) => {
                const status = String(value || '').trim().toLowerCase();
                if (status === 'absent' || status === 'late' || status === 'leave' || status === 'present') return status;
                return 'present';
            };
            const existingIdByRoll = new Map();
            const incomingRollById = new Map();
            (Array.isArray(existingStudents) ? existingStudents : []).forEach(student => {
                if (!student || typeof student !== 'object') return;
                const sid = parseInt(student.id, 10);
                const roll = normalizeAttendanceRoll(student.roll || '');
                if (!sid || !roll || existingIdByRoll.has(roll)) return;
                existingIdByRoll.set(roll, sid);
            });
            (Array.isArray(incomingStudents) ? incomingStudents : []).forEach(student => {
                if (!student || typeof student !== 'object') return;
                const sid = parseInt(student.id, 10);
                const roll = normalizeAttendanceRoll(student.roll || '');
                if (!sid || !roll) return;
                incomingRollById.set(String(sid), roll);
            });
            const buildKey = (item) => {
                if (!item || typeof item !== 'object') return '';
                const date = String(item.date || '').trim();
                let roll = normalizeAttendanceRoll(item.roll || '');
                let sid = parseInt(item.studentId, 10);
                if (!roll && sid) {
                    roll = incomingRollById.get(String(sid)) || '';
                }
                if (roll && existingIdByRoll.has(roll)) {
                    sid = existingIdByRoll.get(roll);
                }
                const sidKey = sid ? String(sid) : '';
                const identity = roll || sid;
                if (!date || !identity) return '';
                return `${date}::${roll || sidKey}`;
            };
            const addItem = (item) => {
                const key = buildKey(item);
                if (!key) return;
                const normalized = {
                    ...item,
                    date: String(item.date || '').trim(),
                    status: normalizeStatus(item.status),
                    remarks: String(item.remarks || '')
                };
                const normalizedRoll = normalizeAttendanceRoll(item.roll || '');
                const normalizedStudentId = parseInt(item.studentId, 10);
                if (normalizedRoll) {
                    normalized.roll = normalizedRoll;
                    if (existingIdByRoll.has(normalizedRoll)) {
                        normalized.studentId = existingIdByRoll.get(normalizedRoll);
                    }
                }
                if (!normalized.roll && normalizedStudentId) {
                    const lookupRoll = incomingRollById.get(String(normalizedStudentId)) || '';
                    if (lookupRoll) {
                        normalized.roll = lookupRoll;
                        if (existingIdByRoll.has(lookupRoll)) {
                            normalized.studentId = existingIdByRoll.get(lookupRoll);
                        }
                    }
                }
                if (!normalized.studentId && normalizedStudentId) {
                    normalized.studentId = normalizedStudentId;
                }
                const prev = merged.get(key);
                if (!prev) {
                    merged.set(key, normalized);
                    return;
                }
                const prevStamp = parseSyncStamp(prev.updated_at || prev.created_at);
                const nextStamp = parseSyncStamp(normalized.updated_at || normalized.created_at);
                if (nextStamp >= prevStamp) {
                    merged.set(key, normalized);
                }
            };
            (Array.isArray(existingAttendance) ? existingAttendance : []).forEach(addItem);
            (Array.isArray(incomingAttendance) ? incomingAttendance : []).forEach(addItem);
            return Array.from(merged.values());
        }

        function mergeFeeRecordsSuperset(existingRecords, incomingRecords) {
            const merged = new Map();

            const maxDate = (a, b) => {
                const aa = String(a || '').trim();
                const bb = String(b || '').trim();
                if (!aa) return bb;
                if (!bb) return aa;
                return aa >= bb ? aa : bb;
            };

            const mergePaymentHistory = (a, b) => {
                const out = [];
                const seen = new Set();
                const add = (item) => {
                    if (!item || typeof item !== 'object') return;
                    const date = String(item.date || item.paid_on || item.paidAt || '').trim();
                    const amount = String(item.amount || '').trim();
                    const note = String(item.note || item.remarks || '').trim().toLowerCase();
                    const fp = `${date}::${amount}::${note}`;
                    if (seen.has(fp)) return;
                    seen.add(fp);
                    out.push({ ...item });
                };
                (Array.isArray(a) ? a : []).forEach(add);
                (Array.isArray(b) ? b : []).forEach(add);
                out.sort((x, y) => String(x.date || x.paid_on || x.paidAt || '').localeCompare(String(y.date || y.paid_on || y.paidAt || '')));
                return out;
            };

            const mergePair = (prev, next) => {
                const prevStamp = parseSyncStamp(prev.updated_at || prev.created_at || '');
                const nextStamp = parseSyncStamp(next.updated_at || next.created_at || '');
                const preferNext = nextStamp >= prevStamp;
                const base = preferNext ? { ...next } : { ...prev };

                // Preserve payment proof regardless of timestamp (guards against clock-skew stale devices).
                base.payment_history = mergePaymentHistory(prev.payment_history, next.payment_history);
                base.last_paid_date = maxDate(prev.last_paid_date, next.last_paid_date);

                // Prefer the latest cycle anchor to avoid reverting to an older due date.
                base.start_date = maxDate(prev.start_date, next.start_date);

                const chosenCycle = String(base.start_date || '').trim();
                const prevCycle = String(prev.start_date || '').trim();
                const nextCycle = String(next.start_date || '').trim();
                const cycleSource = (chosenCycle && chosenCycle === nextCycle)
                    ? next
                    : (chosenCycle && chosenCycle === prevCycle)
                        ? prev
                        : (preferNext ? next : prev);

                if (cycleSource.amount !== null && cycleSource.amount !== undefined) {
                    const amt = Number(cycleSource.amount);
                    if (Number.isFinite(amt)) base.amount = amt;
                }
                if (cycleSource.pending_amount !== null && cycleSource.pending_amount !== undefined) {
                    const pend = Number(cycleSource.pending_amount);
                    if (Number.isFinite(pend)) base.pending_amount = pend;
                }
                const period = parseInt(cycleSource.period_months, 10);
                if (Number.isFinite(period) && period > 0) base.period_months = period;

                const prevRemarks = String(prev.remarks || '').trim();
                const nextRemarks = String(next.remarks || '').trim();
                base.remarks = prevRemarks ? (preferNext && nextRemarks ? nextRemarks : prevRemarks) : nextRemarks;

                base.created_at = String(prev.created_at || next.created_at || base.created_at || '').trim();
                base.updated_at = String((preferNext ? (next.updated_at || next.created_at) : (prev.updated_at || prev.created_at)) || base.updated_at || '').trim();
                return normalizeFeeRecord(base);
            };

            const addRecord = (record) => {
                const normalized = normalizeFeeRecord(record);
                const parsedStudentId = parseInt(normalized.studentId, 10);
                if (!Number.isFinite(parsedStudentId)) return;
                normalized.studentId = parsedStudentId;
                const key = String(parsedStudentId);
                const prev = merged.get(key);
                if (!prev) {
                    merged.set(key, normalized);
                    return;
                }
                merged.set(key, mergePair(prev, normalized));
            };

            (Array.isArray(existingRecords) ? existingRecords : []).forEach(addRecord);
            (Array.isArray(incomingRecords) ? incomingRecords : []).forEach(addRecord);
            return Array.from(merged.values());
        }

        function resourceStatusRank(status) {
            const s = String(status || '').trim().toLowerCase();
            if (s === 'pending_teacher') return 10;
            if (s === 'not_recommended') return 15;
            if (s === 'pending_admin') return 20;
            if (s === 'rejected') return 30;
            if (s === 'approved') return 40;
            if (s === 'fulfilled') return 50;
            if (s === 'cancelled') return 60;
            return 0;
        }

        function mergeResourceCabinetSuperset(existingItems, incomingItems) {
            const merged = new Map();
            const makeKey = (item) => {
                const id = parseInt(item && item.id, 10) || 0;
                if (id) return `id:${id}`;
                const name = String(item && item.name || '').trim().toLowerCase();
                return name ? `name:${name}` : '';
            };
            const normalize = (item) => {
                const id = parseInt(item && item.id, 10) || 0;
                const name = String(item && item.name || '').trim();
                const unit = String(item && item.unit || '').trim();
                const price = Number(item && (item.price_per_unit !== undefined && item.price_per_unit !== null ? item.price_per_unit : item.pricePerUnit)) || 0;
                const held = parseInt(item && (item.total_held !== undefined && item.total_held !== null ? item.total_held : item.totalHeld), 10) || 0;
                const created_at = String(item && item.created_at || '').trim();
                const updated_at = String(item && item.updated_at || '').trim();
                return { ...item, id, name, unit, price_per_unit: price, total_held: held, created_at, updated_at };
            };
            const add = (item) => {
                if (!item || typeof item !== 'object') return;
                const normalized = normalize(item);
                const key = makeKey(normalized);
                if (!key || !normalized.name) return;
                const prev = merged.get(key);
                if (!prev) {
                    merged.set(key, normalized);
                    return;
                }
                const prevStamp = parseSyncStamp(prev.updated_at || prev.created_at || '');
                const nextStamp = parseSyncStamp(normalized.updated_at || normalized.created_at || '');
                merged.set(key, nextStamp >= prevStamp ? { ...prev, ...normalized } : { ...normalized, ...prev });
            };
            (Array.isArray(existingItems) ? existingItems : []).forEach(add);
            (Array.isArray(incomingItems) ? incomingItems : []).forEach(add);
            return Array.from(merged.values()).filter(it => it.name);
        }

        function mergeResourceRequestsSuperset(existingRequests, incomingRequests) {
            const merged = new Map();
            const normalize = (row) => {
                const id = parseInt(row && row.id, 10) || 0;
                if (!id) return null;
                const type = String(row && (row.type || row.mode) || '').trim().toLowerCase();
                const status = String(row && row.status || '').trim().toLowerCase();
                const next = { ...row, id, type, status };
                if (row && row.studentId !== undefined && row.studentId !== null) next.studentId = parseInt(row.studentId, 10) || row.studentId;
                if (row && (row.item_id || row.itemId)) next.item_id = parseInt(row.item_id || row.itemId, 10) || 0;
                if (row && (row.qty || row.quantity)) next.qty = Math.max(1, parseInt(row.qty || row.quantity, 10) || 1);
                next.created_at = String(row && row.created_at || '').trim();
                next.updated_at = String(row && row.updated_at || '').trim();
                return next;
            };
            const mergePair = (a, b) => {
                const aa = normalize(a) || a;
                const bb = normalize(b) || b;
                const ar = resourceStatusRank(aa && aa.status);
                const br = resourceStatusRank(bb && bb.status);
                const aStamp = parseSyncStamp(String(aa && (aa.updated_at || aa.created_at) || ''));
                const bStamp = parseSyncStamp(String(bb && (bb.updated_at || bb.created_at) || ''));
                let base = null;
                if (br > ar) base = { ...aa, ...bb };
                else if (ar > br) base = { ...bb, ...aa };
                else base = bStamp >= aStamp ? { ...aa, ...bb } : { ...bb, ...aa };

                // Never unset decisions once made.
                const teacherDecision = String((aa && aa.teacher_decision) || '').trim() || String((bb && bb.teacher_decision) || '').trim();
                const teacherRemark = String((aa && aa.teacher_remark) || '').trim() || String((bb && bb.teacher_remark) || '').trim();
                const adminDecision = String((aa && aa.admin_decision) || '').trim() || String((bb && bb.admin_decision) || '').trim();
                const adminRemark = String((aa && aa.admin_remark) || '').trim() || String((bb && bb.admin_remark) || '').trim();
                if (teacherDecision) base.teacher_decision = teacherDecision;
                if (teacherRemark) base.teacher_remark = teacherRemark;
                if (adminDecision) base.admin_decision = adminDecision;
                if (adminRemark) base.admin_remark = adminRemark;
                base.urgent = !!(aa && aa.urgent) || !!(bb && bb.urgent);
                return base;
            };
            const add = (row) => {
                const normalized = normalize(row);
                if (!normalized) return;
                const key = String(normalized.id);
                const prev = merged.get(key);
                if (!prev) merged.set(key, normalized);
                else merged.set(key, mergePair(prev, normalized));
            };
            (Array.isArray(existingRequests) ? existingRequests : []).forEach(add);
            (Array.isArray(incomingRequests) ? incomingRequests : []).forEach(add);
            return Array.from(merged.values());
        }

        function mergeResourceTransactionsSuperset(existingRows, incomingRows) {
            const merged = new Map();
            const normalize = (row) => {
                const id = parseInt(row && row.id, 10) || 0;
                if (!id) return null;
                const type = String(row && (row.type || row.mode) || '').trim().toLowerCase();
                const next = { ...row, id, type };
                next.created_at = String(row && row.created_at || '').trim();
                next.updated_at = String(row && row.updated_at || '').trim();
                if (row && row.studentId !== undefined && row.studentId !== null) next.studentId = parseInt(row.studentId, 10) || row.studentId;
                if (row && (row.item_id || row.itemId)) next.item_id = parseInt(row.item_id || row.itemId, 10) || 0;
                if (row && (row.qty || row.quantity)) next.qty = Math.max(1, parseInt(row.qty || row.quantity, 10) || 1);
                return next;
            };
            const add = (row) => {
                const normalized = normalize(row);
                if (!normalized) return;
                const key = String(normalized.id);
                const prev = merged.get(key);
                if (!prev) {
                    merged.set(key, normalized);
                    return;
                }
                const prevStamp = parseSyncStamp(prev.updated_at || prev.created_at || '');
                const nextStamp = parseSyncStamp(normalized.updated_at || normalized.created_at || '');
                merged.set(key, nextStamp >= prevStamp ? { ...prev, ...normalized } : { ...normalized, ...prev });
            };
            (Array.isArray(existingRows) ? existingRows : []).forEach(add);
            (Array.isArray(incomingRows) ? incomingRows : []).forEach(add);
            return Array.from(merged.values());
        }

        function mergeElectionVotesSuperset(existingVotes, incomingVotes, mode = 'party') {
            const merged = new Map();
            const addVote = (vote) => {
                if (!vote || typeof vote !== 'object') return;
                const post = String(vote.post || '').trim();
                if (!post) return;
                let key = '';
                if (mode === 'party') {
                    const partyId = String(vote.partyId || '').trim();
                    if (!partyId) return;
                    key = `${post}::party::${partyId}`;
                } else if (mode === 'teacher') {
                    const teacherId = String(vote.teacherId || '').trim();
                    if (!teacherId) return;
                    key = `${post}::teacher::${teacherId}`;
                } else {
                    const voterStudentId = String(vote.voterStudentId || '').trim();
                    if (!voterStudentId) return;
                    key = `${post}::student::${voterStudentId}`;
                }
                const prev = merged.get(key);
                if (!prev) {
                    merged.set(key, { ...vote });
                    return;
                }
                const prevStamp = parseSyncStamp(prev.timestamp || prev.updated_at || prev.created_at || '');
                const nextStamp = parseSyncStamp(vote.timestamp || vote.updated_at || vote.created_at || '');
                if (nextStamp >= prevStamp) {
                    merged.set(key, { ...vote });
                }
            };
            (Array.isArray(existingVotes) ? existingVotes : []).forEach(addVote);
            (Array.isArray(incomingVotes) ? incomingVotes : []).forEach(addVote);
            return Array.from(merged.values());
        }

        function mergeCandidatesSuperset(existingCandidates, incomingCandidates) {
            const merged = new Map();
            let maxId = 0;
            const addCandidate = (candidate) => {
                if (!candidate || typeof candidate !== 'object') return;
                const post = String(candidate.post || '').trim();
                const studentId = parseInt(candidate.studentId, 10);
                if (!post || !studentId) return;
                const key = `${post.toLowerCase()}::${studentId}`;
                const normalized = { ...candidate, post, studentId };
                const prev = merged.get(key);
                if (!prev) {
                    merged.set(key, normalized);
                } else {
                    const prevStamp = parseSyncStamp(prev.updated_at || prev.created_on || prev.created_at || '');
                    const nextStamp = parseSyncStamp(normalized.updated_at || normalized.created_on || normalized.created_at || '');
                    if (nextStamp >= prevStamp) {
                        merged.set(key, normalized);
                    }
                }
                const idNum = parseInt(normalized.id, 10) || 0;
                if (idNum > maxId) maxId = idNum;
            };
            (Array.isArray(existingCandidates) ? existingCandidates : []).forEach(addCandidate);
            (Array.isArray(incomingCandidates) ? incomingCandidates : []).forEach(addCandidate);
            const used = new Set();
            return Array.from(merged.values()).map(candidate => {
                let idNum = parseInt(candidate.id, 10);
                if (!idNum || used.has(idNum)) {
                    maxId += 1;
                    idNum = maxId;
                }
                used.add(idNum);
                return { ...candidate, id: idNum };
            });
        }

        function mergeStudentsSuperset(existingStudents, incomingStudents) {
            const merged = new Map();
            let maxId = 0;
            const addStudent = (student) => {
                if (!student || typeof student !== 'object') return;
                const normalized = normalizeStudentMeta({ ...student });
                const rollKey = normalizeRoll(normalized.roll || '');
                const nameKey = normalizeStudentNameKey(normalized.base_name || normalized.name || normalized.raw_name || '');
                const key = rollKey ? `roll:${rollKey}` : (nameKey ? `name:${nameKey}` : '');
                if (!key) return;

                const prev = merged.get(key);
                if (!prev) {
                    merged.set(key, normalized);
                } else {
                    const prevStamp = parseSyncStamp(prev.updated_at || prev.created_at || '');
                    const nextStamp = parseSyncStamp(normalized.updated_at || normalized.created_at || '');
                    let mergedStudent;
                    if (nextStamp > prevStamp) {
                        // Incoming is genuinely newer — accept it.
                        mergedStudent = { ...prev, ...normalized };
                    } else if (nextStamp < prevStamp) {
                        // Existing is newer — it overrides.
                        mergedStudent = { ...normalized, ...prev };
                    } else {
                        // Timestamp tie (both often 0): incoming overrides other fields,
                        // but NEVER downgrade active: true → false without a clearly newer stamp.
                        mergedStudent = { ...prev, ...normalized };
                        if (prev.active !== false && mergedStudent.active === false) {
                            mergedStudent.active = prev.active;
                        }
                    }
                    merged.set(key, mergedStudent);
                }
                const idNum = parseInt(normalized.id, 10) || 0;
                if (idNum > maxId) maxId = idNum;
            };

            (Array.isArray(existingStudents) ? existingStudents : []).forEach(addStudent);
            (Array.isArray(incomingStudents) ? incomingStudents : []).forEach(addStudent);
            const used = new Set();
            return Array.from(merged.values()).map(student => {
                let idNum = parseInt(student.id, 10);
                if (!idNum || used.has(idNum)) {
                    maxId += 1;
                    idNum = maxId;
                }
                used.add(idNum);
                return normalizeStudentMeta({ ...student, id: idNum });
            });
        }

        function isSuspiciousStudentShrink(localData, incomingData) {
            const localStudents = Array.isArray(localData && localData.students) ? localData.students : [];
            const incomingStudents = Array.isArray(incomingData && incomingData.students) ? incomingData.students : [];
            if (localStudents.length < 25 || incomingStudents.length === 0) return false;

            const localRolls = new Set(localStudents.map(s => normalizeRoll(s && s.roll)).filter(Boolean));
            const incomingRolls = new Set(incomingStudents.map(s => normalizeRoll(s && s.roll)).filter(Boolean));
            if (!localRolls.size || !incomingRolls.size) return false;

            const removed = [...localRolls].filter(roll => !incomingRolls.has(roll));
            const hardDrop = incomingRolls.size + 5 < localRolls.size;
            const largeRemovedSet = removed.length >= 8;
            return hardDrop && largeRemovedSet;
        }

        // Merge leadership: prefer the version that has a holder assigned (non-empty holder/roll).
        // Match by post id first, then by post name. Never overwrite a populated entry with an empty one.
        function mergeLeadershipSuperset(localPosts, remotePosts) {
            const merged = new Map();
            const normalize = (p) => ({ ...p, id: parseInt(p.id, 10) || 0 });
            const isPopulated = (p) => !!(String(p.holder || '').trim() || String(p.roll || '').trim());
            (Array.isArray(localPosts) ? localPosts : []).forEach(p => {
                const n = normalize(p);
                if (n.id) merged.set(n.id, n);
            });
            (Array.isArray(remotePosts) ? remotePosts : []).forEach(p => {
                const n = normalize(p);
                if (!n.id) return;
                const existing = merged.get(n.id);
                if (!existing) { merged.set(n.id, n); return; }
                // Never overwrite a populated holder with an empty one
                if (isPopulated(existing) && !isPopulated(n)) return;
                // Prefer whichever has a holder; if both have one, use newer timestamp
                if (isPopulated(n) || !isPopulated(existing)) {
                    merged.set(n.id, { ...existing, ...n });
                }
            });
            return Array.from(merged.values());
        }

        // Merge group_crs: match by id, never drop entries, prefer populated
        function mergeGroupCRsSuperset(localCRs, remoteCRs) {
            const merged = new Map();
            const add = (arr) => {
                (Array.isArray(arr) ? arr : []).forEach(cr => {
                    const id = parseInt(cr.id, 10) || 0;
                    if (!id) return;
                    const existing = merged.get(id);
                    if (!existing) { merged.set(id, { ...cr, id }); return; }
                    // Prefer the entry with a studentId assigned
                    const existingHas = !!(existing.studentId);
                    const newHas = !!(cr.studentId);
                    if (newHas || !existingHas) {
                        merged.set(id, { ...existing, ...cr, id });
                    }
                });
            };
            add(localCRs);
            add(remoteCRs);
            return Array.from(merged.values());
        }

        // Merge parties: match by code or id, preserve members (never overwrite populated with empty)
        function mergePartiesSuperset(localParties, remoteParties) {
            const merged = new Map();
            const keyOf = (p) => String(p.code || '').trim().toUpperCase() || String(p.id || '');
            const add = (arr, overwrite) => {
                (Array.isArray(arr) ? arr : []).forEach(p => {
                    const key = keyOf(p);
                    if (!key) return;
                    const existing = merged.get(key);
                    if (!existing) { merged.set(key, { ...p }); return; }
                    const existingMembers = Array.isArray(existing.members) ? existing.members : [];
                    const newMembers = Array.isArray(p.members) ? p.members : [];
                    // Never overwrite non-empty members with empty
                    if (existingMembers.length > 0 && newMembers.length === 0) {
                        // Keep existing members, merge other fields
                        merged.set(key, { ...existing, ...p, members: existingMembers });
                    } else {
                        merged.set(key, { ...existing, ...p });
                    }
                });
            };
            add(localParties, false);
            add(remoteParties, true);
            return Array.from(merged.values());
        }

        // Merge class_reps: same pattern as group_crs
        function mergeClassRepsSuperset(localReps, remoteReps) {
            const merged = new Map();
            const add = (arr) => {
                (Array.isArray(arr) ? arr : []).forEach(rep => {
                    const id = parseInt(rep.id, 10) || 0;
                    if (!id) return;
                    const existing = merged.get(id);
                    if (!existing) { merged.set(id, { ...rep, id }); return; }
                    const existingHas = !!(existing.studentId);
                    const newHas = !!(rep.studentId);
                    if (newHas || !existingHas) {
                        merged.set(id, { ...existing, ...rep, id });
                    }
                });
            };
            add(localReps);
            add(remoteReps);
            return Array.from(merged.values());
        }

        function mergeSyllabusCatalogForSync(localCatalog, remoteCatalog) {
            return mergeSyllabusCatalogSuperset(localCatalog || {}, remoteCatalog || {});
        }

        function mergeSyllabusTrackingForSync(localRows, remoteRows) {
            return mergeSyllabusTrackingSuperset(localRows || [], remoteRows || []);
        }

        function mergeMonthStudentsSuperset(existing, incoming) {
            // Union of roll entries per month — incoming can only ADD, never remove.
            const merged = {};
            [existing || {}, incoming || {}].forEach(src => {
                Object.entries(src || {}).forEach(([month, rolls]) => {
                    if (!Array.isArray(rolls)) return;
                    if (!merged[month]) {
                        merged[month] = [...rolls];
                    } else {
                        const seen = new Set(merged[month].map(r => normalizeRosterValue(r)));
                        rolls.forEach(r => {
                            const key = normalizeRosterValue(r);
                            if (key && !seen.has(key)) { merged[month].push(r); seen.add(key); }
                        });
                    }
                });
            });
            return merged;
        }

        function mergeMonthRosterProfilesSuperset(existing, incoming) {
            // Union of profiles per month keyed by roll. Incoming updates existing metadata.
            const merged = {};
            [existing || {}, incoming || {}].forEach((src, srcIdx) => {
                Object.entries(src || {}).forEach(([month, profiles]) => {
                    if (!Array.isArray(profiles)) return;
                    if (!merged[month]) merged[month] = {};
                    profiles.forEach(p => {
                        if (!p || typeof p !== 'object') return;
                        const roll = normalizeRosterValue(p.roll);
                        if (roll) {
                            merged[month][roll] = srcIdx === 0
                                ? (merged[month][roll] || p)          // existing: keep if already set
                                : { ...(merged[month][roll] || {}), ...p }; // incoming: update metadata
                        }
                    });
                });
            });
            const result = {};
            Object.entries(merged).forEach(([month, byRoll]) => { result[month] = Object.values(byRoll); });
            return result;
        }

        function applyRemoteSnapshot(serverData, serverUpdatedAt, showToast = false, options = {}) {
            if (!serverData) return false;
            if (isLikelyCorruptRoster(serverData)) {
                showAlert(`Rejected remote snapshot due to incomplete roster (${getStudentRosterCount(serverData)} students). Waiting for Master Server snapshot.`, 'warning');
                return false;
            }
            const localData = db.getData() || {};
            const allowShrinkOverride = options.allowShrinkOverride === true;
            if (!allowShrinkOverride && isSuspiciousStudentShrink(localData, serverData)) {
                showAlert('Rejected remote snapshot due to suspicious student-list shrink. Local data retained.', 'warning');
                return false;
            }
            const preferServerConflicts = options.preferServerConflicts === true;
            const authoritativeReplace = options.authoritativeReplace === true;
            let mergedData;
            if (authoritativeReplace) {
                const baseline = (db && typeof db.getDefaultData === 'function') ? db.getDefaultData() : {};
                mergedData = {
                    ...baseline,
                    ...serverData,
                    server_updated_at: serverData.server_updated_at || serverUpdatedAt || baseline.server_updated_at || '',
                    updated_at: serverData.updated_at || serverUpdatedAt || baseline.updated_at || ''
                };
                mergedData.scores = mergeScoreRowsWithHistoricalLocalGuard(
                    localData.scores || [],
                    serverData.scores || [],
                    { preferIncomingOnTie: preferServerConflicts }
                );
            } else {
                mergedData = {
                    ...localData,
                    ...serverData,
                    // ↑ serverData spread is a baseline; the explicit merges below OVERRIDE it for protected tables.
                    students: mergeStudentsSuperset(localData.students || [], serverData.students || []),
                    month_students: mergeMonthStudentsSuperset(localData.month_students || {}, serverData.month_students || {}),
                    month_roster_profiles: mergeMonthRosterProfilesSuperset(localData.month_roster_profiles || {}, serverData.month_roster_profiles || {}),
                    scores: mergeScoreRowsWithHistoricalLocalGuard(localData.scores || [], serverData.scores || [], { preferIncomingOnTie: preferServerConflicts }),
                    attendance: mergeAttendanceSuperset(
                        localData.attendance || [],
                        serverData.attendance || [],
                        localData.students || [],
                        serverData.students || []
                    ),
                    fee_records: mergeFeeRecordsSuperset(localData.fee_records || [], serverData.fee_records || []),
                    leadership: mergeLeadershipSuperset(localData.leadership || [], serverData.leadership || []),
                    group_crs: mergeGroupCRsSuperset(localData.group_crs || [], serverData.group_crs || []),
                    class_reps: mergeClassRepsSuperset(localData.class_reps || [], serverData.class_reps || []),
                    parties: mergePartiesSuperset(localData.parties || [], serverData.parties || []),
                    resource_cabinet: mergeResourceCabinetSuperset(localData.resource_cabinet || [], serverData.resource_cabinet || []),
                    resource_requests: mergeResourceRequestsSuperset(localData.resource_requests || [], serverData.resource_requests || []),
                    resource_transactions: mergeResourceTransactionsSuperset(localData.resource_transactions || [], serverData.resource_transactions || []),
                    syllabus_catalog: mergeSyllabusCatalogForSync(localData.syllabus_catalog || {}, serverData.syllabus_catalog || {}),
                    syllabus_tracking: mergeSyllabusTrackingForSync(localData.syllabus_tracking || [], serverData.syllabus_tracking || []),
                    election_candidates: mergeCandidatesSuperset(localData.election_candidates || [], serverData.election_candidates || []),
                    election_votes: mergeElectionVotesSuperset(localData.election_votes || [], serverData.election_votes || [], 'party'),
                    election_individual_votes: mergeElectionVotesSuperset(localData.election_individual_votes || [], serverData.election_individual_votes || [], 'individual'),
                    election_teacher_votes: mergeElectionVotesSuperset(localData.election_teacher_votes || [], serverData.election_teacher_votes || [], 'teacher'),
                    pending_election_results: mergePendingResultsSuperset(localData.pending_election_results || [], serverData.pending_election_results || []),
                    notification_history: mergeNotificationHistorySuperset(localData.notification_history || [], serverData.notification_history || [])
                };
            }
            db.saveData(mergedData, { system: true, skipSync: true, preserveTimestamp: true, skipBackup: true });
            if (currentUserRole === 'admin' || currentUserRole === 'teacher') {
                // Safety: pull should not trigger a write-back loop.
                const grantsChanged = applyMonthlyRoleVetoGrants({ persist: false });
                const vetoChanged = reconcileVetoCountersFromScores(getCurrentMonthKey(), { persist: false });
                if (grantsChanged || vetoChanged) {
                    db.saveData(mergedData, { system: true, skipSync: true, preserveTimestamp: true, skipBackup: true });
                }
            }
            const appliedStamp = getDataStamp(mergedData, serverUpdatedAt);
            if (appliedStamp > lastKnownRemoteStamp) {
                lastKnownRemoteStamp = appliedStamp;
            }
            if (showToast) {
                showAlert('Synced latest data from LAN servers', 'success');
            }
            scheduleActiveTabRefreshFromSync(showToast ? 90 : 140, { passive: !showToast });
            return true;
        }

        async function pushToServer(data, options = {}) {
            if (!SERVER_SYNC.enabled) return;
            const allowPatch = options.allowPatch === true;
            if (!allowPatch && isLikelyCorruptRoster(data)) {
                updateSyncStatus('offline', 'Offline');
                if (!options.silent) {
                    showAlert('Local roster looks incomplete. Sync upload blocked to protect master data. Pulling from Master Server...', 'warning');
                }
                pullFromServer(false).catch(() => {});
                return false;
            }
            // Mark outbound payload immediately so concurrent pulls do not overwrite unsynced local edits.
            pendingSyncPayload = data;
            updateSyncStatus('syncing', 'Syncing');
            // If we're already pushing now, cancel any scheduled push to avoid duplicate POSTs.
            if (pendingPushTimer) {
                clearTimeout(pendingPushTimer);
                pendingPushTimer = null;
            }
            const baseUrls = getSyncBaseUrls();
            // Browser fetches must be same-origin (cross-origin peer fetches are blocked by CORS on LAN).
            // Server will forward replication to peers using SYNC_PEERS.
            // Try same-origin first, then configured primary as fallback.
            const writeTargets = Array.from(new Set([
                getCurrentSyncBaseUrl(),
                getPrimarySyncBaseUrl()
            ].filter(Boolean)));
            if (!writeTargets.length) {
                updateSyncStatus('offline', 'Offline');
                return false;
            }
            let successCount = 0;
            let conflictCount = 0;
            let authFailureCount = 0;
            let respondedCount = 0;
            let timeoutCount = 0;
            let newestStamp = 0;
            let newestIso = '';
            for (const baseUrl of writeTargets) {
                try {
                    let resp = await fetchWithTimeout(buildSyncUrl(baseUrl, SERVER_SYNC.dataUrl), {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        credentials: 'include',
                        body: JSON.stringify({ data, peers: baseUrls })
                    }, 45000);
                    respondedCount += 1;
                    if (resp.status === 401 || resp.status === 403) {
                        // Session might be stale after server restart; refresh session context once and retry.
                        const refreshed = await loadSessionContext(1);
                        if (refreshed) {
                            resp = await fetchWithTimeout(buildSyncUrl(baseUrl, SERVER_SYNC.dataUrl), {
                                method: 'POST',
                                headers: { 'Content-Type': 'application/json' },
                                credentials: 'include',
                                body: JSON.stringify({ data, peers: baseUrls })
                            }, 45000);
                        }
                        if (resp.status === 401 || resp.status === 403) {
                            authFailureCount += 1;
                            if (!options.silent) {
                                showAlert('Sync failed: please re-login on this device.', 'warning');
                            }
                            continue;
                        }
                    }
                    if (resp.status === 409) {
                        conflictCount += 1;
                        continue;
                    }
                    if (!resp.ok) throw new Error('Server error');
                    const payload = await resp.json();
                    successCount += 1;
                    const stamp = parseSyncStamp(payload.updated_at);
                    if (stamp >= newestStamp) {
                        newestStamp = stamp;
                        newestIso = payload.updated_at || newestIso;
                    }
                } catch (err) {
                    if (err && err.name === 'AbortError') {
                        timeoutCount += 1;
                    }
                    continue;
                }
            }
            if (successCount > 0) {
                const savedData = db.getData();
                pendingSyncPayload = null;
                if (newestIso) {
                    savedData.server_updated_at = newestIso;
                    savedData.updated_at = newestIso;
                    db.saveData(savedData, { system: true, skipSync: true, preserveTimestamp: true, skipBackup: true });
                    setLastSyncTime(newestIso);
                } else {
                    setLastSyncTime(new Date().toISOString());
                }
                // Sync succeeded — clear any pending WAL entry for this device.
                try { localStorage.removeItem(WAL_KEY); } catch (e) {}
                updateSyncStatus('online', `Online (${successCount}/${writeTargets.length})`);
                return true;
            }
            if (conflictCount > 0) {
                updateSyncStatus('online', 'Online (refreshing)');
                await pullFromServer(false, true);
                // After merging server data locally, re-push so any local-only entries
                // (e.g. CR assignments, leadership posts) that were newer than server reach the server.
                scheduleServerPush(db.getData());
                return true;
            }
            if (authFailureCount > 0) {
                updateSyncStatus('online', 'Online (login required)');
                return false;
            }
            if (respondedCount > 0) {
                updateSyncStatus('online', 'Online (sync rejected)');
                if (!options.silent) {
                    showAlert('Server reachable, but sync payload was rejected. Pulling latest snapshot now.', 'warning');
                }
                await pullFromServer(false, true);
                return false;
            }
            if (timeoutCount > 0) {
                updateSyncStatus('online', 'Online (sync timeout)');
                if (!options.silent) {
                    showAlert('Sync timed out while processing a large snapshot. Please retry once.', 'warning');
                }
                return false;
            }
            // ── Write-ahead log ──────────────────────────────────────────────────────
            // All targets were unreachable. Persist the payload to a WAL slot in
            // localStorage so the next successful sync can replay it.
            updateSyncStatus('offline', 'Offline');
            try {
                const walEntry = JSON.stringify({ ts: new Date().toISOString(), data: JSON.stringify(data) });
                localStorage.setItem(WAL_KEY, walEntry);
            } catch (e) { /* WAL write failure is non-fatal */ }
            if (!options.silent) {
                showAlert('All configured servers are unreachable. Changes are saved locally and queued for sync.', 'warning');
            }
            return false;
        }

        function schedulePullFromServer(showToast = false, delayMs = 220, forceFull = false) {
            if (!SERVER_SYNC.enabled) return;
            pullDebouncedToast = pullDebouncedToast || showToast;
            pullDebouncedForceFull = pullDebouncedForceFull || forceFull;
            if (pullDebounceTimer) {
                clearTimeout(pullDebounceTimer);
            }
            const waitMs = Math.max(0, parseInt(delayMs, 10) || 0);
            pullDebounceTimer = setTimeout(() => {
                pullDebounceTimer = null;
                const toast = pullDebouncedToast;
                const queuedForceFull = pullDebouncedForceFull;
                pullDebouncedToast = false;
                pullDebouncedForceFull = false;
                pullFromServer(toast, queuedForceFull);
            }, waitMs);
        }

        // forceFull=true → skip ?since so the server always returns the full snapshot.
        // Use this for explicit user-triggered refreshes to guarantee fresh data.
        async function pullFromServer(showToast = false, forceFull = false) {
            if (!SERVER_SYNC.enabled) return;
            if (pullInFlightPromise) {
                pullQueuedToast = pullQueuedToast || showToast;
                pullQueuedForceFull = pullQueuedForceFull || forceFull;
                return pullInFlightPromise;
            }
            pullInFlightPromise = (async () => {
            const isBackgroundPull = !showToast && !forceFull;
            if (!isBackgroundPull) {
                updateSyncStatus('syncing', 'Syncing');
            }
            const baseUrls = getSyncBaseUrls();
            // Same-origin only: avoids CORS failures when the UI is opened from a backup node.
            // Backup nodes should receive replicated updates from master and serve them locally.
            const readTargets = [getCurrentSyncBaseUrl() || getPrimarySyncBaseUrl()].filter(Boolean);
            if (!readTargets.length) {
                updateSyncStatus('offline', 'Offline');
                return false;
            }
            const localData = db.getData();
            const localStamp = getDataStamp(localData);
            const since = String(localData && localData.server_updated_at || '').trim();
            const localRosterCount = Array.isArray(localData && localData.students) ? localData.students.length : 0;
            const localActiveCountForSince = getActiveStudentCount(localData);
            const localCurrentRosterCountForSince = getCurrentMonthRosterVisibilityCount(localData);
            const localLooksSuspiciousForSince =
                (
                    localCurrentRosterCountForSince > 0 &&
                    localCurrentRosterCountForSince < MIN_SAFE_STUDENT_ROSTER &&
                    localActiveCountForSince >= MIN_SAFE_STUDENT_ROSTER
                ) ||
                (
                    localRosterCount >= MIN_SAFE_STUDENT_ROSTER &&
                    localActiveCountForSince > 0 &&
                    localActiveCountForSince < MIN_SAFE_STUDENT_ROSTER
                );
            // forceFull bypasses ?since — guarantees fresh full snapshot from server.
            // Used for explicit pull requests so teachers/admins always see latest data.
            const canUseSince = !forceFull && !!since && localRosterCount >= MIN_SAFE_STUDENT_ROSTER && !localLooksSuspiciousForSince;
            const readPath = canUseSince ? `${SERVER_SYNC.dataUrl}?since=${encodeURIComponent(since)}` : SERVER_SYNC.dataUrl;
            const fetchTasks = readTargets.map(async (baseUrl) => {
                try {
                    const resp = await fetchWithTimeout(buildSyncUrl(baseUrl, readPath), { cache: 'no-store', credentials: 'include' }, 9000);
                    if (resp.status === 204) {
                        return { baseUrl, notModified: true };
                    }
                    const payload = await resp.json();
                    if (payload && payload.data) {
                        return {
                            baseUrl,
                            data: payload.data,
                            updatedAt: payload.updated_at || payload.data.server_updated_at || payload.data.updated_at || ''
                        };
                    }
                } catch (err) {
                    return null;
                }
                return null;
            });
            const results = (await Promise.all(fetchTasks)).filter(Boolean);
            const snapshots = results.filter(item => item && item.data);
            const notModified = results.filter(item => item && item.notModified);
            if (!snapshots.length && notModified.length) {
                updateSyncStatus('online', `Online (${notModified.length}/${readTargets.length})`);
                if (since) {
                    setLastSyncTime(since);
                }
                return true;
            }

            const roleNeedsAuthoritativeSync = currentUserRole === 'teacher' || currentUserRole === 'student';
            // Override shrink guard only when local data is missing/tiny.
            // When admin has a healthy local roster (≥25 students), NEVER let a server snapshot
            // with fewer students win — even on a forceFull pull.  This stops the FEB26_SEED
            // (46 students) from overwriting a healthy 91-student local cache on page load.
            const localLooksHealthy = localRosterCount >= MIN_SAFE_STUDENT_ROSTER;
            const canOverrideShrinkGuard = roleNeedsAuthoritativeSync || (forceFull && !localLooksHealthy);
            const shrinkRejected = snapshots.filter(item => isSuspiciousStudentShrink(localData, item.data));
            const tinyRosterRejected = snapshots.filter(item => isLikelyCorruptRoster(item.data));
            let safeSnapshots = snapshots
                .filter(item => !isSuspiciousStudentShrink(localData, item.data))
                .filter(item => !isLikelyCorruptRoster(item.data));
            if (!safeSnapshots.length && canOverrideShrinkGuard) {
                // Authoritative/explicit pulls may recover from locally bloated/stale caches.
                // Tiny roster protection still applies.
                safeSnapshots = snapshots.filter(item => !isLikelyCorruptRoster(item.data));
            }
            if (shrinkRejected.length) {
                console.warn('[SYNC] Ignored snapshot(s) with shrinking student roster');
            }
            if (tinyRosterRejected.length) {
                console.warn('[SYNC] Ignored snapshot(s) with incomplete student roster');
            }

            if (!safeSnapshots.length) {
                updateSyncStatus('online', 'Online (waiting master snapshot)');
                if (showToast) {
                    showAlert('Servers reachable, but all snapshots were rejected as unsafe/incomplete. Waiting for Master Server.', 'warning');
                }
                return false;
            }

            safeSnapshots.sort((a, b) => getDataStamp(b.data, b.updatedAt) - getDataStamp(a.data, a.updatedAt));
            const latest = safeSnapshots[0];
            const latestStamp = getDataStamp(latest.data, latest.updatedAt);
            const newestIso = latest.updatedAt || latest.data.server_updated_at || latest.data.updated_at || new Date().toISOString();

            const localCount = Array.isArray(localData && localData.students) ? localData.students.length : 0;
            const remoteCount = Array.isArray(latest.data && latest.data.students) ? latest.data.students.length : 0;
            const localLooksShrunk = isSuspiciousStudentShrink(latest.data, localData);
            const remoteLooksBetterRoster =
                remoteCount >= 25 &&
                (localCount === 0 || localCount < 25 || remoteCount >= localCount + 5 || localLooksShrunk);
            const localActiveCount = getActiveStudentCount(localData);
            const remoteActiveCount = getActiveStudentCount(latest.data);
            const remoteHasHealthierActiveSet =
                remoteActiveCount >= MIN_SAFE_STUDENT_ROSTER &&
                (localActiveCount === 0 || localActiveCount < MIN_SAFE_STUDENT_ROSTER) &&
                remoteActiveCount >= (localActiveCount + 5);

            const localCurrentRosterCount = getCurrentMonthRosterVisibilityCount(localData);
            const remoteCurrentRosterCount = getCurrentMonthRosterVisibilityCount(latest.data);
            const remoteHasHealthierCurrentRoster =
                localCurrentRosterCount > 0 &&
                localCurrentRosterCount < MIN_SAFE_STUDENT_ROSTER &&
                (
                    remoteCurrentRosterCount >= MIN_SAFE_STUDENT_ROSTER ||
                    (remoteCurrentRosterCount === 0 && remoteActiveCount >= MIN_SAFE_STUDENT_ROSTER)
                );

            const hasLocalData = !!(localData && localData.students && localData.students.length);
            // If local Office/Leadership data got wiped by a partial import or a bad local cache,
            // prefer the server snapshot when it is clearly more complete, even if local timestamps look newer.
            const localLeadershipCount = Array.isArray(localData && localData.leadership) ? localData.leadership.length : 0;
            const remoteLeadershipCount = Array.isArray(latest.data && latest.data.leadership) ? latest.data.leadership.length : 0;
            const localGroupCRCount = Array.isArray(localData && localData.group_crs) ? localData.group_crs.length : 0;
            const remoteGroupCRCount = Array.isArray(latest.data && latest.data.group_crs) ? latest.data.group_crs.length : 0;
            const localPartiesCount = Array.isArray(localData && localData.parties) ? localData.parties.length : 0;
            const remotePartiesCount = Array.isArray(latest.data && latest.data.parties) ? latest.data.parties.length : 0;
            const remoteOfficeLooksMoreComplete =
                (remoteLeadershipCount > 0 && localLeadershipCount === 0) ||
                (remoteGroupCRCount > 0 && localGroupCRCount === 0) ||
                (remotePartiesCount > 0 && localPartiesCount === 0);
            let hasPendingLocalWrites = !!pendingSyncPayload;
            if (!hasPendingLocalWrites) {
                try {
                    const walRaw = localStorage.getItem(WAL_KEY);
                    hasPendingLocalWrites = !!(walRaw && walRaw.trim().length);
                } catch (e) {
                    hasPendingLocalWrites = !!pendingSyncPayload;
                }
            }
            // Teachers/students get authoritative replace only when they have no pending local writes.
            // When forceFull=true but local writes are pending, merge mode is used to preserve
            // unsaved attendance edits (e.g. 'absent' marks not yet pushed to server).
            const preferAuthoritativeServerApply = roleNeedsAuthoritativeSync && !hasPendingLocalWrites;

            const shouldApplyRemote =
                forceFull ||                       // explicit refresh/master-update must always evaluate remote snapshot
                preferAuthoritativeServerApply ||
                (roleNeedsAuthoritativeSync && !hasPendingLocalWrites) ||
                remoteOfficeLooksMoreComplete ||
                remoteLooksBetterRoster ||
                remoteHasHealthierActiveSet ||
                remoteHasHealthierCurrentRoster ||
                latestStamp > localStamp ||
                (!hasLocalData && safeSnapshots.length > 0);
            if (shouldApplyRemote) {
                applyRemoteSnapshot(latest.data, newestIso, showToast, {
                    preferServerConflicts: preferAuthoritativeServerApply,
                    authoritativeReplace: preferAuthoritativeServerApply,
                    allowShrinkOverride: canOverrideShrinkGuard
                });
            } else if (
                !forceFull &&
                !preferAuthoritativeServerApply &&
                !localLooksShrunk &&
                localStamp > latestStamp &&
                currentUserRole === 'admin' &&         // teachers must NOT silently overwrite server data
                !isLikelyCorruptRoster(localData) &&   // never auto-push an incomplete local roster
                !isSuspiciousStudentShrink(latest.data, localData)  // don't push if pushing would shrink server
            ) {
                // Local admin copy is newer; queue a push instead of overwriting local data.
                scheduleServerPush(localData);
            }

            if (latestStamp > lastKnownRemoteStamp) {
                lastKnownRemoteStamp = latestStamp;
            }
            updateSyncStatus('online', `Online (${safeSnapshots.length}/${readTargets.length})`);
            setLastSyncTime(newestIso);

            // Connectivity restored: flush queued local writes quickly for convergence.
            if (pendingSyncPayload && (currentUserRole === 'admin' || currentUserRole === 'teacher')) {
                await pushToServer(pendingSyncPayload, { silent: true });
            }

            // ── WAL replay ───────────────────────────────────────────────────────────
            // If a previous push failed while offline, a WAL entry was saved. Now that
            // we have connectivity, replay the WAL payload so the data reaches the server.
            try {
                const walRaw = localStorage.getItem(WAL_KEY);
                if (walRaw) {
                    const wal = JSON.parse(walRaw);
                    if (wal && wal.data) {
                        const walData = JSON.parse(wal.data);
                        if (walData && typeof walData === 'object') {
                            localStorage.removeItem(WAL_KEY); // remove before push to avoid loop
                            await pushToServer(walData, { silent: true });
                        }
                    }
                }
            } catch (e) {
                try { localStorage.removeItem(WAL_KEY); } catch (_) {}
            }

            return true;
            })();
            try {
                return await pullInFlightPromise;
            } finally {
                pullInFlightPromise = null;
                if (pullQueuedToast || pullQueuedForceFull) {
                    const toast = pullQueuedToast;
                    const queuedForceFull = pullQueuedForceFull;
                    pullQueuedToast = false;
                    pullQueuedForceFull = false;
                    schedulePullFromServer(toast, 80, queuedForceFull);
                }
            }
        }

        function startRealtimeSync() {
            if (!ENABLE_REALTIME_SYNC) {
                return;
            }
            if (!SERVER_SYNC.enabled || typeof EventSource === 'undefined') {
                return;
            }
            // Use same-origin SSE for reliability (avoids CORS). Backup nodes will receive replicated
            // updates from master and broadcast events locally.
            const baseUrl = getCurrentSyncBaseUrl() || getPrimarySyncBaseUrl();
            if (!baseUrl) return;

            const eventUrl = buildSyncUrl(baseUrl, '/scoreboard/offline-events');
            if (realtimeSyncSource) {
                realtimeSyncSource.close();
            }

            realtimeSyncSource = new EventSource(eventUrl, { withCredentials: true });
            realtimeSyncSource.addEventListener('sync', (event) => {
                try {
                    const payload = JSON.parse(event.data || '{}');
                    const stamp = parseSyncStamp(payload.updated_at);
                    // Ignore heartbeat/empty events. Pull only when server stamp advances.
                    if (!stamp) {
                        return;
                    }
                    if (stamp <= lastKnownRemoteStamp) {
                        return;
                    }
                    lastKnownRemoteStamp = stamp;
                    schedulePullFromServer(false, 120, false);
                } catch (err) {
                    // Ignore malformed event payloads to avoid pull storms.
                }
            });
            realtimeSyncSource.onerror = () => {
                if (realtimeSyncSource) {
                    realtimeSyncSource.close();
                    realtimeSyncSource = null;
                }
                if (realtimeReconnectTimer) clearTimeout(realtimeReconnectTimer);
                realtimeReconnectTimer = setTimeout(() => startRealtimeSync(), 2500);
            };
        }

        async function forcePublishNow() {
            if (forcePublishRunning) return;
            if (!SERVER_SYNC.enabled) {
                showAlert('Force Publish requires LAN server mode (http://...).', 'warning');
                return;
            }
            if (currentUserRole !== 'admin') {
                showAlert('Only Admin can use Force Publish.', 'warning');
                return;
            }
            forcePublishRunning = true;
            const btn = document.getElementById('globalPublishBtn');
            const prevHtml = btn ? btn.innerHTML : '';
            if (btn) {
                btn.disabled = true;
                btn.innerHTML = '<i class="fas fa-sync fa-spin"></i> Publishing';
            }
            try {
                const pushed = await withTimeout(pushToServer(db.getData(), { silent: false }), 90000);
                if (!pushed) {
                    showAlert('Force Publish could not reach server. Local data remains safe.', 'warning');
                } else {
                    // Publish already succeeded; refresh is best-effort and must not turn success into failure.
                    try {
                        await withTimeout(pullFromServer(true, true), 30000);
                        showAlert('Force Publish complete. Server snapshot updated and reloaded.', 'success');
                    } catch (pullErr) {
                        showAlert('Force Publish succeeded, but refresh timed out. Use Refresh once.', 'warning');
                    }
                }
            } catch (err) {
                const msg = (err && err.message) ? String(err.message) : 'unexpected error';
                showAlert(`Force Publish failed (${msg}). Local data remains safe.`, 'warning');
            } finally {
                if (btn) {
                    btn.disabled = false;
                    btn.innerHTML = prevHtml || '<i class="fas fa-upload"></i> Force Publish';
                }
                forcePublishRunning = false;
            }
        }

        async function maybeAutoPublishAdminSnapshot() {
            if (adminAutoPublishAttempted) return;
            adminAutoPublishAttempted = true;
            if (!SERVER_SYNC.enabled || currentUserRole !== 'admin') return;
            if (masterUpdateRunning || forcePublishRunning) return;

            const localData = db.getData() || {};
            if (isLikelyCorruptRoster(localData)) return;

            const localStudents = getStudentRosterCount(localData);
            const localScores = Array.isArray(localData.scores) ? localData.scores.length : 0;
            if (localStudents < MIN_SAFE_STUDENT_ROSTER) return;

            let remoteData = null;
            let remoteUpdatedAt = '';
            try {
                const resp = await fetchWithTimeout(SERVER_SYNC.dataUrl, { cache: 'no-store', credentials: 'include' }, 4500);
                if (!resp.ok) return;
                const payload = await resp.json();
                if (!payload || !payload.data || typeof payload.data !== 'object') return;
                remoteData = payload.data;
                remoteUpdatedAt = payload.updated_at || '';
            } catch (err) {
                return;
            }

            const remoteStudents = getStudentRosterCount(remoteData);
            const remoteScores = Array.isArray(remoteData.scores) ? remoteData.scores.length : 0;
            const localStamp = getDataStamp(localData);
            const remoteStamp = getDataStamp(remoteData, remoteUpdatedAt);

            // Never auto-publish if local appears to shrink a healthy remote roster.
            if (!isLikelyCorruptRoster(remoteData) && isSuspiciousStudentShrink(remoteData, localData)) {
                return;
            }

            const localNotBehindCounts = localStudents >= remoteStudents && localScores >= Math.floor(remoteScores * 0.9);
            const localClearlyAheadByCount = localStudents >= remoteStudents && localScores >= (remoteScores + 50);
            const remoteLikelyBad = isLikelyCorruptRoster(remoteData) && !isLikelyCorruptRoster(localData);
            const localLikelyAhead = localNotBehindCounts && (localStamp > remoteStamp || localClearlyAheadByCount || remoteLikelyBad);

            if (!localLikelyAhead) return;

            try {
                const pushed = await pushToServer(localData, { silent: true });
                if (pushed) {
                    await pullFromServer(false, true);
                    showAlert('Admin data was ahead of server and has been auto-published.', 'success');
                }
            } catch (err) {
                // silent safety path
            }
        }

        function syncNow() {
            runMasterUpdate();
        }

        function setMasterUpdateButtonState(isRunning, remainingSeconds = 3) {
            const button = document.getElementById('masterUpdateBtn');
            if (!button) return;
            button.disabled = isRunning;
            if (isRunning) {
                button.innerHTML = `<i class="fas fa-sync fa-spin"></i> Updating (${remainingSeconds}s)`;
            } else {
                button.innerHTML = `<i class="fas fa-bolt"></i> Master Update (3s)`;
            }
        }

        function delay(ms) {
            return new Promise(resolve => setTimeout(resolve, ms));
        }

        async function withTimeout(promise, timeoutMs) {
            const ms = Math.max(1, parseInt(timeoutMs, 10) || 1);
            return await Promise.race([
                promise,
                delay(ms).then(() => { throw new Error('timeout'); })
            ]);
        }

        async function runMasterUpdate() {
            if (masterUpdateRunning) return;
            if (!SERVER_SYNC.enabled) {
                showAlert('Master Update requires LAN server mode (http://...).', 'warning');
                return;
            }

            masterUpdateRunning = true;
            const totalWindowMs = 3000;
            const checkpointsMs = [0, 1000, 2000];
            const canPush = currentUserRole === 'admin' || currentUserRole === 'teacher';
            const startedAt = Date.now();
            setMasterUpdateButtonState(true, 3);
            showAlert('Master update started. Syncing all configured servers for 3 seconds.', 'info');

            try {
                let pushFailures = 0;
                let pullFailures = 0;
                for (const targetOffset of checkpointsMs) {
                    const waitMs = startedAt + targetOffset - Date.now();
                    if (waitMs > 0) {
                        await delay(waitMs);
                    }

                    const elapsed = Date.now() - startedAt;
                    const remaining = Math.max(0, Math.ceil((totalWindowMs - elapsed) / 1000));
                    setMasterUpdateButtonState(true, remaining);

                    if (canPush) {
                        // Render cold-start/network jitter can exceed short timeouts.
                        try {
                            await withTimeout(pushToServer(db.getData(), { silent: true }), 15000);
                        } catch (e) {
                            pushFailures += 1;
                        }
                    }
                    try {
                        await withTimeout(pullFromServer(false, true), 15000);
                    } catch (e) {
                        pullFailures += 1;
                    }
                }

                const remainingFinal = Math.max(0, Math.ceil((totalWindowMs - (Date.now() - startedAt)) / 1000));
                if (remainingFinal > 0) {
                    await delay(remainingFinal * 1000);
                }
                try {
                    await withTimeout(pullFromServer(false, true), 15000); // forceFull on final pass
                } catch (e) {
                    pullFailures += 1;
                }
                if (pushFailures || pullFailures) {
                    showAlert(`Master update finished with warnings (push fails: ${pushFailures}, pull fails: ${pullFailures}). Local data is safe; sync will continue in background.`, 'warning');
                } else {
                    showAlert('Master update complete. Devices should converge within a few seconds.', 'success');
                }
            } catch (err) {
                showAlert('Master update encountered an error. Local data is safe.', 'warning');
            } finally {
                masterUpdateRunning = false;
                setMasterUpdateButtonState(false, 3);
            }
        }

        function downloadServerBackup() {
            if (!SERVER_SYNC.enabled) {
                showAlert('Server sync is only available when using the LAN URL.', 'warning');
                return;
            }
            const baseUrls = getSyncBaseUrls();
            const baseUrl = getCurrentSyncBaseUrl() || baseUrls[0];
            if (!baseUrl) {
                showAlert('No server URL configured', 'danger');
                return;
            }
            window.location.href = buildSyncUrl(baseUrl, SERVER_SYNC.backupUrl);
        }

        function filterStudentsByStatus(students, status, month) {
            const visible = students.filter(student => isStudentVisibleForMonth(student, month));
            if (month && month !== getCurrentMonthKey()) {
                return visible;
            }
            if (status === 'active') {
                return visible.filter(student => student.active !== false);
            }
            if (status === 'inactive') {
                return visible.filter(student => student.active === false);
            }
            return visible;
        }

        function getAttendanceStudentsByStatus(students, status) {
            const all = Array.isArray(students) ? students.filter(Boolean) : [];
            if (status === 'active') return all.filter(student => student.active !== false);
            if (status === 'inactive') return all.filter(student => student.active === false);
            return all;
        }

        function getRecordScoreStudentCandidates(month, statusFilter) {
            const monthKey = month || getCurrentMonthKey();
            const students = db.getStudents();
            const profiles = db.getMonthRosterProfiles(monthKey);
            if (!profiles || profiles.length === 0) {
                return filterStudentsByStatus(students, statusFilter, monthKey);
            }

            const byRoll = new Map();
            const byName = new Map();
            students.forEach(student => {
                const rollKey = normalizeRoll(student.roll);
                const nameKey = normalizeText(student.base_name || student.name || '');
                if (rollKey) {
                    if (!byRoll.has(rollKey)) byRoll.set(rollKey, []);
                    byRoll.get(rollKey).push(student);
                }
                if (nameKey) {
                    if (!byName.has(nameKey)) byName.set(nameKey, []);
                    byName.get(nameKey).push(student);
                }
            });

            const matched = [];
            profiles.forEach(profile => {
                const rollKey = normalizeRoll(profile && profile.roll);
                const nameKey = normalizeText(profile && (profile.base_name || profile.name) || '');
                let candidates = rollKey ? (byRoll.get(rollKey) || []) : [];
                if (!candidates.length && nameKey) {
                    candidates = byName.get(nameKey) || [];
                }
                if (!candidates.length) return;
                let chosen = null;
                if (nameKey) {
                    chosen = candidates.find(c => normalizeText(c.base_name || c.name || '') === nameKey) || null;
                }
                if (!chosen) {
                    chosen = candidates.find(c => c.active !== false) || candidates[0];
                }
                if (chosen) {
                    matched.push(chosen);
                }
            });

            const unique = [];
            const seen = new Set();
            matched.forEach(student => {
                if (seen.has(student.id)) return;
                seen.add(student.id);
                unique.push(student);
            });

            if (monthKey !== getCurrentMonthKey()) {
                return unique;
            }
            if (statusFilter === 'active') {
                return unique.filter(student => student.active !== false);
            }
            if (statusFilter === 'inactive') {
                return unique.filter(student => student.active === false);
            }
            return unique;
        }

        function isAwfColumn(column) {
            const key = String(safeProp(column, 'key') || '').trim().toLowerCase();
            const label = String(safeProp(column, 'label') || '').trim().toLowerCase();
            return key === 'awf' || label === 'awf';
        }

        function getVisibleDateWindowIndices(allDates, month) {
            const dates = Array.isArray(allDates) ? allDates : [];
            if (!dates.length) return [];
            // Always return all dates for proper horizontal scrolling
            return dates.map((_, index) => index);
        }

        function addMonths(dateStr, months) {
            if (!dateStr) return null;
            const date = new Date(dateStr);
            if (Number.isNaN(date.getTime())) return null;
            const year = date.getFullYear();
            const month = date.getMonth() + months;
            const day = date.getDate();
            const result = new Date(year, month, day);
            return formatDateKey(result);
        }

        function addDays(dateStr, days) {
            if (!dateStr) return null;
            const date = new Date(dateStr);
            if (Number.isNaN(date.getTime())) return null;
            const result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + days);
            return formatDateKey(result);
        }

        function formatDateKey(dateObj) {
            const date = dateObj instanceof Date ? dateObj : new Date(dateObj);
            if (Number.isNaN(date.getTime())) return '';
            const year = date.getFullYear();
            const month = String(date.getMonth() + 1).padStart(2, '0');
            const day = String(date.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        function normalizeDateKey(value) {
            const raw = String(value || '').trim();
            if (/^\d{4}-\d{2}-\d{2}$/.test(raw)) return raw;
            const parsed = new Date(raw);
            if (Number.isNaN(parsed.getTime())) return '';
            return formatDateKey(parsed);
        }

        function parseDateKeyToLocalDate(dateKey) {
            const text = String(dateKey || '').trim();
            const match = text.match(/^(\d{4})-(\d{2})-(\d{2})$/);
            if (!match) return null;
            const year = parseInt(match[1], 10);
            const month = parseInt(match[2], 10);
            const day = parseInt(match[3], 10);
            if (!year || !month || !day) return null;
            return new Date(year, month - 1, day);
        }

        function formatDateMonthDayLabel(dateKey) {
            const localDate = parseDateKeyToLocalDate(dateKey);
            if (!localDate || Number.isNaN(localDate.getTime())) return dateKey;
            return localDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        }

        function getMonthDateRange(monthKey) {
            const value = String(monthKey || '').trim();
            if (!/^\d{4}-\d{2}$/.test(value)) return [];
            const [yearText, monthText] = value.split('-');
            const year = parseInt(yearText, 10);
            const monthIndex = parseInt(monthText, 10) - 1;
            if (Number.isNaN(year) || Number.isNaN(monthIndex) || monthIndex < 0 || monthIndex > 11) return [];
            const start = new Date(year, monthIndex, 1);
            const end = new Date(year, monthIndex + 1, 0);
            const dates = [];
            for (let day = 1; day <= end.getDate(); day += 1) {
                const date = new Date(year, monthIndex, day);
                dates.push(formatDateKey(date));
            }
            return dates;
        }

        let scoreboardScrollSyncBound = false;
        let scoreboardScrollSyncBusy = false;
        let _sbLastHeaderKey = '';
        function getScoreboardDayScrollMetrics(bottom, headerRow) {
            const bottomMax = Math.max(0, (bottom && bottom.scrollWidth ? bottom.scrollWidth : 0) - (bottom && bottom.clientWidth ? bottom.clientWidth : 0));
            if (!bottom || !headerRow) {
                return {
                    dayStart: 0,
                    dayMax: bottomMax,
                    bottomMax,
                    stickyLeftWidth: 0,
                    stickyRightWidth: 0,
                    dayWidth: 0,
                    dayViewport: Math.max(0, (bottom && bottom.clientWidth) ? bottom.clientWidth : 0)
                };
            }
            const dateHeaders = Array.from(headerRow.querySelectorAll('th[data-score-date]'));
            if (!dateHeaders.length) {
                return {
                    dayStart: 0,
                    dayMax: bottomMax,
                    bottomMax,
                    stickyLeftWidth: 0,
                    stickyRightWidth: 0,
                    dayWidth: 0,
                    dayViewport: Math.max(0, (bottom && bottom.clientWidth) ? bottom.clientWidth : 0)
                };
            }
            const first = dateHeaders[0];
            const last = dateHeaders[dateHeaders.length - 1];
            const stickyLeftWidth = Array.from(headerRow.querySelectorAll('th.sticky-left'))
                .reduce((sum, th) => sum + (th.offsetWidth || 0), 0);
            const stickyRightWidth = Array.from(headerRow.querySelectorAll('th.sticky-right'))
                .reduce((sum, th) => sum + (th.offsetWidth || 0), 0);
            const firstLeft = first ? (first.offsetLeft || 0) : 0;
            const lastRight = last ? ((last.offsetLeft || 0) + (last.offsetWidth || 0)) : firstLeft;
            const totalDayWidth = Math.max(0, lastRight - firstLeft);
            const visibleDayWidth = Math.max(0, (bottom.clientWidth || 0) - stickyLeftWidth - stickyRightWidth);
            const dayMax = Math.max(0, totalDayWidth - visibleDayWidth);
            const dayStart = Math.max(0, firstLeft - stickyLeftWidth);
            return {
                dayStart,
                dayMax,
                bottomMax,
                stickyLeftWidth,
                stickyRightWidth,
                dayWidth: totalDayWidth,
                dayViewport: visibleDayWidth
            };
        }
        function syncScoreboardDualScrollbars() {
            const top = document.getElementById('scoreboardTopScroll');
            const spacer = document.getElementById('scoreboardTopScrollSpacer');
            const bottom = document.getElementById('scoreboardBottomScroll');
            const table = document.getElementById('scoreboardTable');
            const headerRow = document.getElementById('scoreboardHeaderRow');
            if (!top || !spacer || !bottom || !table) return;

            const metrics = getScoreboardDayScrollMetrics(bottom, headerRow);
            // Top scrollbar is for day columns only: align it over day viewport.
            if (metrics.dayViewport > 0) {
                top.style.marginLeft = `${metrics.stickyLeftWidth}px`;
                top.style.marginRight = `${metrics.stickyRightWidth}px`;
            } else {
                top.style.marginLeft = '0px';
                top.style.marginRight = '0px';
            }
            const effectiveViewport = Math.max(0, metrics.dayViewport || top.clientWidth || 0);
            const topWidth = Math.max(metrics.dayWidth || 0, effectiveViewport + 1);
            spacer.style.width = `${topWidth}px`;
            // Always show the top scrollbar so users can see it without scrolling to the bottom.
            top.style.display = 'block';

            if (!scoreboardScrollSyncBound) {
                top.addEventListener('scroll', () => {
                    if (scoreboardScrollSyncBusy) return;
                    const activeHeaderRow = document.getElementById('scoreboardHeaderRow');
                    const activeMetrics = getScoreboardDayScrollMetrics(bottom, activeHeaderRow);
                    scoreboardScrollSyncBusy = true;
                    const nextTop = Math.max(0, Math.min(top.scrollLeft, activeMetrics.dayMax));
                    const nextBottom = Math.max(0, Math.min(activeMetrics.dayStart + nextTop, activeMetrics.bottomMax));
                    bottom.scrollLeft = nextBottom;
                    scoreboardScrollSyncBusy = false;
                }, { passive: true });
                bottom.addEventListener('scroll', () => {
                    if (scoreboardScrollSyncBusy) return;
                    const activeHeaderRow = document.getElementById('scoreboardHeaderRow');
                    const activeMetrics = getScoreboardDayScrollMetrics(bottom, activeHeaderRow);
                    scoreboardScrollSyncBusy = true;
                    const mappedTop = Math.max(0, Math.min((bottom.scrollLeft || 0) - activeMetrics.dayStart, activeMetrics.dayMax));
                    top.scrollLeft = mappedTop;
                    scoreboardScrollSyncBusy = false;
                }, { passive: true });
                scoreboardScrollSyncBound = true;
            }

            const mappedTop = Math.max(0, Math.min((bottom.scrollLeft || 0) - metrics.dayStart, metrics.dayMax));
            if (Math.abs((top.scrollLeft || 0) - mappedTop) > 1) {
                top.scrollLeft = mappedTop;
            }
        }

        function scrollScoreboardToCurrentDateWindow(month) {
            if (String(month || '') !== getCurrentMonthKey()) return;
            const top = document.getElementById('scoreboardTopScroll');
            const bottom = document.getElementById('scoreboardBottomScroll');
            const headerRow = document.getElementById('scoreboardHeaderRow');
            if (!top || !bottom || !headerRow) return;
            const today = formatDateKey(new Date());
            const dateHeaders = Array.from(headerRow.querySelectorAll('th[data-score-date]'));
            if (!dateHeaders.length) return;

            let currentIndex = dateHeaders.findIndex(th => String(th.getAttribute('data-score-date') || '') === today);
            if (currentIndex < 0) {
                const nextIndex = dateHeaders.findIndex(th => String(th.getAttribute('data-score-date') || '') > today);
                currentIndex = nextIndex === -1 ? dateHeaders.length - 1 : Math.max(0, nextIndex - 1);
            }

            const startIndex = Math.max(0, currentIndex - 5);
            const anchorHeader = dateHeaders[startIndex] || dateHeaders[0];
            if (!anchorHeader) return;

            const stickyLeftHeaders = Array.from(headerRow.querySelectorAll('th.sticky-left'));
            const stickyRightHeaders = Array.from(headerRow.querySelectorAll('th.sticky-right'));
            const stickyLeftWidth = stickyLeftHeaders.reduce((sum, th) => sum + (th.offsetWidth || 0), 0);
            const stickyRightWidth = stickyRightHeaders.reduce((sum, th) => sum + (th.offsetWidth || 0), 0);
            const maxScroll = Math.max(0, bottom.scrollWidth - bottom.clientWidth);

            let nextLeft = Math.max(0, (anchorHeader.offsetLeft || 0) - stickyLeftWidth);
            const rightIndex = Math.min(dateHeaders.length - 1, currentIndex + 2);
            const rightHeader = dateHeaders[rightIndex];
            if (rightHeader) {
                const rightEdgeOffset = (rightHeader.offsetLeft || 0) + (rightHeader.offsetWidth || 0);
                const visibleRightBoundary = nextLeft + bottom.clientWidth - stickyRightWidth;
                if (rightEdgeOffset > visibleRightBoundary) {
                    nextLeft += (rightEdgeOffset - visibleRightBoundary);
                }
            }
            nextLeft = Math.max(0, Math.min(nextLeft, maxScroll));
            bottom.scrollLeft = nextLeft;
            const metrics = getScoreboardDayScrollMetrics(bottom, headerRow);
            top.scrollLeft = Math.max(0, Math.min(nextLeft - metrics.dayStart, metrics.dayMax));
        }

        function formatDateLabel(dateStr) {
            if (!dateStr) return '-';
            const date = new Date(dateStr);
            if (Number.isNaN(date.getTime())) return '-';
            return date.toLocaleDateString('en-US', { day: '2-digit', month: 'short', year: 'numeric' });
        }

        function normalizePostHolderStatus(value) {
            const text = String(value || '').trim().toLowerCase();
            if (text === 'suspended') return 'suspended';
            if (text === 'vacant') return 'vacant';
            if (text === 'ended') return 'ended';
            return 'active';
        }

        function getTenureMonthsForAssignment(source, postName) {
            const sourceKey = String(source || '').trim().toLowerCase();
            if (sourceKey === 'class_rep' || sourceKey === 'group_cr') return 1;
            if (sourceKey === 'leadership') {
                const text = String(postName || '').trim().toLowerCase();
                if (text.includes('co-leader') || text.includes('co leader') || text.includes('(col)')) return 1;
            }
            return 2;
        }

        function isAssignmentActiveByTenure(electedOn, tenureMonths = 2, extensionMonths = 0, onDate = '') {
            const start = String(electedOn || '').trim();
            if (!start) return false;
            const totalMonths = Math.max(0, (parseInt(tenureMonths, 10) || 0) + (parseInt(extensionMonths, 10) || 0));
            const end = addMonths(start, totalMonths);
            if (!end) return false;
            const checkDate = String(onDate || formatDateKey(new Date())).trim();
            return checkDate >= start && checkDate <= end;
        }

        function getDayDiff(fromDateKey, toDateKey) {
            const from = new Date(String(fromDateKey || '') + 'T00:00:00');
            const to = new Date(String(toDateKey || '') + 'T00:00:00');
            if (Number.isNaN(from.getTime()) || Number.isNaN(to.getTime())) return null;
            return Math.ceil((to.getTime() - from.getTime()) / (1000 * 60 * 60 * 24));
        }

        function getPostHolderStatusInfo(statusValue, electedOn, tenureMonths = 2, extensionMonths = 0) {
            const status = normalizePostHolderStatus(statusValue);
            const totalMonths = Math.max(0, (parseInt(tenureMonths, 10) || 0) + (parseInt(extensionMonths, 10) || 0));
            const end = addMonths(electedOn, totalMonths);
            const today = formatDateKey(new Date());
            const diff = end ? getDayDiff(today, end) : null;
            const overdue = typeof diff === 'number' ? diff < 0 : false;
            const dueSoon = typeof diff === 'number' ? diff >= 0 && diff <= 7 : false;
            if (status === 'vacant') {
                return { key: 'vacant', label: 'Vacant', end: '-', dueSoon: false, overdue: false, daysToEnd: null };
            }
            if (status === 'ended') {
                return { key: 'ended', label: 'Ended', end: end || '-', dueSoon: false, overdue: false, daysToEnd: diff };
            }
            if (status === 'suspended') {
                return { key: 'suspended', label: 'Suspended', end: end || '-', dueSoon: false, overdue, daysToEnd: diff };
            }
            return { key: 'active', label: 'Active', end: end || '-', dueSoon, overdue, daysToEnd: diff };
        }

        function isAssignmentEffectivelyActive(statusValue, electedOn, tenureMonths = 2, extensionMonths = 0, onDate = '') {
            const statusInfo = getPostHolderStatusInfo(statusValue, electedOn, tenureMonths, extensionMonths);
            if (statusInfo.key !== 'active') return false;
            return isAssignmentActiveByTenure(electedOn, tenureMonths, extensionMonths, onDate);
        }

        function renderPostStatusBadge(statusInfo) {
            const info = statusInfo || { key: 'vacant', label: 'Vacant' };
            let cls = 'fee-status fee-due';
            if (info.key === 'active') cls = 'fee-status fee-paid';
            if (info.key === 'suspended') cls = 'fee-status fee-overdue';
            if (info.key === 'ended') cls = 'fee-status';
            return `<span class="${cls}">${escapeHtml(info.label)}</span>`;
        }

        function getTenureStatus(electedOn, tenureMonths = 2, extensionMonths = 0) {
            if (!electedOn) return { status: 'Unknown', end: '-' };
            const totalMonths = Math.max(0, (parseInt(tenureMonths, 10) || 0) + (parseInt(extensionMonths, 10) || 0));
            const end = addMonths(electedOn, totalMonths);
            if (!end) return { status: 'Unknown', end: '-' };
            const today = formatDateKey(new Date());
            return {
                status: today <= end ? 'Active' : 'Expired',
                end
            };
        }

        function getLeadershipRoleType(postName) {
            const text = String(postName || '').trim().toLowerCase();
            if (!text) return '';
            if (text.includes('leader of opposition') || text.includes('(lop)')) return 'lop';
            if (text.includes('co-leader') || text.includes('co leader') || text.includes('(col)')) return 'co_leader';
            if ((text.includes('leader') || text.includes('(l)')) && !text.includes('opposition')) return 'leader';
            return '';
        }

        function getLeadershipVetoQuota(postName) {
            const roleType = getLeadershipRoleType(postName);
            if (roleType === 'leader') return 5;
            if (roleType === 'co_leader') return 3;
            if (roleType === 'lop') return 2;
            return 0;
        }

        function getActiveRoleVetoQuotas(dateKey = formatDateKey(new Date())) {
            const data = db.getData();
            const quotas = new Map();
            const addQuota = (studentId, amount) => {
                const sid = parseInt(studentId, 10);
                const quota = parseInt(amount, 10) || 0;
                if (!sid || quota <= 0) return;
                quotas.set(sid, (quotas.get(sid) || 0) + quota);
            };

            (data.leadership || []).forEach(post => {
                if (normalizePostHolderStatus(post.status) !== 'active') return;
                const tenureMonths = getTenureMonthsForAssignment('leadership', post.post);
                const extensionMonths = parseInt(post.tenure_extension_months, 10) || 0;
                if (!isAssignmentActiveByTenure(post.elected_on, tenureMonths, extensionMonths, dateKey)) return;
                const quota = getLeadershipVetoQuota(post.post);
                if (quota <= 0) return;
                const resolved = resolveLeadershipStudent(post);
                if (!resolved || !resolved.id) return;
                if (isStudentPostHolderSuspendedById(resolved.id, dateKey)) return;
                addQuota(resolved.id, quota);
            });

            // CR quota: +2 once per student if either class CR or group CR is active.
            const crStudents = new Set();
            (data.class_reps || []).forEach(rep => {
                if (normalizePostHolderStatus(rep.status || 'active') !== 'active') return;
                const tenureMonths = getTenureMonthsForAssignment('class_rep', rep.post || 'CR');
                const extensionMonths = parseInt(rep.tenure_extension_months, 10) || 0;
                if (!isAssignmentActiveByTenure(rep.elected_on, tenureMonths, extensionMonths, dateKey)) return;
                const sid = parseInt(rep.studentId, 10);
                if (sid) crStudents.add(sid);
            });
            (data.group_crs || []).forEach(rep => {
                if (normalizePostHolderStatus(rep.status || 'active') !== 'active') return;
                const tenureMonths = getTenureMonthsForAssignment('group_cr', rep.post || 'CR');
                const extensionMonths = parseInt(rep.tenure_extension_months, 10) || 0;
                if (!isAssignmentActiveByTenure(rep.elected_on, tenureMonths, extensionMonths, dateKey)) return;
                const sid = parseInt(rep.studentId, 10);
                if (sid) crStudents.add(sid);
            });
            crStudents.forEach(sid => {
                if (isStudentPostHolderSuspendedById(sid, dateKey)) return;
                addQuota(sid, 2);
            });

            return quotas;
        }

        function applyMonthlyRoleVetoGrants(options = {}) {
            const data = db.getData();
            data.role_veto_monthly = data.role_veto_monthly || {};
            const monthKey = String(options.month || getCurrentMonthKey()).trim();
            if (!monthKey) return false;
            const appliedMonth = String(data.role_veto_applied_month || '').trim();
            const todayKey = String(options.dateKey || formatDateKey(new Date())).trim();
            const targetMap = getActiveRoleVetoQuotas(todayKey);
            const monthState = data.role_veto_monthly[monthKey] || {};
            const nextMonthState = {};
            const studentById = new Map((data.students || []).map(item => [parseInt(item.id, 10), item]));
            let changed = false;

            if (appliedMonth && appliedMonth !== monthKey) {
                const prevState = data.role_veto_monthly[appliedMonth] || {};
                Object.entries(prevState).forEach(([sidText, grantValue]) => {
                    const sid = parseInt(sidText, 10);
                    const grant = Math.max(0, parseInt(grantValue, 10) || 0);
                    if (!sid || grant <= 0) return;
                    const student = studentById.get(sid);
                    if (!student) return;
                    student.veto_count = Math.max(0, (parseInt(student.veto_count, 10) || 0) - grant);
                    changed = true;
                });
            }

            const keySet = new Set();
            Object.keys(monthState || {}).forEach(key => keySet.add(String(key)));
            targetMap.forEach((_, sid) => keySet.add(String(sid)));

            keySet.forEach(key => {
                const sid = parseInt(key, 10);
                if (!sid) return;
                const oldGrant = Math.max(0, parseInt(monthState[key], 10) || 0);
                const targetGrant = Math.max(0, parseInt(targetMap.get(sid), 10) || 0);
                const delta = targetGrant - oldGrant;
                if (delta !== 0) {
                    const student = studentById.get(sid);
                    if (student) {
                        student.veto_count = Math.max(0, (parseInt(student.veto_count, 10) || 0) + delta);
                        changed = true;
                    }
                }
                if (targetGrant > 0) {
                    nextMonthState[key] = targetGrant;
                }
            });

            data.role_veto_monthly[monthKey] = nextMonthState;
            data.role_veto_applied_month = monthKey;

            if (!changed && JSON.stringify(monthState || {}) === JSON.stringify(nextMonthState)) {
                return false;
            }
            if (options.persist === false) return true;
            if (currentUserRole === 'teacher') {
                db.saveData(data, { allowTeacher: true });
            } else if (currentUserRole === 'admin') {
                db.saveData(data);
            } else {
                db._cacheData = data;
            }
            return true;
        }

        function reconcileVetoCountersFromScores(monthKey = getCurrentMonthKey(), options = {}) {
            const data = db.getData();
            const month = String(monthKey || '').trim();
            if (!month) return false;
            const grants = (data.role_veto_monthly && data.role_veto_monthly[month]) || {};
            const netByStudent = {};
            (data.scores || []).forEach(row => {
                if (String(row.month || '') !== month) return;
                const sid = parseInt(row.studentId, 10);
                if (!sid) return;
                netByStudent[sid] = (netByStudent[sid] || 0) + (parseInt(row.vetos, 10) || 0);
            });
            let changed = false;
            Object.entries(netByStudent).forEach(([sidText, netValue]) => {
                const sid = parseInt(sidText, 10);
                if (!sid) return;
                const student = (data.students || []).find(s => parseInt(s.id, 10) === sid);
                if (!student) return;
                const grant = parseInt(grants[String(sid)], 10) || 0;
                const expected = Math.max(0, grant + (parseInt(netValue, 10) || 0));
                const actual = parseInt(student.veto_count, 10) || 0;
                if (expected !== actual) {
                    student.veto_count = expected;
                    changed = true;
                }
            });
            if (!changed) return false;
            if (options.persist === false) return true;
            if (currentUserRole === 'teacher') {
                db.saveData(data, { allowTeacher: true });
            } else if (currentUserRole === 'admin') {
                db.saveData(data);
            } else {
                db._cacheData = data;
            }
            return true;
        }

        function isPartyPresidentDesignation(designation) {
            if (!designation) return false;
            const text = String(designation).trim().toLowerCase();
            // Only "Party President" counts as an office-holder role for visuals/suffixes.
            // DPP (Deputy Party President) should NOT get post-holder visuals.
            return text === 'party president' || text === 'pp';
        }

        function formatDesignationShort(designation) {
            const text = String(designation || '').trim();
            const lower = text.toLowerCase();
            if (!text) return '';
            if (lower === 'party president' || lower === 'pp') return 'PP';
            if (lower === 'deputy party president' || lower === 'dpp') return 'DPP';
            if (lower === 'secretary') return '';
            return text;
        }

        /**
         * When the calendar rolls to a new month and no roster exists for it yet,
         * silently copy the previous month's active roster (admin only).
         * Stars and VETOs are snapshotted from each student's current global totals
         * so historical views of this month will show correct carry-in balances.
         * Returns true if a new roster was created, false otherwise.
         */
        function autoCreateNewMonthRosterIfNeeded() {
            if (currentUserRole !== 'admin') return false;
            const data = db.getData();
            const todayMonth = getCurrentMonthKey();
            // Already has a roster for today's month — nothing to do
            const existing = data.month_students && data.month_students[todayMonth];
            if (existing && existing.length > 0) return false;
            // Find the most recent previous month that has a roster
            const allMonths = db.getMonths(); // sorted descending
            const prevMonth = allMonths.find(m => m < todayMonth);
            if (!prevMonth) return false;
            const prevRolls = (data.month_students && data.month_students[prevMonth]) || [];
            if (!prevRolls.length) return false;
            // Build new month profiles: copy names/classes from prev profiles,
            // snapshot current star/veto totals from student records.
            const prevProfiles = (data.month_roster_profiles && data.month_roster_profiles[prevMonth]) || [];
            const studentsByRoll = new Map();
            (data.students || []).forEach(s => {
                const r = normalizeRosterValue(s.roll);
                if (r) studentsByRoll.set(r, s);
            });
            const newProfiles = [];
            prevRolls.forEach(rollRaw => {
                const roll = normalizeRosterValue(rollRaw);
                if (!roll || !isValidRollNo(roll)) return;
                const student = studentsByRoll.get(roll);
                const prev = prevProfiles.find(p => normalizeRosterValue(p.roll) === roll);
                const name = (student && (student.name || student.base_name)) || (prev && prev.name) || roll;
                const baseName = (student && (student.base_name || student.name)) || (prev && prev.base_name) || roll;
                if (!isValidStudentName(baseName)) return;
                const classRaw = (student && student.class) || (prev && prev.class);
                const classNum = parseInt(classRaw, 10);
                newProfiles.push({
                    roll,
                    name: name || baseName,
                    base_name: baseName,
                    class: Number.isNaN(classNum) ? null : classNum,
                    month_star_count: student ? Math.max(0, parseInt(student.stars, 10) || 0) : 0,
                    month_veto_count: student ? Math.max(0, parseInt(student.veto_count, 10) || 0) : 0,
                    month_designations: []
                });
            });
            if (!newProfiles.length) return false;
            data.month_students = data.month_students || {};
            data.month_roster_profiles = data.month_roster_profiles || {};
            data.month_students[todayMonth] = newProfiles.map(p => p.roll);
            data.month_roster_profiles[todayMonth] = newProfiles;
            db.saveData(data);
            console.log(`[AutoMonth] Created ${todayMonth} roster from ${prevMonth} (${newProfiles.length} students)`);
            return true;
        }

        function loadScoreboard() {
            if (localRosterNeedsRecovery()) {
                rosterRecoveryQueuedTab = 'scoreboard';
                renderRosterRecoveryPlaceholder('Recovering safe roster from Master Server...');
                attemptRosterRecovery();
                return;
            }
            // Auto-create new month roster when the calendar rolls over
            autoCreateNewMonthRosterIfNeeded();

            const months = db.getMonths();
            const todayMonth = getCurrentMonthKey();
            const savedMonth = localStorage.getItem(ACTIVE_SCOREBOARD_MONTH_KEY) || '';
            const currentMonth = (
                (savedMonth && months.includes(savedMonth) && savedMonth) ||
                (months.includes(todayMonth) ? todayMonth : '') ||
                months[0] ||
                todayMonth
            );

            // Populate month dropdown
            const monthSelector = document.getElementById('monthSelector');
            monthSelector.innerHTML = months.map(month => {
                const [year, monthNum] = month.split('-');
                const date = new Date(year, monthNum - 1);
                const label = date.toLocaleDateString('en-US', { year: 'numeric', month: 'short' });
                return `<option value="${month}"${month === currentMonth ? ' selected' : ''}>${label}</option>`;
            }).join('');

            loadMonthScoreboard(currentMonth);
            if (document.getElementById('groupMonthFilter')) {
                loadGroupScoreboard();
            }
        }

        /**
         * Auto-suspend a post-holder after 72h of rank/VETO breach.
         * Only executes when an admin session is active.
         * @param {number} sid          - student ID
         * @param {string|null} preferTable - 'leadership'|'group_crs'|'class_reps'|null (null = all)
         * @param {string} reason       - human-readable reason stored in suspend_reason field
         * @param {number} penaltyPoints - negative score deducted today (e.g. -200 for Leader)
         */
        function _autoSuspendPostHolder(sid, preferTable, reason, penaltyPoints) {
            if (currentUserRole !== 'admin') return;
            const data = db.getData();
            let changed = false;
            // Track whether any suspended entry is still within its normal tenure
            // (penalty is waived if the holder has already served their full term).
            let withinNormalTenure = false;

            // Normal tenure in months per table/role:
            // Leadership — Leader (L): 2 months; Co-Leader/LoP/others: 1 month
            // group_crs / class_reps: 1 month
            function _normalMonths(tbl, entry) {
                if (tbl !== 'leadership') return 1; // all CR types: 1 month
                // Co-Leader is 1 month; Leader, LoP, and every other leadership role is 2 months
                const pn = String(entry.postName || entry.title || entry.post || '').toUpperCase();
                if (pn.includes('CO-LEADER') || pn.includes('CO LEADER') || pn.includes('(COL)')) return 1;
                return 2;
            }

            function _isExtended(tbl, entry) {
                const raw = entry.assigned_on || entry.start_date || entry.startDate || entry.from;
                if (!raw) return false;
                const d = new Date(raw);
                if (isNaN(d.getTime())) return false;
                const today = new Date();
                const elapsed = (today.getFullYear() - d.getFullYear()) * 12
                              + (today.getMonth() - d.getMonth());
                return elapsed >= _normalMonths(tbl, entry);
            }

            const tables = preferTable
                ? [preferTable, ...['leadership', 'group_crs', 'class_reps'].filter(t => t !== preferTable)]
                : ['leadership', 'group_crs', 'class_reps'];
            tables.forEach(tbl => {
                (data[tbl] || []).forEach(entry => {
                    if (parseInt(entry.studentId, 10) === sid &&
                            normalizePostHolderStatus(entry.status || 'active') === 'active') {
                        entry.status = 'suspended';
                        entry.suspended_on = formatDateKey(new Date());
                        entry.suspend_reason = reason || 'Auto-suspended by system';
                        changed = true;
                        if (!_isExtended(tbl, entry)) withinNormalTenure = true;
                    }
                });
            });
            if (changed) {
                // Penalty applies ONLY when suspended within normal tenure (not on extended service)
                if (penaltyPoints && penaltyPoints < 0 && withinNormalTenure) {
                    const _today = formatDateKey(new Date());
                    const _monthKey = _today.substring(0, 7);
                    // Accumulate penalty onto today's existing score (do NOT replace it).
                    const _prevScore = db.getScore(sid, _today);
                    const _prevPts = _prevScore ? (parseInt(_prevScore.points, 10) || 0) : 0;
                    db.addScore({
                        id: _prevScore ? _prevScore.id : Date.now(),
                        studentId: sid,
                        date: _today,
                        month: _monthKey,
                        points: _prevPts + penaltyPoints,
                        stars: _prevScore ? (parseInt(_prevScore.stars, 10) || 0) : 0,
                        vetos: _prevScore ? (parseInt(_prevScore.vetos, 10) || 0) : 0,
                        notes: (_prevScore && _prevScore.notes ? _prevScore.notes + ' | ' : '') + `[Auto-suspension penalty] ${reason}`,
                        recordedBy: 'system'
                    });
                }
                savePostHolderData(data);
                const student = (db.getStudents() || []).find(s => parseInt(s.id, 10) === sid);
                const name = student ? (student.name || `Student #${sid}`) : `Student #${sid}`;
                const penaltyMsg = (penaltyPoints && withinNormalTenure)
                    ? ` (${penaltyPoints} pts deducted)` : ' (no penalty — extended tenure)';
                showAlert(`Auto-suspended: ${name} — ${reason}${penaltyMsg}`, 'warning');
            }
        }

        // ─── Auto-Suspend Exemption Helpers ──────────────────────────────────────
        // Returns { type: 'waived' } or { type: 'veto_shield' } if an active post record
        // for this student has either an admin waiver or a VETO shield active.
        // Called inside the 72h enforcement block before deciding whether to suspend.
        function _getAutoSuspendExemption(sid) {
            const data = db.getData();
            for (const tbl of ['leadership', 'group_crs', 'class_reps']) {
                for (const entry of (data[tbl] || [])) {
                    if (parseInt(entry.studentId, 10) !== sid) continue;
                    if (normalizePostHolderStatus(entry.status || 'active') !== 'active') continue;
                    if (entry.auto_suspend_waived) return { type: 'waived' };
                    if (entry.veto_shield_active) return { type: 'veto_shield' };
                }
            }
            // Check party president members
            for (const party of (data.parties || [])) {
                for (const member of (party.members || [])) {
                    if (parseInt(member.studentId, 10) !== sid) continue;
                    if (normalizePostHolderStatus(member.status || 'active') !== 'active') continue;
                    if (!isPartyPresidentDesignation(member.designation)) continue;
                    if (member.auto_suspend_waived) return { type: 'waived' };
                    if (member.veto_shield_active) return { type: 'veto_shield' };
                }
            }
            return null;
        }

        // Handles an active exemption: waiver just clears the clock; VETO shield is consumed
        // (one-time use) and then the clock is cleared. Neither path suspends the holder.
        function _consumeAutoSuspendExemption(sid, exemptionType, wKey) {
            const student = (db.getStudents() || []).find(s => parseInt(s.id, 10) === sid);
            const name = student ? (student.base_name || student.name || `Student #${sid}`) : `Student #${sid}`;
            if (exemptionType === 'waived') {
                localStorage.removeItem(wKey);
                showAlert(`Auto-suspension waived for ${name} — admin waiver is active.`, 'info');
            } else if (exemptionType === 'veto_shield') {
                // Consume the shield (one-time use) and clear the warning clock
                const data = db.getData();
                let consumed = false;
                for (const tbl of ['leadership', 'group_crs', 'class_reps']) {
                    for (const entry of (data[tbl] || [])) {
                        if (parseInt(entry.studentId, 10) === sid && entry.veto_shield_active) {
                            entry.veto_shield_active = false;
                            consumed = true;
                            break;
                        }
                    }
                    if (consumed) break;
                }
                if (!consumed) {
                    for (const party of (data.parties || [])) {
                        for (const member of (party.members || [])) {
                            if (parseInt(member.studentId, 10) === sid && member.veto_shield_active) {
                                member.veto_shield_active = false;
                                consumed = true;
                                break;
                            }
                        }
                        if (consumed) break;
                    }
                }
                if (consumed) {
                    localStorage.removeItem(wKey);
                    // Persist only the flag change — no full post-holder resync needed
                    suspendedPostHolderCache.key = '';
                    suspendedPostHolderCache.ids = new Set();
                    votePowerSuspendedPostHolderCache.key = '';
                    votePowerSuspendedPostHolderCache.ids = new Set();
                    roleDisplayCache.key = '';
                    roleDisplayCache.ctx = null;
                    db.saveData(data);
                    showAlert(`VETO Shield activated — auto-suspension blocked for ${name}. Shield has been consumed.`, 'success');
                }
            }
        }
        // ─────────────────────────────────────────────────────────────────────────

        function loadMonthScoreboard(month, filterOnly) {
            try {
            if (month) {
                localStorage.setItem(ACTIVE_SCOREBOARD_MONTH_KEY, month);
            }
            // Sync month dropdown selection
            const _sel = document.getElementById('monthSelector');
            if (_sel && _sel.tagName === 'SELECT' && _sel.value !== month) _sel.value = month;

            let scoreboard = db.getMonthlyScoreboard(month);
            const allDates = (scoreboard.length && Array.isArray(scoreboard[0].dates))
                ? scoreboard[0].dates.slice()
                : [...new Set(db.getScoresForMonth(month).map(s => normalizeDateKey(s.date)).filter(Boolean))].sort();
            const dateWindowIndices = getVisibleDateWindowIndices(allDates, month);
            const dates = dateWindowIndices.map(index => allDates[index]).filter(Boolean);
            const monthExtraCols = db.getMonthExtraColumns(month);
            const classFilter = document.getElementById('classFilter').value;
            const groupFilter = getElementValue('groupFilter') || 'all';
            const searchValue = document.getElementById('searchStudent').value.toLowerCase().trim();
            const statusFilter = getElementValue('statusFilter') || 'all';
            const effectiveStatusFilter = month === getCurrentMonthKey() ? statusFilter : 'all';

            // Single-pass combined filter (avoids 5 separate array traversals)
            const _needsFilter = classFilter || (groupFilter && groupFilter !== 'all') ||
                searchValue || (effectiveStatusFilter && effectiveStatusFilter !== 'all') ||
                (currentUserRole === 'student' && currentStudentRoll);
            if (_needsFilter) {
                scoreboard = scoreboard.filter(row => {
                    if (classFilter && String(row.student.class) !== classFilter) return false;
                    if (groupFilter && groupFilter !== 'all' && getStudentGroup(row.student) !== groupFilter) return false;
                    if (searchValue && !(
                        (row.student.base_name || row.student.name || '').toLowerCase().includes(searchValue) ||
                        (row.student.roll || '').toLowerCase().includes(searchValue)
                    )) return false;
                    if (effectiveStatusFilter && effectiveStatusFilter !== 'all') {
                        const isActive = row.student.active !== false;
                        if (effectiveStatusFilter === 'active' && !isActive) return false;
                        if (effectiveStatusFilter !== 'active' && isActive) return false;
                    }
                    return true;
                });
            }

            // Student privacy: top 20 shown + own row appended if below rank 20
            let _myExtraRow = null;
            if (currentUserRole === 'student' && currentStudentRoll && !searchValue) {
                const _myIdx = scoreboard.findIndex(r =>
                    r.student && String(r.student.roll || '').trim().toUpperCase() === String(currentStudentRoll).trim().toUpperCase());
                if (_myIdx >= 20) {
                    _myExtraRow = { row: scoreboard[_myIdx], rank: _myIdx + 1, total: scoreboard.length };
                    scoreboard = [...scoreboard.slice(0, 20), null, scoreboard[_myIdx]];
                } else {
                    scoreboard = scoreboard.slice(0, Math.max(20, _myIdx >= 0 ? _myIdx + 1 : 0));
                }
            }

            const table = document.getElementById('scoreboardTable');
            const headerRow = document.getElementById('scoreboardHeaderRow');
            const tbody = document.getElementById('scoreboardBody');

            // Update header with dates
            const dateHeaders = dates.map(date => {
                return `<th style="min-width: 50px;" data-score-date="${date}">${formatDateMonthDayLabel(date)}</th>`;
            }).join('');
            const rightPinnedBase = 96 + 150;
            const extraPinnedMeta = monthExtraCols.map((col, idx) => {
                const right = rightPinnedBase + ((monthExtraCols.length - 1 - idx) * 95);
                return { ...col, right };
            });
            const extraHeaders = extraPinnedMeta.map(col => {
                const awfCol = isAwfColumn(col);
                const dataCol = awfCol ? ' data-col="awf"' : '';
                return `<th class="sticky-right extra-fixed" style="right: ${col.right}px;"${dataCol}>${escapeHtml(col.label)}</th>`;
            }).join('');
            // Only rebuild the header when the structure actually changes (month, dates, extra cols).
            // Filter-only calls leave dates/cols unchanged — skip the DOM write to avoid layout thrash.
            const _headerKey = `${month}|${dates.join(',')}|${monthExtraCols.map(c => c.key || c.label || '').join('|')}`;
            if (_headerKey !== _sbLastHeaderKey) {
                _sbLastHeaderKey = _headerKey;
                headerRow.innerHTML = `
                    <th class="sticky-left rank-cell" style="width: 70px;">Rank</th>
                    <th class="sticky-left sticky-left-1" style="width: 92px;">Roll No.</th>
                    <th class="sticky-left sticky-left-2" style="width: 320px;">Student Name</th>
                    <th class="sticky-left sticky-left-3" style="width: 60px;">Class</th>
                    <th class="sticky-left sticky-left-4" style="width: 70px;" data-col="fees">Fees</th>
                    ${dateHeaders}
                    ${extraHeaders}
                    <th class="sticky-right sticky-right-1 total-cell" style="width: 150px; background: #fbbf24 !important;">Total<br>Score</th>
                    <th class="sticky-right vote-cell" style="width: 96px;">Vote<br>Power</th>
                `;
            }

            // Update stats
            document.getElementById('currentMonth').textContent = new Date(month + '-01').toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            document.getElementById('totalStudents').textContent = scoreboard.length;
            const avgScore = scoreboard.length > 0 ? Math.round(scoreboard.reduce((sum, row) => sum + row.total, 0) / scoreboard.length) : 0;
            document.getElementById('avgScore').textContent = avgScore;
            if (scoreboard.length > 0) {
                const topName = (scoreboard[0].student.base_name || scoreboard[0].student.name || '');
                const topEl = document.getElementById('topScorer');
                if (topEl) {
                    topEl.textContent = topName.substring(0, 20) + (topName.length > 20 ? '...' : '');
                    topEl.classList.add('top-scorer-name');
                    topEl.style.fontSize = 'clamp(20px, 2.2vw, 30px)';
                }
            }

            // ── Post-holder rank / VETO status detection (current month only) ──────────
            const _isCurrentMonth = (month === getCurrentMonthKey());
            const _leaderIds       = new Set();   // students holding the LEADER post
            const _depletedHolders = new Set();   // post-holders with veto_count ≤ 0
            if (_isCurrentMonth) {
                const _chkDate = formatDateKey(new Date());
                const _rdc = buildRoleDisplayContext(_chkDate);
                // leader = student whose active suffix includes 'L'
                _rdc.suffixesById.forEach((suffixes, sid) => {
                    if (suffixes.has('L')) _leaderIds.add(sid);
                });
                // post-holder with depleted VETOs
                const _students = db.getStudents() || [];
                _rdc.officeHolderIds.forEach(sid => {
                    const _s = _students.find(s => parseInt(s.id, 10) === sid);
                    if (_s && (parseInt(_s.veto_count, 10) || 0) <= 0) _depletedHolders.add(sid);
                });

                // ── 72-hour auto-suspend enforcement (effective from 2026-02-23) ──────
                // Timestamps are stored in localStorage; actual suspension only by admin.
                const _EFFECT_FROM_MS = new Date('2026-02-23T00:00:00').getTime();
                const _NOW_MS = Date.now();
                const _72H_MS = 72 * 60 * 60 * 1000;

                // Leader rank check: must stay in Top 10; 72h grace → suspend (-200 pts)
                // An admin waiver or active VETO shield blocks the suspension.
                scoreboard.forEach((row, idx) => {
                    const sid = parseInt(row.student.id, 10);
                    if (!_leaderIds.has(sid)) return;
                    const rank = idx + 1;
                    const wKey = `ea_rank_warn_${sid}`;
                    if (rank > 10) {
                        const stored = localStorage.getItem(wKey);
                        if (!stored) {
                            // First detection — start the 72h clock
                            localStorage.setItem(wKey, String(_NOW_MS));
                        } else {
                            const warnSince = parseInt(stored, 10);
                            if (warnSince >= _EFFECT_FROM_MS && (_NOW_MS - warnSince) >= _72H_MS) {
                                const _exemption = _getAutoSuspendExemption(sid);
                                if (_exemption) {
                                    // Waiver or VETO shield active — block suspension
                                    _consumeAutoSuspendExemption(sid, _exemption.type, wKey);
                                    _leaderIds.delete(sid);
                                } else {
                                    _autoSuspendPostHolder(sid, 'leadership',
                                        'Rank dropped below Top 10 for 72+ hours', -200);
                                    localStorage.removeItem(wKey);
                                    _leaderIds.delete(sid); // no longer shows alert after suspension
                                }
                            }
                        }
                    } else {
                        localStorage.removeItem(wKey); // recovered — cancel the clock
                    }
                });

                // VETO depletion check: post-holders must maintain positive VETO; 72h grace → suspend
                // Penalty: Leader -200, Co-Leader -150, all others (CR/LoP) -100
                // An admin waiver or active VETO shield blocks the suspension.
                _rdc.officeHolderIds.forEach(sid => {
                    const wKey = `ea_veto_warn_${sid}`;
                    if (_depletedHolders.has(sid)) {
                        const stored = localStorage.getItem(wKey);
                        if (!stored) {
                            localStorage.setItem(wKey, String(_NOW_MS));
                        } else {
                            const warnSince = parseInt(stored, 10);
                            if (warnSince >= _EFFECT_FROM_MS && (_NOW_MS - warnSince) >= _72H_MS) {
                                const _exemption = _getAutoSuspendExemption(sid);
                                if (_exemption) {
                                    // Waiver or VETO shield active — block suspension
                                    _consumeAutoSuspendExemption(sid, _exemption.type, wKey);
                                    _depletedHolders.delete(sid);
                                } else {
                                    // Determine penalty by role suffix
                                    const _suf = _rdc.suffixesById.get(sid) || new Set();
                                    const _penalty = _suf.has('L') ? -200 : _suf.has('CoL') ? -150 : -100;
                                    _autoSuspendPostHolder(sid, null,
                                        'VETO power depleted for 72+ hours', _penalty);
                                    localStorage.removeItem(wKey);
                                    _depletedHolders.delete(sid);
                                }
                            }
                        }
                    } else {
                        localStorage.removeItem(wKey); // VETO restored — cancel the clock
                    }
                });
                // ─────────────────────────────────────────────────────────────────────
            }
            // ─────────────────────────────────────────────────────────────────────────

            // Populate table
            tbody.innerHTML = scoreboard.map((row, idx) => {
                // null sentinel = ellipsis separator row (student privacy mode)
                if (!row) {
                    const colSpan = 3 + dates.length + extraPinnedMeta.length;
                    return `<tr class="rank-ellipsis-row"><td colspan="${colSpan}" style="text-align:center;padding:8px 16px;color:var(--text-muted);font-style:italic;font-size:12px">· · · ranks 21 – ${_myExtraRow ? _myExtraRow.rank - 1 : '…'} not shown · · ·</td></tr>`;
                }
                const blinkClass = idx === 0 ? 'blink blink-first' : idx === 1 ? 'blink blink-second' : idx === 2 ? 'blink blink-third' : '';
                const hasDisplay = Array.isArray(row.dailyDisplay) && Array.isArray(row.dailyClasses) && row.dailyDisplay.length === row.dailyScores.length;
                const scores = dateWindowIndices.map((dateIndex) => {
                    const score = parseInt(safeProp(row.dailyScores, dateIndex), 10) || 0;
                    const scoreClass = score > 0 ? 'positive' : score < 0 ? 'negative' : '';
                    const displayValue = hasDisplay ? coalesce(safeProp(row.dailyDisplay, dateIndex), '-') : (score !== 0 ? score : '-');
                    const cellClass = hasDisplay ? (safeProp(row.dailyClasses, dateIndex) || 'score-cell') : `score-cell ${scoreClass}`;
                    const titleText = String(coalesce(safeProp(row.dailyTitles, dateIndex), '')).trim();
                    const titleAttr = titleText ? ` title="${escapeHtml(titleText)}"` : '';
                    const reasonAttr = (titleText && String(cellClass).includes('veto-used')) ? ` data-reason="${escapeHtml(titleText)}"` : '';
                    return `<td class="${cellClass}"${titleAttr}${reasonAttr}>${displayValue}</td>`;
                }).join('');
                const extraValues = extraPinnedMeta.map((col, idx) => {
                    const item = safeProp(row.extraValues, idx) || {};
                    const value = item && Object.prototype.hasOwnProperty.call(item, 'value') ? item.value : '';
                    const key = item && item.key ? item.key : '';
                    const editable = currentUserRole === 'admin' ? 'score-cell editable' : '';
                    const clickHandler = (currentUserRole === 'admin' && key)
                        ? `onclick="editMonthExtraValue('${month}', ${row.student.id}, '${key}')"`
                        : '';
                    const awfCol = isAwfColumn(item);
                    const dataCol = awfCol ? ' data-col="awf"' : '';
                    return `<td class="sticky-right extra-fixed ${editable}" style="right: ${col.right}px;" ${clickHandler}${dataCol}>${escapeHtml(value)}</td>`;
                }).join('');

                const medals = ['gold', 'silver', 'bronze'];
                const medal = idx < 3 ? `<span class="medal ${medals[idx]} ${blinkClass}">${idx + 1}</span>` : `<span style="display: inline-block; width: 32px; text-align: center; font-weight: bold;">${idx + 1}</span>`;

                // Row alert classes
                const _sid  = parseInt(row.student.id, 10);
                const _rank = idx + 1;
                const _isLeaderRow = _leaderIds.has(_sid);
                let rowClass = idx === 0 ? 'top-scorer-row' : '';
                if (_isLeaderRow && _rank > 14) {
                    rowClass += ' leader-rank-critical';
                } else if (_isLeaderRow && _rank > 9) {
                    rowClass += ' leader-rank-warning';
                }
                if (_depletedHolders.has(_sid)) rowClass += ' veto-depleted-holder';
                if (currentUserRole === 'student' && currentStudentRoll && row.student &&
                    String(row.student.roll || '').toUpperCase() === String(currentStudentRoll).toUpperCase())
                    rowClass += ' my-own-row';
                rowClass = rowClass.trim();

                return `<tr class="${rowClass}">
                    <td class="sticky-left rank-cell ${blinkClass}">${medal}</td>
                    <td class="sticky-left sticky-left-1 ${isOfficeHolderStudent(row.student, month) ? 'office-holder-roll' : ''}"><strong>${formatRollDisplay(row.student.roll)}</strong></td>
                    <td class="sticky-left sticky-left-2">${renderStudentName(row.student, month)}</td>
                    <td class="sticky-left sticky-left-3">${row.student.class}</td>
                    <td class="sticky-left sticky-left-4" data-col="fees">${coalesce(row.student.fees, '-')}</td>
                    ${scores}
                    ${extraValues}
                    <td class="score-cell total sticky-right sticky-right-1 total-cell ${blinkClass}">${row.total}</td>
                    <td class="sticky-right vote-cell ${blinkClass}">${computeVotePower(row.total)}</td>
                </tr>`;
            }).join('');

            if (tbody.children.length === 0) {
                const colCount = 7 + dates.length + monthExtraCols.length;
                tbody.innerHTML = `<tr><td colspan="${colCount}" class="text-center" style="padding: 40px; color: var(--text-muted);">No data for this month</td></tr>`;
            }
            applyColumnVisibility();
            if (!filterOnly) _animateTableRows('scoreboardTable');
            setTimeout(() => {
                syncScoreboardDualScrollbars();
                // Only scroll to current date on a full load (month switch/initial render),
                // not when the user is just typing in the search/filter — that would be jarring.
                if (!filterOnly) {
                    requestAnimationFrame(() => {
                        scrollScoreboardToCurrentDateWindow(month);
                        syncScoreboardDualScrollbars();
                    });
                }
            }, 0);
            } catch (err) {
                const tbody = document.getElementById('scoreboardBody');
                if (tbody) {
                    tbody.innerHTML = `<tr><td colspan="8" class="text-center" style="padding: 28px; color: #dc2626;">Error loading scoreboard data</td></tr>`;
                }
                showAlert('Scoreboard load error: ' + (safeProp(err, 'message') || String(err)), 'danger');
            }
        }

        function editMonthExtraValue(month, studentId, columnKey) {
            if (currentUserRole !== 'admin') {
                showAlert('Only Admin can edit these values.', 'warning');
                return;
            }
            const data = db.getData();
            const student = (data.students || []).find(s => s.id === studentId);
            if (!student) return;
            const rollKey = String(student.roll || '').trim().toUpperCase();
            const nameKey = String(student.base_name || student.name || '').trim().toUpperCase();
            const studentMonthMap = ((data.month_student_extras || {})[month] || {});
            const activeKey = rollKey || nameKey;
            if (!activeKey) return;
            const currentValues = studentMonthMap[activeKey] || {};
            const currentValue = coalesce(currentValues[columnKey], '');
            const input = prompt(`Edit value for ${student.base_name || student.name} (${columnKey})`, currentValue);
            if (input === null) return;

            if (!data.month_student_extras) data.month_student_extras = {};
            if (!data.month_student_extras[month]) data.month_student_extras[month] = {};
            if (!data.month_student_extras[month][activeKey]) data.month_student_extras[month][activeKey] = {};

            const nextValue = String(input).trim();
            if (!nextValue) {
                delete data.month_student_extras[month][activeKey][columnKey];
            } else if (/^-?\d+(\.\d+)?$/.test(nextValue)) {
                data.month_student_extras[month][activeKey][columnKey] = Number(nextValue);
            } else {
                data.month_student_extras[month][activeKey][columnKey] = nextValue;
            }
            db.saveData(data);
            loadMonthScoreboard(month);
            showAlert('Value updated', 'success');
        }

        function filterScoreboard() {
            const sel = document.getElementById('monthSelector');
            const activeMonth = sel && sel.value;
            if (activeMonth) {
                loadMonthScoreboard(activeMonth, true);
            } else {
                loadScoreboard();
            }
        }

        function initScoreForm() {
            const today = formatDateKey(new Date());
            const todayMonth = today.substring(0, 7);
            document.getElementById('scoreDate').value = today;
            document.getElementById('scoreMonth').value = todayMonth;
            document.getElementById('scoreGroupFilter').value = 'all';
            const listGroupFilter = document.getElementById('scoreGroupFilterList');
            if (listGroupFilter) listGroupFilter.value = 'all';
            document.getElementById('scoreClassFilter').value = '';
            const listClassFilter = document.getElementById('scoreClassFilterList');
            if (listClassFilter) listClassFilter.value = '';
            const statusFilter = document.getElementById('scoreStatusFilter');
            if (statusFilter) statusFilter.value = 'active';

            const months = db.getMonths();
            const monthSelect = document.getElementById('scoreMonth');
            if (!months.includes(todayMonth)) {
                months.unshift(todayMonth);
            }
            monthSelect.innerHTML = '<option value="">Select Month...</option>' + 
                months.map(m => {
                    const date = new Date(m + '-01');
                    return `<option value="${m}">${date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</option>`;
                }).join('');
            document.getElementById('scoreMonth').value = todayMonth;
            populateScoreGroupFilter();
            renderRecordScoreDateStrip(todayMonth, today);
            updateScoreStudentOptions(false);
            loadRecordStudentTable();

            document.getElementById('scoreStudent').onchange = loadExistingScore;
            document.getElementById('scoreDate').onchange = () => {
                renderRecordScoreDateStrip(getElementValue('scoreMonth') || getElementValue('scoreDate').substring(0, 7), getElementValue('scoreDate'));
                loadExistingScore();
                populateScoreGroupFilter();
                loadRecordStudentTable();
            };
            document.getElementById('scoreMonth').onchange = () => {
                const month = getElementValue('scoreMonth');
                const date = getElementValue('scoreDate');
                if (month) {
                    const bounds = getMonthDateBounds(month);
                    if (!date || !String(date).startsWith(`${month}-`)) {
                        setElementValue('scoreDate', bounds.min || date);
                    }
                }
                renderRecordScoreDateStrip(month, getElementValue('scoreDate'));
                populateScoreGroupFilter();
                updateScoreStudentOptions(true);
            };
            if (listGroupFilter) {
                listGroupFilter.onchange = () => syncRecordScoreGroupFilter();
            }
            if (listClassFilter) {
                listClassFilter.onchange = () => syncRecordScoreGroupFilter(true);
            }
        }

        function updateScoreStudentOptions(preserveSelection = true) {
            const date = getElementValue('scoreDate');
            let month = getElementValue('scoreMonth') || (date ? date.substring(0, 7) : getCurrentMonthKey());
            if (currentUserRole === 'teacher' && date) {
                month = String(date).substring(0, 7);
                const monthEl = document.getElementById('scoreMonth');
                if (monthEl) monthEl.value = month;
            }
            renderRecordScoreDateStrip(month, date);
            const statusFilter = getElementValue('scoreStatusFilter') || 'active';
            populateScoreGroupFilter();
            let students = getRecordScoreStudentCandidates(month, statusFilter);
            const profileMap = getMonthRosterProfileMap(month);
            const studentSelect = document.getElementById('scoreStudent');
            const groupFilter = getElementValue('scoreGroupFilter') || 'all';
            const classFilter = getElementValue('scoreClassFilter') || '';
            const listGroupFilter = document.getElementById('scoreGroupFilterList');
            const listClassFilter = document.getElementById('scoreClassFilterList');
            if (listGroupFilter && listGroupFilter.value && listGroupFilter.value !== groupFilter) {
                listGroupFilter.value = groupFilter;
            }
            if (listClassFilter && listClassFilter.value !== classFilter) {
                listClassFilter.value = classFilter;
            }
            const selected = studentSelect.value;

            let filtered = students;
            if (groupFilter !== 'all') {
                filtered = filtered.filter(s => getStudentGroup(s) === groupFilter);
            }
            if (classFilter) {
                filtered = filtered.filter(s => String(s.class) === String(classFilter));
            }
            filtered = filtered.sort(compareRecordStudentsByRollSuffix);

            studentSelect.innerHTML = '<option value="">Select Student...</option>' + 
                filtered.map(s => {
                    const displayStudent = getMonthAwareStudent(s, month, profileMap);
                    return `<option value="${s.id}">${displayStudent.base_name || displayStudent.name} (${s.roll}) [*${getStudentMonthStarAwardTotal(s.id, month)} V${getStudentMonthVetoAwardTotal(s.id, month)}]</option>`;
                }).join('');

            if (preserveSelection && selected) {
                const stillExists = filtered.some(s => String(s.id) === String(selected));
                if (stillExists) {
                    studentSelect.value = selected;
                }
            }
            refreshStarTransferModule(true);
            loadRecordStudentTable();
        }

        function appendTransferNote(existingNotes, transferNote) {
            const base = String(existingNotes || '').trim();
            const token = String(transferNote || '').trim();
            if (!token) return base;
            if (!base) return token;
            if (base.includes(token)) return base;
            return `${base} | ${token}`;
        }

        function getStarTransferStudentsForContext(monthKey) {
            const month = String(monthKey || '').trim() || getCurrentMonthKey();
            const groupFilter = getElementValue('scoreGroupFilter') || 'all';
            const classFilter = getElementValue('scoreClassFilter') || '';
            let students = getRecordScoreStudentCandidates(month, 'active');
            if (groupFilter !== 'all') {
                students = students.filter(s => getStudentGroup(s) === groupFilter);
            }
            if (classFilter) {
                students = students.filter(s => String(s.class) === String(classFilter));
            }
            return students.sort(compareRecordStudentsByRollSuffix);
        }

        function refreshStarTransferModule(preserveSelection = true) {
            const module = document.getElementById('starTransferModule');
            const fromSelect = document.getElementById('starTransferFrom');
            const toSelect = document.getElementById('starTransferTo');
            const transferBtn = module ? module.querySelector('button[onclick="transferStarsBetweenStudents()"]') : null;
            if (!module || !fromSelect || !toSelect) return;

            const canUse = currentUserRole === 'admin' || currentUserRole === 'teacher';
            module.style.display = canUse ? '' : 'none';
            if (!canUse) return;

            const date = String(getElementValue('scoreDate') || '').trim();
            const month = String(getElementValue('scoreMonth') || (date ? date.substring(0, 7) : getCurrentMonthKey())).trim();
            const students = getStarTransferStudentsForContext(month);
            const selectedFrom = preserveSelection ? String(fromSelect.value || '') : '';
            const selectedTo = preserveSelection ? String(toSelect.value || '') : '';

            const options = students.map(student => {
                const name = escapeHtml(String(student.base_name || student.name || 'Unknown'));
                const roll = escapeHtml(formatRollDisplay(student.roll || '') || String(student.roll || ''));
                const availableStars = Math.max(0, parseInt(student.stars, 10) || 0);
                const monthAwards = getStudentMonthStarAwardTotal(student.id, month);
                const label = `${name} (${roll}) [Avail *${availableStars} | M+${monthAwards}]`;
                return `<option value="${student.id}">${label}</option>`;
            }).join('');

            fromSelect.innerHTML = `<option value="">Select source...</option>${options}`;
            toSelect.innerHTML = `<option value="">Select destination...</option>${options}`;

            if (selectedFrom && students.some(s => String(s.id) === selectedFrom)) {
                fromSelect.value = selectedFrom;
            }
            if (selectedTo && students.some(s => String(s.id) === selectedTo)) {
                toSelect.value = selectedTo;
            }
            const hasCandidates = students.length >= 2;
            fromSelect.disabled = !hasCandidates;
            toSelect.disabled = !hasCandidates;
            if (transferBtn) transferBtn.disabled = !hasCandidates;
        }

        function transferStarsBetweenStudents() {
            if (currentUserRole !== 'admin' && currentUserRole !== 'teacher') {
                showAlert('Only Admin or Teacher can transfer stars.', 'warning');
                return;
            }
            const fromId = parseInt(getElementValue('starTransferFrom'), 10);
            const toId = parseInt(getElementValue('starTransferTo'), 10);
            const rawCount = parseInt(getElementValue('starTransferCount'), 10);
            const count = Number.isFinite(rawCount) ? rawCount : 0;
            const date = String(getElementValue('scoreDate') || '').trim();
            const month = String(getElementValue('scoreMonth') || (date ? date.substring(0, 7) : getCurrentMonthKey())).trim();

            if (!fromId || !toId) {
                showAlert('Select both source and destination students.', 'warning');
                return;
            }
            if (fromId === toId) {
                showAlert('Source and destination must be different students.', 'warning');
                return;
            }
            if (!count || count < 1) {
                showAlert('Enter a valid star transfer count (minimum 1).', 'warning');
                return;
            }
            if (!date || !/^\d{4}-\d{2}-\d{2}$/.test(date)) {
                showAlert('Select a valid score date before transferring stars.', 'warning');
                return;
            }
            if (!month || date.substring(0, 7) !== month) {
                showAlert('Score month/date mismatch. Set Month and Date correctly first.', 'warning');
                return;
            }
            if (!teacherValidateCurrentMonth(date, month, 'Star transfer')) return;

            const students = db.getStudents();
            const fromStudent = students.find(s => parseInt(s.id, 10) === fromId);
            const toStudent = students.find(s => parseInt(s.id, 10) === toId);
            if (!fromStudent || !toStudent) {
                showAlert('Unable to resolve one or both students.', 'danger');
                return;
            }

            const availability = validateStarAvailability(fromId, -count);
            if (!availability.valid) {
                showValidationModal('Insufficient Stars', availability.message);
                return;
            }

            const fromExisting = db.getScore(fromId, date);
            const toExisting = db.getScore(toId, date);
            const fromOldStars = fromExisting ? (parseInt(fromExisting.stars, 10) || 0) : 0;
            const toOldStars = toExisting ? (parseInt(toExisting.stars, 10) || 0) : 0;
            const fromNextStars = fromOldStars - count;
            const toNextStars = toOldStars + count;
            const timestamp = new Date().toISOString();
            const transferTag = `[STAR TRANSFER ${count}]`;
            const fromRoll = formatRollDisplay(fromStudent.roll || '') || String(fromStudent.roll || '');
            const toRoll = formatRollDisplay(toStudent.roll || '') || String(toStudent.roll || '');

            const fromPayload = fromExisting
                ? {
                    ...fromExisting,
                    month,
                    stars: fromNextStars,
                    notes: appendTransferNote(fromExisting.notes, `${transferTag} OUT to ${toRoll}`),
                    updated_at: timestamp
                }
                : {
                    studentId: fromId,
                    date,
                    month,
                    points: 0,
                    stars: fromNextStars,
                    vetos: 0,
                    notes: `${transferTag} OUT to ${toRoll}`,
                    recordedBy: currentUserRole
                };

            const toPayload = toExisting
                ? {
                    ...toExisting,
                    month,
                    stars: toNextStars,
                    notes: appendTransferNote(toExisting.notes, `${transferTag} IN from ${fromRoll}`),
                    updated_at: timestamp
                }
                : {
                    studentId: toId,
                    date,
                    month,
                    points: 0,
                    stars: toNextStars,
                    vetos: 0,
                    notes: `${transferTag} IN from ${fromRoll}`,
                    recordedBy: currentUserRole
                };

            pushUndoSnapshot(`Transfer ${count} star(s): ${fromRoll} -> ${toRoll}`);
            db.addScore(fromPayload);
            db.addScore(toPayload);

            if (SERVER_SYNC.enabled) {
                pushToServer(db.getData(), { silent: true });
            }

            setElementValue('starTransferCount', '');
            refreshStarTransferModule(true);
            loadScoreboard();
            if (getActiveTabName() === 'add-score') {
                loadRecordStudentTable();
                loadExistingScore();
            }
            showAlert(`Transferred ${count} star(s): ${escapeHtml(fromRoll)} -> ${escapeHtml(toRoll)} on ${date}.`, 'success');
        }

        function renderRecordScoreDateStrip(monthKey, selectedDate) {
            const strip = document.getElementById('recordScoreDateStrip');
            if (!strip) return;
            const month = String(monthKey || '').trim();
            const selected = String(selectedDate || '').trim();
            const monthLabel = document.getElementById('recordDateMonthLabel');
            const activeLabel = document.getElementById('recordDateActiveLabel');
            if (!/^\d{4}-\d{2}$/.test(month)) {
                strip.innerHTML = '';
                if (monthLabel) monthLabel.textContent = 'Month';
                if (activeLabel) activeLabel.textContent = 'Selected: -';
                return;
            }
            const [yearStr, monthStr] = month.split('-');
            const year = parseInt(yearStr, 10);
            const monthIndex = parseInt(monthStr, 10) - 1;
            if (!Number.isFinite(year) || monthIndex < 0 || monthIndex > 11) return;

            const first = new Date(year, monthIndex, 1);
            const daysInMonth = new Date(year, monthIndex + 1, 0).getDate();
            if (monthLabel) {
                monthLabel.textContent = first.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
            }
            if (activeLabel) {
                activeLabel.textContent = selected ? `Selected: ${selected}` : 'Selected: -';
            }

            const parts = [];
            for (let d = 1; d <= daysInMonth; d += 1) {
                const dateObj = new Date(year, monthIndex, d);
                const dateKey = formatDateKey(dateObj);
                const dayName = dateObj.toLocaleDateString('en-US', { weekday: 'short' });
                const activeClass = selected === dateKey ? 'active' : '';
                parts.push(
                    `<button type="button" class="record-date-chip ${activeClass}" onclick="selectRecordScoreDate('${dateKey}')">` +
                    `<span class="dnum">${d}</span><span class="dday">${dayName}</span>` +
                    `</button>`
                );
            }
            strip.innerHTML = parts.join('');

            const activeChip = strip.querySelector('.record-date-chip.active');
            if (activeChip && typeof activeChip.scrollIntoView === 'function') {
                const behavior = getActiveTabName() === 'add-score' ? 'auto' : 'smooth';
                activeChip.scrollIntoView({ behavior, inline: 'center', block: 'nearest' });
            }
        }

        function selectRecordScoreDate(dateKey) {
            if (!dateKey) return;
            setElementValue('scoreDate', dateKey);
            const month = String(dateKey).substring(0, 7);
            setElementValue('scoreMonth', month);
            renderRecordScoreDateStrip(month, dateKey);
            loadExistingScore();
            populateScoreGroupFilter();
            updateScoreStudentOptions(true);
        }

        function loadRecordStudentTable() {
            const tbody = document.getElementById('recordStudentsBody');
            if (!tbody) return;
            const groupFilter = getElementValue('scoreGroupFilter') || 'all';
            const classFilter = getElementValue('scoreClassFilter') || '';
            const date = getElementValue('scoreDate');
            let month = getElementValue('scoreMonth') || (date ? date.substring(0, 7) : getCurrentMonthKey());
            if (currentUserRole === 'teacher' && date) {
                month = String(date).substring(0, 7);
                const monthEl = document.getElementById('scoreMonth');
                if (monthEl) monthEl.value = month;
            }
            ensureRecordScoreDraftContext(date, month);
            const statusFilter = getElementValue('scoreStatusFilter') || 'active';
            let students = getRecordScoreStudentCandidates(month, statusFilter);
            const profileMap = getMonthRosterProfileMap(month);
            const monthScores = db.getScoresForMonth(month);
            const monthStarAwardByStudent = {};
            const monthVetoAwardByStudent = {};
            monthScores.forEach(score => {
                const sid = parseInt(score.studentId, 10);
                if (!sid) return;
                const starDelta = parseInt(score.stars, 10) || 0;
                const vetoDelta = parseInt(score.vetos, 10) || 0;
                if (starDelta > 0) {
                    monthStarAwardByStudent[sid] = (monthStarAwardByStudent[sid] || 0) + starDelta;
                }
                if (vetoDelta > 0) {
                    monthVetoAwardByStudent[sid] = (monthVetoAwardByStudent[sid] || 0) + vetoDelta;
                }
            });

            let filtered = students;
            if (groupFilter !== 'all') {
                filtered = filtered.filter(s => getStudentGroup(s) === groupFilter);
            }
            if (classFilter) {
                filtered = filtered.filter(s => String(s.class) === String(classFilter));
            }
            filtered = filtered.sort(compareRecordStudentsByRollSuffix);

            tbody.innerHTML = filtered.map(student => {
                const dayScore = date ? db.getScore(student.id, date) : null;
                const attendanceRecord = date ? getAttendanceRecord(student.id, date) : null;
                const attendancePenalty = getAttendancePenaltyPointsForStatus(safeProp(attendanceRecord, 'status'));
                const draft = getRecordScoreDraft(student.id);
                // Inputs show DRAFT values only (user's pending delta entry).
                // Stored totals are shown as badges, NOT in inputs.
                const pointsValue = draft && draft.points != null ? draft.points : '';
                const starsValue = draft && draft.stars != null ? draft.stars : '';
                const vetosValue = draft && draft.vetos != null ? draft.vetos : '';
                const starReasonRaw = draft && draft.starReason != null ? draft.starReason : '';
                const vetoReasonRaw = draft && draft.vetoReason != null ? draft.vetoReason : '';
                const starReasonValue = escapeHtml(String(starReasonRaw));
                const vetoReasonValue = escapeHtml(String(vetoReasonRaw));
                const hasExisting = !!dayScore;
                const storedPoints = hasExisting ? (parseInt(safeProp(dayScore, 'points'), 10) || 0) : null;
                const storedStars = hasExisting ? (parseInt(safeProp(dayScore, 'stars'), 10) || 0) : null;
                const storedVetos = hasExisting ? (parseInt(safeProp(dayScore, 'vetos'), 10) || 0) : null;
                const recordedBy = hasExisting ? String(safeProp(dayScore, 'recordedBy') || '').trim() : '';
                const storedTitleParts = [];
                if (storedPoints !== null) storedTitleParts.push(`Stored: ${storedPoints} pts`);
                if (recordedBy) storedTitleParts.push(`Recorded by: ${recordedBy}`);
                if (date && attendancePenalty < 0) storedTitleParts.push(`Attendance penalty ${attendancePenalty} is auto-applied in scoreboard total`);
                const storedBadge = storedPoints !== null
                    ? `<span class="stored-score-badge" title="${escapeHtml(storedTitleParts.join(' | '))}">${storedPoints}</span>`
                    : '';
                const attendancePenaltyBadge = (date && attendancePenalty < 0)
                    ? `<span class="stored-veto-badge" style="margin-left:6px;background:rgba(127,29,29,.35);border-color:rgba(248,113,113,.55);color:#fecaca;" title="Attendance penalty ${attendancePenalty} (${normalizeAttendanceStatus(safeProp(attendanceRecord, 'status'))}) is auto-applied to scoreboard total and is not an accidental score.">ATT ${attendancePenalty}</span>`
                    : '';
                const sourceBadge = (hasExisting && recordedBy)
                    ? `<span class="stored-star-badge" style="margin-left:6px;background:rgba(30,41,59,.75);border-color:rgba(148,163,184,.45);color:#cbd5e1;" title="This score was recorded by ${escapeHtml(recordedBy)}.">By ${escapeHtml(recordedBy)}</span>`
                    : '';
                const storedStarBadge = storedStars ? `<span class="stored-star-badge" title="Stored: ${storedStars} star(s)">${storedStars}</span>` : '';
                const starUndoBtn = (date && storedStars !== null && storedStars !== 0 && (currentUserRole === 'admin' || currentUserRole === 'teacher'))
                    ? `<button type="button" class="record-star-undo-btn" title="${storedStars > 0 ? 'Undo 1 awarded star' : 'Undo 1 star usage'}" onclick="undoStarAwardFromRecordRow(${student.id}, '${date}', event)">↺</button>`
                    : '';
                const storedVetoBadge = storedVetos ? `<span class="stored-veto-badge" title="Stored: ${storedVetos} VETO(s)">${storedVetos}</span>` : '';
                const rowClass = `${student.active === false ? 'inactive-row' : ''} ${hasExisting ? 'score-recorded-row' : ''}`.trim();
                return `
                <tr class="${rowClass}" data-student-id="${student.id}">
                    <td>${formatRollDisplay(student.roll)}</td>
                    <td>${renderStudentName(getMonthAwareStudent(student, month, profileMap), month)}</td>
                    <td>${student.class}</td>
                    <td data-col="record-group">${getStudentGroup(student) || '-'}</td>
                    <td data-col="record-vote-power">${computeVotePower(getStudentMonthTotal(student.id, month))}</td>
                    <td data-col="record-stars">${monthStarAwardByStudent[student.id] || 0}</td>
                    <td data-col="record-vetos">${monthVetoAwardByStudent[student.id] || 0}</td>
                    <td data-col="record-status">${student.active === false ? 'Inactive' : 'Active'}</td>
                    <td>
                        <div class="score-input-wrapper">${storedBadge}${attendancePenaltyBadge}${sourceBadge}
                        <input type="number" class="score-input" placeholder="${hasExisting ? '+/- to adjust' : 'e.g. 50 or -50'}"
                            value="${pointsValue}"
                            oninput="updateRecordScoreDraft(${student.id}, this, 0)"
                            onkeydown="recordScoreKey(event, ${student.id})">
                        </div>
                    </td>
                    <td>
                        <div class="score-input-wrapper">${storedStarBadge}${starUndoBtn}
                        <input type="text" class="score-input" placeholder="${hasExisting ? '+/- stars' : '* / -** or 2'}"
                            value="${starsValue}"
                            oninput="updateRecordScoreDraft(${student.id}, this, 1)"
                            onkeydown="recordScoreKey(event, ${student.id})">
                        </div>
                    </td>
                    <td>
                        <input type="text" class="score-input" placeholder="Reason for +stars"
                            value="${starReasonValue}"
                            oninput="updateRecordScoreDraft(${student.id}, this, 2)"
                            onkeydown="recordScoreKey(event, ${student.id})">
                    </td>
                    <td>
                        <div class="score-input-wrapper">${storedVetoBadge}
                        <input type="text" class="score-input" placeholder="${hasExisting && storedVetos ? '+/- VETOs' : 'V / -VV or 2'}"
                            value="${vetosValue}"
                            oninput="updateRecordScoreDraft(${student.id}, this, 3)"
                            onkeydown="recordScoreKey(event, ${student.id})">
                        </div>
                    </td>
                    <td>
                        <input type="text" class="score-input veto-reason-input" placeholder="Reason for -VETO"
                            value="${vetoReasonValue}"
                            oninput="updateRecordScoreDraft(${student.id}, this, 4)"
                            onkeydown="recordScoreKey(event, ${student.id})">
                    </td>
                    <td>
                        <button class="score-save-btn" onclick="saveRecordScoreRow(${student.id}, this)"><i class="fas fa-check"></i></button>
                    </td>
                </tr>
            `;
            }).join('');

            if (filtered.length === 0) {
                tbody.innerHTML = `<tr><td colspan="14" class="text-center" style="padding: 30px;">No students match the filters</td></tr>`;
            }
            refreshStarTransferModule(true);
            applyRecordColumnsVisibility();
            autoAdjustTableFonts();
        }

        function compareRecordStudentsByRollSuffix(a, b) {
            const extractSuffix = (student) => {
                const roll = normalizeRoll((student && student.roll) || '');
                if (!roll) return '';
                return roll.slice(-3).toUpperCase();
            };
            const suffixA = extractSuffix(a);
            const suffixB = extractSuffix(b);
            if (suffixA !== suffixB) {
                return suffixA.localeCompare(suffixB, undefined, { numeric: true, sensitivity: 'base' });
            }
            return compareStudentsByGroup(a, b);
        }

        function setSelectValueIfExists(selectId, value, fallback = '') {
            const select = document.getElementById(selectId);
            if (!select) return;
            const nextValue = value == null ? '' : String(value);
            const exists = Array.from(select.options || []).some(option => String(option.value) === nextValue);
            if (exists) {
                select.value = nextValue;
                return;
            }
            const fallbackValue = fallback == null ? '' : String(fallback);
            const fallbackExists = Array.from(select.options || []).some(option => String(option.value) === fallbackValue);
            if (fallbackExists) {
                select.value = fallbackValue;
            }
        }

        function resetRecordScoreDraft(date = '', month = '') {
            recordScoreDraftState.date = String(date || '');
            recordScoreDraftState.month = String(month || '');
            recordScoreDraftState.rows = {};
            recordScoreDraftState.lastEditAt = 0;
        }

        function ensureRecordScoreDraftContext(date, month) {
            const normalizedDate = String(date || '');
            const normalizedMonth = String(month || '');
            if (recordScoreDraftState.date !== normalizedDate || recordScoreDraftState.month !== normalizedMonth) {
                resetRecordScoreDraft(normalizedDate, normalizedMonth);
            }
        }

        function setRecordScoreDraft(studentId, payload) {
            const key = String(studentId || '');
            if (!key) return;
            const existing = recordScoreDraftState.rows[key] || {};
            recordScoreDraftState.rows[key] = {
                points: Object.prototype.hasOwnProperty.call(payload, 'points') ? String(coalesce(payload.points, '')) : existing.points,
                stars: Object.prototype.hasOwnProperty.call(payload, 'stars') ? String(coalesce(payload.stars, '')) : existing.stars,
                vetos: Object.prototype.hasOwnProperty.call(payload, 'vetos') ? String(coalesce(payload.vetos, '')) : existing.vetos,
                starReason: Object.prototype.hasOwnProperty.call(payload, 'starReason') ? String(coalesce(payload.starReason, '')) : existing.starReason,
                vetoReason: Object.prototype.hasOwnProperty.call(payload, 'vetoReason') ? String(coalesce(payload.vetoReason, '')) : existing.vetoReason
            };
        }

        function getRecordScoreDraft(studentId) {
            return recordScoreDraftState.rows[String(studentId || '')] || null;
        }

        function clearRecordScoreDraft(studentId) {
            delete recordScoreDraftState.rows[String(studentId || '')];
        }

        function updateRecordScoreDraft(studentId, inputEl, index) {
            if (!inputEl) return;
            recordScoreDraftState.lastEditAt = Date.now();
            if (index === 0) setRecordScoreDraft(studentId, { points: inputEl.value });
            else if (index === 1) setRecordScoreDraft(studentId, { stars: inputEl.value });
            else if (index === 2) setRecordScoreDraft(studentId, { starReason: inputEl.value });
            else if (index === 3) setRecordScoreDraft(studentId, { vetos: inputEl.value });
            else if (index === 4) setRecordScoreDraft(studentId, { vetoReason: inputEl.value });
        }

        function hasActiveRecordScoreEdit() {
            const active = document.activeElement;
            const insideTable = !!(active && typeof active.closest === 'function' && active.closest('#recordStudentsTable'));
            const recentEdit = (Date.now() - (recordScoreDraftState.lastEditAt || 0)) < LIVE_EDIT_GUARD_MS;
            return insideTable || recentEdit;
        }

        function refreshRecordScoreTabFromSync() {
            if (hasActiveRecordScoreEdit()) return;
            const previous = {
                date: getElementValue('scoreDate'),
                month: getElementValue('scoreMonth'),
                status: getElementValue('scoreStatusFilter') || 'active',
                group: getElementValue('scoreGroupFilter') || 'all',
                groupList: getElementValue('scoreGroupFilterList') || 'all',
                classValue: getElementValue('scoreClassFilter') || '',
                classList: getElementValue('scoreClassFilterList') || '',
                studentId: getElementValue('scoreStudent') || ''
            };
            ensureRecordScoreDraftContext(previous.date, previous.month);
            document.querySelectorAll('#recordStudentsBody tr[data-student-id]').forEach(row => {
                const studentId = parseInt(row.getAttribute('data-student-id'), 10);
                if (!studentId) return;
                const inputs = row.querySelectorAll('input.score-input');
                if (!inputs || inputs.length < 5) return;
                setRecordScoreDraft(studentId, {
                    points: inputs[0].value,
                    stars: inputs[1].value,
                    starReason: inputs[2].value,
                    vetos: inputs[3].value,
                    vetoReason: inputs[4].value
                });
            });

            if (!previous.date) {
                const today = formatDateKey(new Date());
                setElementValue('scoreDate', today);
                previous.date = today;
            }
            if (!previous.month) {
                const month = previous.date ? previous.date.substring(0, 7) : getCurrentMonthKey();
                setElementValue('scoreMonth', month);
                previous.month = month;
            }

            setElementValue('scoreStatusFilter', previous.status);
            populateScoreGroupFilter();
            setSelectValueIfExists('scoreGroupFilter', previous.group, 'all');
            setSelectValueIfExists('scoreGroupFilterList', previous.groupList || previous.group, 'all');
            setSelectValueIfExists('scoreClassFilter', previous.classValue, '');
            setSelectValueIfExists('scoreClassFilterList', previous.classList || previous.classValue, '');

            updateScoreStudentOptions(true);
            setSelectValueIfExists('scoreStudent', previous.studentId, '');
            loadExistingScore();
        }

        function refreshAttendanceTabFromSync() {
            if (hasActiveAttendanceEdit()) return;
            const date = getElementValue('attendanceDate') || formatDateKey(new Date());
            const month = getElementValue('attendanceMonth') || date.substring(0, 7);
            ensureAttendanceDraftContext(date, month);
            document.querySelectorAll('[data-attendance-student]').forEach(select => {
                const studentId = parseInt(select.getAttribute('data-attendance-student'), 10);
                if (!studentId) return;
                const remarksInput = document.querySelector(`[data-attendance-remarks="${studentId}"]`);
                setAttendanceDraft(studentId, select.value, remarksInput ? String(remarksInput.value || '') : undefined);
            });
            loadAttendanceTab();
        }

        function getPendingScoreAdjustmentAppeal(studentId, date, createdBy = '') {
            const appeals = db.getAppeals();
            return appeals.find(appeal =>
                appeal.type === 'score_adjustment' &&
                appeal.student_id === studentId &&
                appeal.score_date === date &&
                ['pending_admin', 'recommended'].includes(appeal.status) &&
                (!createdBy || appeal.created_by === createdBy)
            ) || null;
        }

        function queueTeacherScoreAdjustment(studentId, date, month, requestedStars, requestedVetos, points, notes = '') {
            if (currentUserRole !== 'teacher') return null;
            const student = db.getStudents().find(s => s.id === studentId);
            if (!student) return null;
            const existingScore = db.getScore(studentId, date);
            const approvedStars = parseInt(safeProp(existingScore, 'stars'), 10) || 0;
            const approvedVetos = parseInt(safeProp(existingScore, 'vetos'), 10) || 0;
            if (requestedStars === approvedStars && requestedVetos === approvedVetos) {
                return null;
            }

            const now = new Date().toISOString();
            const createdBy = currentLoginId || 'Teacher';
            const message = `Teacher requested star/veto update for ${student.base_name || student.name} (${formatRollDisplay(student.roll)}) on ${date}. Requested: *${requestedStars}, V${requestedVetos}. Approved now: *${approvedStars}, V${approvedVetos}.`;
            const payload = {
                type: 'score_adjustment',
                subject: 'Teacher Star/VETO Approval Request',
                message,
                from_role: 'teacher',
                created_by: createdBy,
                target_role: 'admin',
                forwarded_to: 'admin',
                status: 'pending_admin',
                recommendation: 'Teacher Entered',
                student_id: studentId,
                student_roll: formatRollDisplay(student.roll),
                student_name: student.base_name || student.name || '',
                score_date: date,
                score_month: month,
                requested_points: parseInt(points, 10) || 0,
                requested_stars: requestedStars,
                requested_vetos: requestedVetos,
                approved_stars_before: approvedStars,
                approved_vetos_before: approvedVetos,
                score_notes: notes || ''
            };

            const existingAppeal = getPendingScoreAdjustmentAppeal(studentId, date, createdBy);
            if (existingAppeal) {
                db.updateAppeal(existingAppeal.id, payload);
                return { updated: true, appealId: existingAppeal.id };
            }
            const created = db.addAppeal({
                ...payload,
                created_at: now,
                updated_at: now
            });
            return { updated: false, appealId: safeProp(created, 'id') || 0 };
        }

        function smartStarCounter(studentId, date, month, points, stars) {
            // If student uses stars to counter negative marking
            if (points < 0 && stars > 0) {
                // VALIDATION: Check if student has enough stars
                const student = db.getStudents().find(s => s.id === studentId);
                const availableStars = parseInt(safeProp(student, 'stars'), 10) || 0;
                if (availableStars < stars) {
                    showAlert(`Student only has ${availableStars} star(s) available, cannot use ${stars} star(s).`, 'danger');
                    return null;
                }

                const absPoints = Math.abs(points);
                let modifiedPoints = 0;
                let nextDayBonus = 0;
                let cellColor = 'red';  // Default to red for large penalties

                // IF points >= -50 (small penalty like -49, -48 to -1): GREEN + BONUS
                if (points >= -50) {
                    cellColor = 'green';       // Replace with green cell
                    modifiedPoints = 0;        // Remove negative mark
                    nextDayBonus = 100;        // Add +100 to next day
                } else {
                    // IF points < -50 (large penalty like -51, -52, etc): RED + NO BONUS
                    cellColor = 'red';         // Replace with red cell
                    modifiedPoints = 0;        // Remove negative mark
                    nextDayBonus = 0;          // No bonus applied
                }

                // Update current day score with visual indicator
                const resolved = {
                    score: {
                        studentId,
                        date,
                        points: modifiedPoints,
                        stars: stars,
                        vetos: 0,
                        month,
                        notes: `[${cellColor.toUpperCase()}] Star used to counter negative marking (original: ${points})`,
                        recordedBy: currentUserRole
                    },
                    cellColor: cellColor
                };

                // Deduct stars from student record
                if (student && availableStars >= stars) {
                    student.stars = availableStars - stars;
                    // Don't save yet - will be saved with addScore
                }

                // If bonus applies, create/update next day entry
                if (nextDayBonus > 0) {
                    const nextDate = new Date(date);
                    nextDate.setDate(nextDate.getDate() + 1);
                    const nextDateStr = formatDateKey(nextDate);
                    const nextMonth = nextDateStr.substring(0, 7);

                    // Check if next day already has a score
                    const nextDayScore = db.getScore(studentId, nextDateStr);
                    if (nextDayScore) {
                        // Add bonus to existing score
                        const newPoints = (parseInt(nextDayScore.points, 10) || 0) + nextDayBonus;
                        db.addScore({
                            studentId,
                            date: nextDateStr,
                            points: newPoints,
                            stars: parseInt(safeProp(nextDayScore, 'stars'), 10) || 0,
                            vetos: parseInt(safeProp(nextDayScore, 'vetos'), 10) || 0,
                            month: nextMonth,
                            notes: `${safeProp(nextDayScore, 'notes') || ''} [Star bonus +100]`.trim(),
                            recordedBy: currentUserRole
                        });
                    } else {
                        // Create new next day entry with bonus (VISIBLE IN SCOREBOARD)
                        db.addScore({
                            studentId,
                            date: nextDateStr,
                            points: nextDayBonus,
                            stars: 0,
                            vetos: 0,
                            month: nextMonth,
                            notes: `[BONUS] Star bonus +100 from ${date}`,
                            recordedBy: currentUserRole
                        });
                    }
                }

                return resolved;
            }

            // If not using star to counter negative marking, return normal result
            return null;
        }

        function resolveScoreForRole(studentId, date, month, points, stars, vetos, notes = '') {
            const existing = db.getScore(studentId, date);
            if (currentUserRole !== 'teacher') {
                return {
                    score: {
                        studentId,
                        date,
                        points,
                        stars,
                        vetos,
                        month,
                        notes,
                        recordedBy: currentUserRole
                    },
                    queuedApproval: null
                };
            }

            const approvedStars = parseInt(safeProp(existing, 'stars'), 10) || 0;
            const approvedVetos = parseInt(safeProp(existing, 'vetos'), 10) || 0;
            const queuedApproval = queueTeacherScoreAdjustment(studentId, date, month, stars, vetos, points, notes);
            return {
                score: {
                    studentId,
                    date,
                    points,
                    stars: approvedStars,
                    vetos: approvedVetos,
                    month,
                    notes,
                    recordedBy: currentUserRole
                },
                queuedApproval
            };
        }

        let recordScoreRefreshTimer = null;
        function scheduleScoreboardRefresh() {
            if (recordScoreRefreshTimer) clearTimeout(recordScoreRefreshTimer);
            recordScoreRefreshTimer = setTimeout(() => {
                loadScoreboard();
                recordScoreRefreshTimer = null;
            }, 220);
        }

        function saveRecordScoreRow(studentId, triggerEl = null, options = {}) {
            const row = triggerEl ? triggerEl.closest('tr') : null;
            if (!row) return;
            const currentInputs = row.querySelectorAll('input.score-input');
            if (!currentInputs.length) return;
            const focusIndex = Number.isFinite(parseInt(options.focusIndex, 10))
                ? Math.max(0, Math.min(parseInt(options.focusIndex, 10), currentInputs.length - 1))
                : 0;
            const pointsRaw = coalesce(safeProp(currentInputs[0], 'value'), '');
            const starsRaw = coalesce(safeProp(currentInputs[1], 'value'), '');
            const starReasonRaw = coalesce(safeProp(currentInputs[2], 'value'), '');
            const vetosRaw = coalesce(safeProp(currentInputs[3], 'value'), '');
            const vetoReasonRaw = coalesce(safeProp(currentInputs[4], 'value'), '');
            let points = pointsRaw === '' ? NaN : parseInt(pointsRaw, 10);
            const stars = parseTokenAdjustment(starsRaw, '*');
            const vetos = parseTokenAdjustment(vetosRaw, 'V');
            const starReason = String(starReasonRaw || '').trim();
            const vetoReason = String(vetoReasonRaw || '').trim();
            const date = getElementValue('scoreDate');
            let month = getElementValue('scoreMonth') || (date ? date.substring(0, 7) : getCurrentMonthKey());
            if (currentUserRole === 'teacher' && date) {
                month = String(date).substring(0, 7);
                const monthEl = document.getElementById('scoreMonth');
                if (monthEl) monthEl.value = month;
            }
            if (!date) {
                showAlert('Select date first.', 'warning');
                return;
            }
            if (!teacherValidateCurrentMonth(date, month, 'Score entry')) {
                return;
            }

            const pointsEmpty = String(pointsRaw).trim() === '';
            const starsEmpty = String(starsRaw).trim() === '';
            const vetosEmpty = String(vetosRaw).trim() === '';
            if (pointsEmpty && starsEmpty && vetosEmpty) {
                showAlert('Enter points, stars, or VETOs before saving.', 'warning');
                return;
            }
            if (Number.isNaN(points)) {
                if (pointsEmpty) {
                    points = 0;
                } else {
                    showAlert('Enter valid points (e.g., 50 or -50).', 'danger');
                    return;
                }
            }
            if (Number.isNaN(stars) || Number.isNaN(vetos)) {
                showAlert('Enter valid values. Stars: number or * pattern. VETOs: number or V pattern.', 'danger');
                return;
            }
            if (stars > 0 && !starReason) {
                showAlert('Enter Star Reason when adding positive stars.', 'warning');
                currentInputs[2].focus();
                return;
            }
            if (vetos < 0 && !vetoReason) {
                showAlert('Enter VETO reason when using negative VETO.', 'warning');
                currentInputs[4].focus();
                return;
            }

            if (stars !== 0) {
                const starValidation = validateStarAvailability(studentId, stars);
                if (!starValidation.valid) {
                    showValidationModal('Insufficient Stars', starValidation.message);
                    return;
                }
            }

            if (vetos !== 0) {
                const vetoValidation = validateVetoAvailability(studentId, vetos);
                if (!vetoValidation.valid) {
                    showValidationModal('Insufficient VETOs', vetoValidation.message);
                    return;
                }
            }

            // ACCUMULATION MODE: inputs contain DELTA values.
            // Each save adds the delta to the stored total.
            const existingScore = db.getScore(studentId, date);
            const existingPoints = existingScore ? (parseInt(safeProp(existingScore, 'points'), 10) || 0) : 0;
            const existingStars = existingScore ? (parseInt(safeProp(existingScore, 'stars'), 10) || 0) : 0;
            const existingVetos = existingScore ? (parseInt(safeProp(existingScore, 'vetos'), 10) || 0) : 0;
            const attendanceRecord = getAttendanceRecord(studentId, date);
            const attendancePenalty = getAttendancePenaltyPointsForStatus(safeProp(attendanceRecord, 'status'));

            // Accumulate: stored + delta
            const finalPoints = existingPoints + points;
            let finalStars = existingStars + (starsEmpty ? 0 : stars);
            let finalVetos = existingVetos + (vetosEmpty ? 0 : vetos);

            if (attendancePenalty < 0 && existingPoints === 0 && points === Math.abs(attendancePenalty)) {
                const proceedPenaltyComp = confirm(
                    `Note: This date has an attendance penalty ${attendancePenalty} (auto-applied in scoreboard).\n` +
                    `You are entering +${points}, which exactly cancels that penalty in total view.\n\nContinue?`
                );
                if (!proceedPenaltyComp) return;
            }
            if (existingScore && existingPoints !== 0 && finalPoints === 0) {
                const prevBy = String(safeProp(existingScore, 'recordedBy') || '').trim();
                const proceedZero = confirm(
                    `You are about to zero-out an existing saved score (${existingPoints})${prevBy ? ` recorded by ${prevBy}` : ''}.\n` +
                    `If this is not intentional, cancel and enter the actual delta directly.\n\nContinue?`
                );
                if (!proceedZero) return;
            }

            if (points < 0 && finalPoints < existingPoints) {
                const recordedBy = String(safeProp(existingScore, 'recordedBy') || '').trim();
                const student = db.getStudents().find(s => s.id === studentId);
                const studentLabel = student ? `${student.base_name || student.name || 'Student'} (${formatRollDisplay(student.roll)})` : `ID ${studentId}`;
                const ok = confirm(
                    `This will REDUCE previously recorded score for ${studentLabel} on ${date}${recordedBy ? ` (recorded by: ${recordedBy})` : ''}.\n` +
                    `Current: ${existingPoints}, Change: ${points}, New: ${finalPoints}.\n\nContinue?`
                );
                if (!ok) return;
            }

            const existingNotes = String(coalesce(safeProp(existingScore, 'notes'), '')).trim();
            let notesToSave = existingNotes;
            const noteParts = [];
            if (notesToSave) noteParts.push(notesToSave);
            if (points < 0 && finalPoints < existingPoints) {
                noteParts.push(`Score adjusted by ${currentLoginId || currentUserRole}: ${existingPoints} -> ${finalPoints} (delta ${points})`);
            }
            if (stars > 0 && starReason) noteParts.push(`Star reason: ${starReason}`);
            if (vetoReason) noteParts.push(`VETO reason: ${vetoReason}`);
            else if (vetos < 0 && !existingNotes) noteParts.push('VETO used');
            notesToSave = noteParts.join(' | ').trim();

            const resolved = resolveScoreForRole(studentId, date, month, finalPoints, finalStars, finalVetos, notesToSave);
            db.addScore(resolved.score);
            reconcileVetoCountersFromScores(month, { persist: false });

            db.saveData(db.getData(), { allowTeacher: true });
            if (SERVER_SYNC.enabled && (currentUserRole === 'admin' || currentUserRole === 'teacher')) {
                pushToServer(db.getData(), { silent: true });
            }

            if (resolved.queuedApproval) {
                showAlert('Points saved. Star/VETO change sent to Admin for approval.', 'warning');
            } else {
                const deltaDesc = points >= 0 ? `+${points}` : String(points);
                showAlert(`Score saved! ${deltaDesc} → Total: ${resolved.score.points}`, 'success');
            }
            // Clear inputs after save (inputs are for delta entry only)
            currentInputs[0].value = '';
            currentInputs[1].value = '';
            currentInputs[2].value = '';
            currentInputs[3].value = '';
            currentInputs[4].value = '';
            // Update stored-score badges in the row
            const pointsWrapper = currentInputs[0].closest('.score-input-wrapper');
            if (pointsWrapper) {
                let badge = pointsWrapper.querySelector('.stored-score-badge');
                if (!badge) { badge = document.createElement('span'); badge.className = 'stored-score-badge'; badge.title = 'Stored score for this date'; pointsWrapper.insertBefore(badge, currentInputs[0]); }
                badge.textContent = resolved.score.points;
            }
            const starsWrapper = currentInputs[1].closest('.score-input-wrapper');
            if (starsWrapper) {
                let badge = starsWrapper.querySelector('.stored-star-badge');
                if (resolved.score.stars) {
                    if (!badge) { badge = document.createElement('span'); badge.className = 'stored-star-badge'; badge.title = 'Stars recorded for this date'; starsWrapper.insertBefore(badge, currentInputs[1]); }
                    badge.textContent = resolved.score.stars;
                } else if (badge) { badge.remove(); }
            }
            const vetosWrapper = currentInputs[2].closest('.score-input-wrapper');
            if (vetosWrapper) {
                let badge = vetosWrapper.querySelector('.stored-veto-badge');
                if (resolved.score.vetos) {
                    if (!badge) { badge = document.createElement('span'); badge.className = 'stored-veto-badge'; badge.title = 'VETOs recorded for this date'; vetosWrapper.insertBefore(badge, currentInputs[2]); }
                    badge.textContent = resolved.score.vetos;
                } else if (badge) { badge.remove(); }
            }
            // Update placeholders to show delta mode
            currentInputs[0].placeholder = '+/- to adjust';
            currentInputs[1].placeholder = '+/- stars';
            currentInputs[2].placeholder = 'Reason for +stars';
            currentInputs[3].placeholder = '+/- VETOs';
            clearRecordScoreDraft(studentId);
            row.classList.add('score-recorded-row');
            currentInputs.forEach(input => input.classList.add('filled'));
            const refreshedStudent = db.getStudents().find(s => s.id === studentId);
            if (refreshedStudent) {
                const voteCell = row.children[4];
                const starsCell = row.children[5];
                const vetosCell = row.children[6];
                if (voteCell) {
                    voteCell.textContent = String(computeVotePower(getStudentMonthTotal(studentId, month)));
                }
                if (starsCell) starsCell.textContent = String(getStudentMonthStarAwardTotal(studentId, month));
                if (vetosCell) vetosCell.textContent = String(getStudentMonthVetoAwardTotal(studentId, month));
            }
            scheduleScoreboardRefresh();
            if (getActiveTabName() === 'appeals') {
                loadAppealsTab();
            } else {
                updateAppealsTabNotification();
            }
            const focusInput = currentInputs[focusIndex] || currentInputs[0];
            if (focusInput) {
                focusInput.focus();
                focusInput.select();
            }
        }

        function recordScoreKey(event, studentId) {
            const input = event.target;
            const row = input.closest('tr');
            if (!row) return;
            const inputs = Array.from(row.querySelectorAll('input.score-input'));
            const colIndex = inputs.indexOf(input);

            if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
                event.preventDefault();
                const nextRow = event.key === 'ArrowDown' ? row.nextElementSibling : row.previousElementSibling;
                if (!nextRow) return;
                const nextInputs = nextRow.querySelectorAll('input.score-input');
                if (!nextInputs.length) return;
                const target = nextInputs[Math.max(0, Math.min(colIndex, nextInputs.length - 1))];
                if (target) {
                    target.focus();
                    target.select();
                }
                return;
            }

            if (event.key === 'Enter') {
                event.preventDefault();
                saveRecordScoreRow(studentId, row, { focusIndex: colIndex });
                return;
            }
        }

        function saveScore() {
            const studentId = parseInt(document.getElementById('scoreStudent').value);
            const date = document.getElementById('scoreDate').value;
            const pointsInput = document.getElementById('scorePoints').value;
            let points = pointsInput === '' ? NaN : parseInt(pointsInput);
            const starsInput = document.getElementById('scoreStars').value;
            const stars = parseTokenAdjustment(starsInput, '*');
            const vetosInput = document.getElementById('scoreVetos').value;
            const vetos = parseTokenAdjustment(vetosInput, 'V');
            let month = document.getElementById('scoreMonth').value;
            if (currentUserRole === 'teacher' && date) {
                month = String(date).substring(0, 7);
                const monthEl = document.getElementById('scoreMonth');
                if (monthEl) monthEl.value = month;
            }
            const notes = document.getElementById('scoreNotes').value;

            const pointsEmpty = String(pointsInput).trim() === '';
            const starsEmpty = String(starsInput).trim() === '';
            const vetosEmpty = String(vetosInput).trim() === '';
            if (!studentId || !date || !month) {
                showAlert('Select a student, date, and month first.', 'danger');
                return;
            }
            if (!teacherValidateCurrentMonth(date, month, 'Score entry')) {
                return;
            }
            if (pointsEmpty && starsEmpty && vetosEmpty) {
                showAlert('Enter points, stars, or VETOs before saving.', 'warning');
                return;
            }
            if (Number.isNaN(points)) {
                if (pointsEmpty) {
                    points = 0;
                } else {
                    showAlert('Please fill valid points (e.g., 50 or -50).', 'danger');
                    return;
                }
            }
            if (Number.isNaN(stars) || Number.isNaN(vetos)) {
                showAlert('Please fill valid values (Stars: number/*, VETOs: number/V)', 'danger');
                return;
            }
            if (vetos < 0 && !String(notes || '').trim()) {
                showAlert('Enter reason in Notes when using negative VETO.', 'warning');
                const notesEl = document.getElementById('scoreNotes');
                if (notesEl) notesEl.focus();
                return;
            }

            // Validate availability only when removing/using existing stars.
            if (stars !== 0) {
                const starValidation = validateStarAvailability(studentId, stars);
                if (!starValidation.valid) {
                    showValidationModal('Insufficient Stars', starValidation.message);
                    return;
                }
            }

            // Validate availability only when removing/using existing VETOs.
            if (vetos !== 0) {
                const vetoValidation = validateVetoAvailability(studentId, vetos);
                if (!vetoValidation.valid) {
                    showValidationModal('Insufficient VETOs', vetoValidation.message);
                    return;
                }
            }

            // ACCUMULATION MODE: form inputs contain DELTA values.
            // Each save adds the delta to the stored total.
            const existingScore = db.getScore(studentId, date);
            const existingPoints = existingScore ? (parseInt(safeProp(existingScore, 'points'), 10) || 0) : 0;
            const existingStars = existingScore ? (parseInt(safeProp(existingScore, 'stars'), 10) || 0) : 0;
            const existingVetos = existingScore ? (parseInt(safeProp(existingScore, 'vetos'), 10) || 0) : 0;
            const attendanceRecord = getAttendanceRecord(studentId, date);
            const attendancePenalty = getAttendancePenaltyPointsForStatus(safeProp(attendanceRecord, 'status'));

            const finalPoints = existingPoints + points;
            const finalStars = existingStars + (starsEmpty ? 0 : stars);
            const finalVetos = existingVetos + (vetosEmpty ? 0 : vetos);

            if (attendancePenalty < 0 && existingPoints === 0 && points === Math.abs(attendancePenalty)) {
                const proceedPenaltyComp = confirm(
                    `Note: This date has an attendance penalty ${attendancePenalty} (auto-applied in scoreboard).\n` +
                    `You are entering +${points}, which exactly cancels that penalty in total view.\n\nContinue?`
                );
                if (!proceedPenaltyComp) return;
            }
            if (existingScore && existingPoints !== 0 && finalPoints === 0) {
                const prevBy = String(safeProp(existingScore, 'recordedBy') || '').trim();
                const proceedZero = confirm(
                    `You are about to zero-out an existing saved score (${existingPoints})${prevBy ? ` recorded by ${prevBy}` : ''}.\n` +
                    `If this is not intentional, cancel and enter the actual delta directly.\n\nContinue?`
                );
                if (!proceedZero) return;
            }

            if (points < 0 && finalPoints < existingPoints) {
                const recordedBy = String(safeProp(existingScore, 'recordedBy') || '').trim();
                const student = db.getStudents().find(s => s.id === studentId);
                const studentLabel = student ? `${student.base_name || student.name || 'Student'} (${formatRollDisplay(student.roll)})` : `ID ${studentId}`;
                const ok = confirm(
                    `This will REDUCE previously recorded score for ${studentLabel} on ${date}${recordedBy ? ` (recorded by: ${recordedBy})` : ''}.\n` +
                    `Current: ${existingPoints}, Change: ${points}, New: ${finalPoints}.\n\nContinue?`
                );
                if (!ok) return;
            }

            let notesToSave = String(notes || '').trim();
            if (points < 0 && finalPoints < existingPoints) {
                const reductionNote = `Score adjusted by ${currentLoginId || currentUserRole}: ${existingPoints} -> ${finalPoints} (delta ${points})`;
                notesToSave = notesToSave ? `${notesToSave} | ${reductionNote}` : reductionNote;
            }

            const resolved = resolveScoreForRole(studentId, date, month, finalPoints, finalStars, finalVetos, notesToSave);
            const result = db.addScore(resolved.score);
            reconcileVetoCountersFromScores(month, { persist: false });
            clearRecordScoreDraft(studentId);

            db.saveData(db.getData(), { allowTeacher: true });
            
            if (SERVER_SYNC.enabled && (currentUserRole === 'admin' || currentUserRole === 'teacher')) {
                pushToServer(db.getData(), { silent: true });
            }

            clearScoreForm();
            if (resolved.queuedApproval) {
                showAlert('Points saved. Star/VETO request sent to Admin for approval.', 'warning');
            } else {
                showAlert(result.updated ? 'Score updated successfully!' : 'Score saved successfully!', 'success');
            }
            loadScoreboard();
            loadRecordStudentTable();
            if (getActiveTabName() === 'appeals') {
                loadAppealsTab();
            } else {
                updateAppealsTabNotification();
            }
        }

        function loadExistingScore() {
            const studentId = parseInt(document.getElementById('scoreStudent').value);
            const date = document.getElementById('scoreDate').value;
            if (!studentId || !date) return;

            // In accumulation mode, inputs are always EMPTY (for delta entry).
            // Existing stored values are shown as info only.
            document.getElementById('scorePoints').value = '';
            document.getElementById('scoreStars').value = '';
            document.getElementById('scoreVetos').value = '';
            document.getElementById('scoreNotes').value = '';

            const existing = db.getScore(studentId, date);
            if (existing) {
                document.getElementById('scoreMonth').value = existing.month || date.substring(0, 7);
                const storedPts = existing.points || 0;
                const storedStars = existing.stars || 0;
                document.getElementById('scoreHint').textContent = `Stored: Points=${storedPts}, Stars=${storedStars}. Enter +/- delta to adjust.`;
                document.getElementById('scorePoints').placeholder = `+/- to adjust (current: ${storedPts})`;
                document.getElementById('scoreStars').placeholder = `+/- stars (current: ${storedStars})`;
            } else {
                document.getElementById('scoreMonth').value = date.substring(0, 7);
                document.getElementById('scoreHint').textContent = 'Enter score values. Subsequent entries for same date will accumulate.';
                document.getElementById('scorePoints').placeholder = 'e.g. 50 or -50';
                document.getElementById('scoreStars').placeholder = '* / -** or 2';
            }
        }

        function deleteScore() {
            const studentId = parseInt(document.getElementById('scoreStudent').value);
            const date = document.getElementById('scoreDate').value;
            if (!studentId || !date) {
                showAlert('Select a student and date first', 'danger');
                return;
            }
            const existing = db.getScore(studentId, date);
            if (!existing) {
                showAlert('No score found for this student and date', 'danger');
                return;
            }
            if (confirm('Delete this score entry?')) {
                pushUndoSnapshot('Delete score');
                db.deleteScore(studentId, date);
                clearScoreForm();
                showAlert('Score deleted. Press Ctrl+Z to undo.', 'success');
                loadScoreboard();
                loadRecordStudentTable();
            }
        }

        // ── Record Score quick star undo (admin/teacher) ───────────────────────

        function undoStarAwardFromRecordRow(studentId, date, event) {
            if (event) {
                event.preventDefault();
                event.stopPropagation();
            }
            if (currentUserRole !== 'admin' && currentUserRole !== 'teacher') return;
            const existing = db.getScore(parseInt(studentId, 10), date);
            if (!existing) {
                showAlert('Score entry not found.', 'danger');
                return;
            }
            const currentStars = parseInt(existing.stars, 10) || 0;
            if (currentStars > 0) {
                undoStarOnDate(studentId, date);
                loadRecordStudentTable();
                return;
            }
            if (currentStars < 0) {
                undoStarUsageOnDate(studentId, date);
                loadRecordStudentTable();
                return;
            }
            showAlert('No star delta found for this date.', 'warning');
        }

        function undoStarOnDate(studentId, date) {
            if (currentUserRole !== 'admin' && currentUserRole !== 'teacher') return;
            const existing = db.getScore(parseInt(studentId, 10), date);
            if (!existing) { showAlert('Score entry not found.', 'danger'); return; }
            const currentStars = parseInt(existing.stars, 10) || 0;
            if (currentStars <= 0) { showAlert('No awarded stars to remove on this date.', 'warning'); return; }
            const st = db.getStudents().find(s => s.id === parseInt(studentId, 10));
            const name = st ? String(st.base_name || st.name || '').trim() : '(unknown)';
            pushUndoSnapshot(`Remove star — ${name} on ${date}`);
            db.addScore({ ...existing, stars: currentStars - 1, updated_at: new Date().toISOString() });
            if (SERVER_SYNC.enabled) pushToServer(db.getData(), { silent: true });
            showAlert(`Removed 1 star from ${escapeHtml(name)} on ${date}. Press Ctrl+Z to undo.`, 'success');
            loadScoreboard();
            if (getActiveTabName() === 'add-score') loadRecordStudentTable();
        }

        function undoStarUsageOnDate(studentId, date) {
            if (currentUserRole !== 'admin' && currentUserRole !== 'teacher') return;
            const existing = db.getScore(parseInt(studentId, 10), date);
            if (!existing) { showAlert('Score entry not found.', 'danger'); return; }
            const currentStars = parseInt(existing.stars, 10) || 0;
            if (currentStars >= 0) { showAlert('No negative star entry to restore on this date.', 'warning'); return; }
            const st = db.getStudents().find(s => s.id === parseInt(studentId, 10));
            const name = st ? String(st.base_name || st.name || '').trim() : '(unknown)';
            pushUndoSnapshot(`Restore star usage — ${name} on ${date}`);
            db.addScore({ ...existing, stars: currentStars + 1, updated_at: new Date().toISOString() });
            if (SERVER_SYNC.enabled) pushToServer(db.getData(), { silent: true });
            showAlert(`Restored 1 star for ${escapeHtml(name)} on ${date}. Press Ctrl+Z to undo.`, 'success');
            loadScoreboard();
            if (getActiveTabName() === 'add-score') loadRecordStudentTable();
        }

        function undoVetoOnDate(studentId, date) {
            if (currentUserRole !== 'admin' && currentUserRole !== 'teacher') return;
            const existing = db.getScore(parseInt(studentId, 10), date);
            if (!existing) { showAlert('Score entry not found.', 'danger'); return; }
            const currentVetos = parseInt(existing.vetos, 10) || 0;
            if (currentVetos <= 0) { showAlert('No awarded VETOs to remove on this date.', 'warning'); return; }
            const st = db.getStudents().find(s => s.id === parseInt(studentId, 10));
            const name = st ? String(st.base_name || st.name || '').trim() : '(unknown)';
            const month = String(existing.month || date).substring(0, 7);
            pushUndoSnapshot(`Remove VETO — ${name} on ${date}`);
            db.addScore({ ...existing, vetos: currentVetos - 1, updated_at: new Date().toISOString() });
            reconcileVetoCountersFromScores(month, { persist: true });
            if (SERVER_SYNC.enabled) pushToServer(db.getData(), { silent: true });
            showAlert(`Removed 1 VETO from ${escapeHtml(name)} on ${date}. Press Ctrl+Z to undo.`, 'success');
            loadScoreboard();
        }

        function undoVetoUsageOnDate(studentId, date) {
            if (currentUserRole !== 'admin' && currentUserRole !== 'teacher') return;
            const existing = db.getScore(parseInt(studentId, 10), date);
            if (!existing) { showAlert('Score entry not found.', 'danger'); return; }
            const currentVetos = parseInt(existing.vetos, 10) || 0;
            if (currentVetos >= 0) { showAlert('No negative VETO entry to restore on this date.', 'warning'); return; }
            const st = db.getStudents().find(s => s.id === parseInt(studentId, 10));
            const name = st ? String(st.base_name || st.name || '').trim() : '(unknown)';
            const month = String(existing.month || date).substring(0, 7);
            pushUndoSnapshot(`Restore VETO usage — ${name} on ${date}`);
            db.addScore({ ...existing, vetos: currentVetos + 1, updated_at: new Date().toISOString() });
            reconcileVetoCountersFromScores(month, { persist: true });
            if (SERVER_SYNC.enabled) pushToServer(db.getData(), { silent: true });
            showAlert(`Restored 1 VETO for ${escapeHtml(name)} on ${date}. Press Ctrl+Z to undo.`, 'success');
            loadScoreboard();
        }

        // ── Student position detection ──────────────────────────────────────────────
        function detectStudentPositions() {
            if (currentUserRole !== 'student' || !currentStudentRoll) return {};
            const data = db.getData();
            const students = db.getStudents();
            const me = students.find(s => String(s.roll || '').trim().toUpperCase() === String(currentStudentRoll).trim().toUpperCase());
            if (!me) return {};
            const myId = parseInt(me.id, 10);
            const pos = { studentId: myId, student: me };

            const leadEntry = (data.leadership || []).find(l =>
                parseInt(l.studentId, 10) === myId &&
                normalizePostHolderStatus(l.status || '') === 'active');
            if (leadEntry) pos.leadership_post = leadEntry.post;

            const gcr = (data.group_crs || []).find(c =>
                parseInt(c.studentId, 10) === myId &&
                normalizePostHolderStatus(c.status || '') === 'active');
            if (gcr) { pos.is_group_cr = true; pos.cr_group = gcr.group; pos.cr_class = gcr.class; }

            const cr = (data.class_reps || []).find(c =>
                parseInt(c.studentId, 10) === myId &&
                normalizePostHolderStatus(c.status || '') === 'active');
            if (cr) { pos.is_class_rep = true; pos.class_rep_class = cr.class; }

            (data.parties || []).forEach(party => {
                const mem = (party.members || []).find(m =>
                    parseInt(m.studentId, 10) === myId &&
                    normalizePostHolderStatus(m.status || '') === 'active');
                if (mem) {
                    pos.party_code = party.code;
                    pos.party_name = party.full_name;
                    pos.party_role = mem.designation;
                    if (mem.designation === 'president') pos.is_party_leader = true;
                }
            });
            return pos;
        }

        // ── Student dashboard loader ────────────────────────────────────────────────
        function loadMyDashboard() {
            if (currentUserRole !== 'student') return;
            currentStudentPositions = detectStudentPositions();
            const pos = currentStudentPositions;
            const me = pos.student;

            // ── Personal stats ──────────────────────────────────────────────────────
            const month = getCurrentMonthKey();
            const sb = db.getMonthlyScoreboard(month);
            const myRow = sb.find(r => r.student && String(r.student.roll || '').toUpperCase() === String(currentStudentRoll).toUpperCase());
            const myRank = myRow ? (sb.indexOf(myRow) + 1) : '—';
            const myTotal = myRow ? myRow.total : '—';
            const myStars = me ? (parseInt(me.stars, 10) || 0) : 0;
            const myVetos = me ? (parseInt(me.veto_count, 10) || 0) : 0;

            const statsEl = document.getElementById('myStatsContent');
            if (statsEl) {
                statsEl.innerHTML = `
                    <div style="display:flex;flex-wrap:wrap;gap:14px;margin-top:10px">
                        <div class="stat-pill" style="background:rgba(56,189,248,0.12);border:1px solid rgba(56,189,248,0.25);border-radius:10px;padding:14px 22px;text-align:center;min-width:110px">
                            <div style="font-size:28px;font-weight:800;color:#38bdf8">#${myRank}</div>
                            <div style="font-size:11px;color:var(--text-muted)">Rank this month</div>
                        </div>
                        <div class="stat-pill" style="background:rgba(34,197,94,0.12);border:1px solid rgba(34,197,94,0.25);border-radius:10px;padding:14px 22px;text-align:center;min-width:110px">
                            <div style="font-size:28px;font-weight:800;color:#22c55e">${myTotal}</div>
                            <div style="font-size:11px;color:var(--text-muted)">Points (${month})</div>
                        </div>
                        <div class="stat-pill" style="background:rgba(251,191,36,0.12);border:1px solid rgba(251,191,36,0.25);border-radius:10px;padding:14px 22px;text-align:center;min-width:110px">
                            <div style="font-size:28px;font-weight:800;color:#fcd34d">${myStars >= 0 ? '+' : ''}${myStars} ★</div>
                            <div style="font-size:11px;color:var(--text-muted)">Stars balance</div>
                        </div>
                        <div class="stat-pill" style="background:rgba(239,68,68,0.12);border:1px solid rgba(239,68,68,0.25);border-radius:10px;padding:14px 22px;text-align:center;min-width:110px">
                            <div style="font-size:28px;font-weight:800;color:#f87171">${myVetos} V</div>
                            <div style="font-size:11px;color:var(--text-muted)">VETOs remaining</div>
                        </div>
                    </div>`;
            }

            // ── Position badges ─────────────────────────────────────────────────────
            const posCard = document.getElementById('myPositionCard');
            const posContent = document.getElementById('myPositionContent');
            const badges = [];
            if (pos.leadership_post) badges.push(`<span class="meta-badge" style="background:rgba(251,191,36,0.2);border:1px solid rgba(251,191,36,0.4);color:#fcd34d;padding:5px 12px;border-radius:20px;font-size:13px;font-weight:600"><i class="fas fa-crown"></i> ${escapeHtml(pos.leadership_post)}</span>`);
            if (pos.is_group_cr || pos.is_class_rep) badges.push(`<span class="meta-badge" style="background:rgba(236,72,153,0.15);border:1px solid rgba(236,72,153,0.35);color:#f9a8d4;padding:5px 12px;border-radius:20px;font-size:13px;font-weight:600"><i class="fas fa-user-check"></i> Class Rep${pos.cr_class ? ' — Class ' + pos.cr_class : ''}${pos.cr_group ? ' / Group ' + pos.cr_group : ''}</span>`);
            if (pos.party_code) badges.push(`<span class="meta-badge" style="background:rgba(249,115,22,0.15);border:1px solid rgba(249,115,22,0.35);color:#fdba74;padding:5px 12px;border-radius:20px;font-size:13px;font-weight:600"><i class="fas fa-flag"></i> ${escapeHtml(pos.party_name || pos.party_code)} ${pos.is_party_leader ? '(Leader)' : pos.party_role === 'deputy_president' ? '(Deputy)' : '(Member)'}</span>`);

            if (posCard && badges.length > 0) {
                posCard.style.display = '';
                if (posContent) posContent.innerHTML = `<div style="display:flex;flex-wrap:wrap;gap:10px;margin-top:8px">${badges.join('')}</div>`;
            } else if (posCard) {
                posCard.style.display = 'none';
            }

            // ── VETO request section ────────────────────────────────────────────────
            const vetoCard = document.getElementById('myVetoCard');
            if (vetoCard) vetoCard.style.display = (myVetos > 0) ? '' : 'none';
            if (myVetos > 0) {
                const vetoContent = document.getElementById('myVetoContent');
                if (vetoContent) {
                    const students = db.getStudents().filter(s => s.active !== false && (!me || s.roll !== me.roll));
                    const studentOpts = students.map(s => `<option value="${s.id}">${escapeHtml(formatRollDisplay(s.roll))} — ${escapeHtml(s.base_name || s.name || '')}</option>`).join('');
                    vetoContent.innerHTML = `
                        <p style="color:var(--text-muted);font-size:13px;margin:0 0 14px">You have <strong style="color:#f87171">${myVetos} VETO${myVetos !== 1 ? 's' : ''}</strong> remaining. Use a VETO to block a score entry — subject to teacher/admin approval.</p>
                        <div class="form-grid">
                            <div class="form-group">
                                <label>Target Student</label>
                                <select id="myVetoTarget">${studentOpts}</select>
                            </div>
                            <div class="form-group">
                                <label>Date to VETO</label>
                                <input type="date" id="myVetoDate" value="${formatDateKey(new Date())}" max="${formatDateKey(new Date())}">
                            </div>
                        </div>
                        <div class="form-group" style="margin-top:8px">
                            <label>Reason</label>
                            <textarea id="myVetoReason" rows="2" placeholder="Explain why you are using this VETO…" style="resize:vertical"></textarea>
                        </div>
                        <div class="form-buttons" style="margin-top:10px">
                            <button onclick="submitStudentVetoRequest()"><i class="fas fa-gavel"></i> Submit VETO Request</button>
                        </div>`;
                }
            }

            // ── CR/Group view ───────────────────────────────────────────────────────
            const crCard = document.getElementById('myCRCard');
            if (crCard) {
                if (pos.is_group_cr || pos.is_class_rep) {
                    crCard.style.display = '';
                    loadMyCRView(pos);
                } else {
                    crCard.style.display = 'none';
                }
            }

            // ── Group leader ────────────────────────────────────────────────────────
            const groupCard = document.getElementById('myGroupCard');
            if (groupCard) {
                if (me && (me.group || pos.cr_group)) {
                    groupCard.style.display = '';
                    loadMyGroupView(me.group || pos.cr_group);
                } else {
                    groupCard.style.display = 'none';
                }
            }

            // ── Party view ──────────────────────────────────────────────────────────
            const partyCard = document.getElementById('myPartyCard');
            if (partyCard) {
                if (pos.party_code) {
                    partyCard.style.display = '';
                    loadMyPartyView(pos.party_code);
                } else {
                    partyCard.style.display = 'none';
                }
            }

            // ── My appeals ─────────────────────────────────────────────────────────
            loadMyAppealsView();
        }

        function loadMyCRView(pos) {
            const el = document.getElementById('myCRContent');
            if (!el) return;
            const filterClass = pos.cr_class || pos.class_rep_class;
            const filterGroup = pos.cr_group;
            const month = getCurrentMonthKey();
            const sb = db.getMonthlyScoreboard(month).filter(r => {
                if (filterClass && String(r.student.class) !== String(filterClass)) return false;
                if (filterGroup && getStudentGroup(r.student) !== filterGroup) return false;
                return true;
            });
            if (!sb.length) { el.innerHTML = '<p style="color:var(--text-muted)">No data for your class yet.</p>'; return; }
            el.innerHTML = `<div class="scoreboard-wrapper"><div class="scoreboard-scroll"><table class="scoreboard">
                <thead><tr><th>#</th><th>Roll</th><th>Student</th><th>Points (${month})</th></tr></thead>
                <tbody>${sb.map((r, i) => `<tr><td>${i + 1}</td><td>${escapeHtml(formatRollDisplay(r.student.roll))}</td><td>${escapeHtml(r.student.base_name || r.student.name || '')}</td><td class="${r.total > 0 ? 'score-cell positive' : r.total < 0 ? 'score-cell negative' : 'score-cell'}">${r.total}</td></tr>`).join('')}</tbody>
            </table></div></div>`;
        }

        function loadMyGroupView(group) {
            const el = document.getElementById('myGroupContent');
            if (!el || !group) return;
            const month = getCurrentMonthKey();
            const sb = db.getMonthlyScoreboard(month).filter(r => getStudentGroup(r.student) === group);
            if (!sb.length) { el.innerHTML = '<p style="color:var(--text-muted)">No data for your group yet.</p>'; return; }
            el.innerHTML = `<p style="color:var(--text-muted);font-size:13px;margin-bottom:10px">Group ${group} standings for ${month}</p>
                <div class="scoreboard-wrapper"><div class="scoreboard-scroll"><table class="scoreboard">
                <thead><tr><th>#</th><th>Roll</th><th>Student</th><th>Points</th><th>Stars</th></tr></thead>
                <tbody>${sb.map((r, i) => `<tr class="${r.student.roll === currentStudentRoll ? 'my-own-row' : ''}"><td>${i + 1}</td><td>${escapeHtml(formatRollDisplay(r.student.roll))}</td><td>${escapeHtml(r.student.base_name || r.student.name || '')}</td><td class="${r.total > 0 ? 'score-cell positive' : r.total < 0 ? 'score-cell negative' : 'score-cell'}">${r.total}</td><td>${parseInt(r.student.stars, 10) || 0} ★</td></tr>`).join('')}</tbody>
            </table></div></div>`;
        }

        function loadMyPartyView(partyCode) {
            const el = document.getElementById('myPartyContent');
            if (!el) return;
            const data = db.getData();
            const party = (data.parties || []).find(p => p.code === partyCode);
            if (!party) { el.innerHTML = '<p style="color:var(--text-muted)">Party data not found.</p>'; return; }
            const students = db.getStudents();
            const month = getCurrentMonthKey();
            const sb = db.getMonthlyScoreboard(month);
            const activeMembers = (party.members || []).filter(m => normalizePostHolderStatus(m.status || '') === 'active');
            const rows = activeMembers.map(m => {
                const s = students.find(st => parseInt(st.id, 10) === parseInt(m.studentId, 10));
                const sbRow = s ? sb.find(r => r.student && parseInt(r.student.id, 10) === parseInt(s.id, 10)) : null;
                const pts = sbRow ? sbRow.total : '—';
                const rank = sbRow ? (sb.indexOf(sbRow) + 1) : '—';
                const name = s ? (s.base_name || s.name || '') : '(unknown)';
                const roll = s ? formatRollDisplay(s.roll) : '—';
                const desig = m.designation === 'president' ? '👑 President' : m.designation === 'deputy_president' ? 'Deputy' : 'Member';
                const isMe = s && s.roll === currentStudentRoll;
                return `<tr class="${isMe ? 'my-own-row' : ''}"><td>${rank}</td><td>${escapeHtml(roll)}</td><td>${escapeHtml(name)}</td><td style="color:var(--text-muted);font-size:12px">${desig}</td><td class="${typeof pts === 'number' && pts > 0 ? 'score-cell positive' : typeof pts === 'number' && pts < 0 ? 'score-cell negative' : 'score-cell'}">${pts}</td></tr>`;
            }).join('');
            el.innerHTML = `<p style="font-size:13px;color:var(--text-muted);margin-bottom:10px">${escapeHtml(party.full_name || party.code)} — ${activeMembers.length} active member${activeMembers.length !== 1 ? 's' : ''}</p>
                <div class="scoreboard-wrapper"><div class="scoreboard-scroll"><table class="scoreboard">
                <thead><tr><th>Rank</th><th>Roll</th><th>Student</th><th>Role</th><th>Points (${month})</th></tr></thead>
                <tbody>${rows || '<tr><td colspan="5" class="text-center" style="color:var(--text-muted)">No members found.</td></tr>'}</tbody>
            </table></div></div>`;
        }

        function loadMyAppealsView() {
            const el = document.getElementById('myAppealsContent');
            if (!el) return;
            const data = db.getData();
            const myAppeals = (data.appeals || []).filter(a => String(a.from_login_id || '') === String(currentLoginId || ''));
            if (!myAppeals.length) {
                el.innerHTML = `<p style="color:var(--text-muted);font-size:13px;margin-bottom:14px">You have no appeals yet.</p>${_myAppealForm()}`;
                return;
            }
            const rows = myAppeals.map(a => {
                const decision = a.admin_decision || 'pending';
                const color = decision === 'approved' ? '#4ade80' : decision === 'rejected' ? '#f87171' : '#fcd34d';
                return `<tr><td>${escapeHtml(a.type || '—')}</td><td>${escapeHtml((a.created_at || '').substring(0, 10))}</td><td style="color:${color};font-weight:600">${decision}</td><td style="font-size:12px;color:var(--text-muted)">${escapeHtml(a.message || '').substring(0, 60)}${(a.message || '').length > 60 ? '…' : ''}</td></tr>`;
            }).join('');
            el.innerHTML = `<div class="scoreboard-wrapper" style="margin-bottom:18px"><div class="scoreboard-scroll"><table class="scoreboard">
                <thead><tr><th>Type</th><th>Date</th><th>Status</th><th>Message</th></tr></thead>
                <tbody>${rows}</tbody>
            </table></div></div>${_myAppealForm()}`;
        }

        function _myAppealForm() {
            return `<h4 style="margin:0 0 10px;font-size:14px;color:var(--text-secondary)"><i class="fas fa-plus-circle"></i> Submit New Appeal</h4>
            <div class="form-grid">
                <div class="form-group">
                    <label>Appeal Type</label>
                    <select id="myAppealType">
                        <option value="score_dispute">Score Dispute</option>
                        <option value="profile_change">Profile Change</option>
                        <option value="general">General</option>
                    </select>
                </div>
            </div>
            <div class="form-group" style="margin-top:8px">
                <label>Message</label>
                <textarea id="myAppealMsg" rows="3" placeholder="Describe your appeal clearly…" style="resize:vertical"></textarea>
            </div>
            <div class="form-buttons" style="margin-top:10px">
                <button onclick="submitStudentAppeal()"><i class="fas fa-paper-plane"></i> Submit Appeal</button>
            </div>`;
        }

        function submitStudentVetoRequest() {
            const targetId = parseInt((document.getElementById('myVetoTarget') || {}).value, 10);
            const date = (document.getElementById('myVetoDate') || {}).value || '';
            const reason = ((document.getElementById('myVetoReason') || {}).value || '').trim();
            if (!targetId || !date) { showAlert('Please select a target student and date.', 'warning'); return; }
            if (!reason) { showAlert('Please provide a reason for the VETO.', 'warning'); return; }
            const pos = currentStudentPositions;
            db.addAppeal({
                id: Date.now(),
                type: 'veto_request',
                subject: 'VETO Request',
                from_role: 'student',
                from_login_id: currentLoginId,
                to_role: 'teacher',
                studentId: pos.studentId || 0,
                target_studentId: targetId,
                target_date: date,
                message: reason,
                admin_decision: 'pending',
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            });
            if (SERVER_SYNC.enabled) pushToServer(db.getData(), { silent: true });
            showAlert('VETO request submitted — awaiting teacher/admin approval.', 'success');
            loadMyDashboard();
        }

        function submitStudentAppeal() {
            const type = (document.getElementById('myAppealType') || {}).value || 'general';
            const msg = ((document.getElementById('myAppealMsg') || {}).value || '').trim();
            if (!msg) { showAlert('Please write your appeal message.', 'warning'); return; }
            const pos = currentStudentPositions;
            db.addAppeal({
                id: Date.now(),
                type,
                subject: type === 'score_dispute' ? 'Score Dispute' : type === 'profile_change' ? 'Profile Change Request' : 'General Appeal',
                from_role: 'student',
                from_login_id: currentLoginId,
                to_role: 'admin',
                studentId: pos.studentId || 0,
                message: msg,
                admin_decision: 'pending',
                created_at: new Date().toISOString(),
                updated_at: new Date().toISOString()
            });
            if (SERVER_SYNC.enabled) pushToServer(db.getData(), { silent: true });
            showAlert('Appeal submitted successfully.', 'success');
            loadMyAppealsView();
        }
        // ───────────────────────────────────────────────────────────────────────────

        function clearScoreForm() {
            const _today = formatDateKey(new Date());
            document.getElementById('scoreStudent').value = '';
            document.getElementById('scoreDate').value = _today;
            document.getElementById('scorePoints').value = '';
            document.getElementById('scoreStars').value = '';
            document.getElementById('scoreVetos').value = '';
            document.getElementById('scoreMonth').value = _today.substring(0, 7);
            document.getElementById('scoreNotes').value = '';
            if (document.getElementById('scoreHint')) {
                document.getElementById('scoreHint').textContent = 'Tip: Saving a score for the same student and date will update the existing entry.';
            }
            refreshStarTransferModule(false);
            loadRecordStudentTable();
        }

        let studentsSearchTimer = null;
        function debouncedLoadStudents() {
            if (studentsSearchTimer) clearTimeout(studentsSearchTimer);
            studentsSearchTimer = setTimeout(() => {
                loadStudents();
                studentsSearchTimer = null;
            }, 140);
        }

        let feesSearchTimer = null;
        function debouncedLoadFeesTab() {
            if (feesSearchTimer) clearTimeout(feesSearchTimer);
            feesSearchTimer = setTimeout(() => {
                loadFeesTab();
                feesSearchTimer = null;
            }, 160);
        }

        let _sbFilterTimer = null;
        function debouncedFilterScoreboard() {
            if (_sbFilterTimer) clearTimeout(_sbFilterTimer);
            _sbFilterTimer = setTimeout(() => {
                _sbFilterTimer = null;
                filterScoreboard();
            }, 120);
        }

        function loadStudents() {
            const allStudents = db.getStudents();
            const statusFilter = getElementValue('studentStatusFilter') || 'active';
            const classFilter = getElementValue('studentClassFilter') || '';
            const groupFilter = getElementValue('studentGroupFilter') || 'all';
            const search = (getElementValue('studentSearchFilter') || '').trim().toLowerCase();
            let students = allStudents;
            if (statusFilter === 'active') {
                students = allStudents.filter(student => student.active !== false);
            } else if (statusFilter === 'inactive') {
                students = allStudents.filter(student => student.active === false);
            }
            if (classFilter) {
                students = students.filter(student => String(student.class || '') === String(classFilter));
            }
            if (groupFilter && groupFilter !== 'all') {
                students = students.filter(student => getStudentGroup(student) === groupFilter);
            }
            if (search) {
                students = students.filter(student => {
                    const name = String(student.base_name || student.name || '').toLowerCase();
                    const roll = String(student.roll || '').toLowerCase();
                    return name.includes(search) || roll.includes(search);
                });
            }
            students = students.sort(compareStudentsByGroup);
            const tbody = document.getElementById('studentsBody');
            _showTableSkeleton('studentsBody', 7, 6);

            tbody.innerHTML = students.map(student => `
                <tr>
                    <td class="${isOfficeHolderStudent(student) ? 'office-holder-roll' : ''}">${formatRollDisplay(student.roll)}</td>
                    <td>${renderStudentName(student)}</td>
                    <td>${student.class}</td>
                    <td data-col="fees">${coalesce(student.fees, '-')}</td>
                    <td>${student.active === false ? 'Inactive' : 'Active'}</td>
                    <td>${coalesce(student.stars, 0)}</td>
                    <td>${coalesce(student.veto_count, 0)}</td>
                    <td>${computeVotePower(getStudentMonthTotal(student.id, getCurrentMonthKey()))}</td>
                    <td>
                        <button class="secondary" onclick="openEditStudent(${student.id})" style="font-size: 12px;">Edit</button>
                        <button class="secondary" onclick="removeStudentStars(${student.id})" style="font-size: 11px; background-color: #f9a825;">Remove Stars</button>
                        <button class="secondary" onclick="removeStudentVetos(${student.id})" style="font-size: 11px; background-color: #c75146;">Remove V</button>
                        <button class="secondary" onclick="toggleStudentActive(${student.id})" style="font-size: 12px;">${student.active === false ? 'Activate' : 'Deactivate'}</button>
                        <button class="secondary" onclick="deleteStudent(${student.id})" style="font-size: 12px;">Delete</button>
                    </td>
                </tr>
            `).join('');

            if (students.length === 0) {
                tbody.innerHTML = `<tr><td colspan="9" class="text-center" style="padding: 40px;">No students added yet</td></tr>`;
            } else {
                _animateTableRows('studentsList');
            }
            loadDuplicateRollAudit();
            applyColumnVisibility();
            if (document.getElementById('crStudent')) {
                loadClassRepOptions();
            }
            if (document.getElementById('candidateStudent')) {
                populateVotingSelects();
                loadCandidates();
                loadVotingCandidates();
            }
        }

        function loadDuplicateRollAudit() {
            const tbody = document.getElementById('duplicateRollBody');
            if (!tbody) return;
            const groups = {};
            db.getStudents().forEach(student => {
                const roll = formatRollDisplay(student.roll);
                if (!roll) return;
                if (!groups[roll]) groups[roll] = [];
                groups[roll].push(student);
            });
            const duplicates = Object.entries(groups)
                .filter(([, list]) => list.length > 1)
                .sort((a, b) => String(a[0]).localeCompare(String(b[0])));

            if (!duplicates.length) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center" style="padding: 24px;">No duplicate roll numbers found</td></tr>`;
                return;
            }

            tbody.innerHTML = duplicates.map(([roll, list]) =>
                list.map(student => `
                    <tr class="${student.active === false ? 'inactive-row' : ''}">
                        <td class="${isOfficeHolderStudent(student) ? 'office-holder-roll' : ''}">${roll}</td>
                        <td>${renderStudentName(student, getCurrentMonthKey())}</td>
                        <td>${student.class || '-'}</td>
                        <td>${student.active === false ? 'Inactive' : 'Active'}</td>
                        <td>
                            <button class="secondary" onclick="toggleStudentActive(${student.id})" style="font-size: 12px;">
                                ${student.active === false ? 'Activate' : 'Deactivate'}
                            </button>
                        </td>
                    </tr>
                `).join('')
            ).join('');
            autoAdjustTableFonts();
        }

        function addNewStudent() {
            const roll = document.getElementById('newRoll').value;
            const name = document.getElementById('newName').value;
            const classNum = parseInt(document.getElementById('newClass').value);
            const fees = parseInt(document.getElementById('newFees').value) || 0;
            const stars = parseInt(document.getElementById('newStars').value, 10) || 0;
            const vetos = parseInt(document.getElementById('newVetos').value, 10) || 0;

            if (!roll || !name || !classNum) {
                showAlert('Please fill all required fields', 'danger');
                return;
            }
            if (!isValidRollNo(roll)) {
                showAlert('Roll number format must be EA followed by 5 letters/numbers (7 chars total)', 'danger');
                return;
            }
            if (!isValidStudentName(name)) {
                showAlert('Student name is invalid. Remove + sign or non-student placeholder words.', 'danger');
                return;
            }

            db.addStudent({ roll, name, base_name: name, raw_name: name, class: classNum, fees, vote_power: null, stars, veto_count: vetos });
            clearStudentForm();
            loadStudents();
            loadParties();
            showAlert('Student added successfully!', 'success');
        }

        function clearStudentForm() {
            document.getElementById('newRoll').value = '';
            document.getElementById('newName').value = '';
            document.getElementById('newClass').value = '';
            document.getElementById('newFees').value = '';
            document.getElementById('newVotePower').value = '1';
            document.getElementById('newStars').value = '';
            document.getElementById('newVetos').value = '';
        }

        function syncStudentsFromList(
            studentsList,
            message,
            skipConfirm = false,
            monthStudents = null,
            monthExtraColumns = null,
            monthStudentExtras = null,
            monthRosterProfiles = null
        ) {
            if (!skipConfirm && !confirm(message)) {
                return;
            }

            const data = db.getData();
            const existingByRoll = new Map((data.students || []).map(s => [String(s.roll).toUpperCase(), s]));
            let idCounter = Date.now();

            const newStudents = studentsList.map(student => {
                const rollKey = String(student.roll || '').toUpperCase();
                const existing = existingByRoll.get(rollKey);
                const mergedStudent = {
                    ...student,
                    id: existing ? existing.id : idCounter++,
                    group: deriveGroupFromRoll(student.roll),
                    active: existing ? existing.active !== false : true,
                    raw_name: existing ? (existing.raw_name || existing.name || student.name) : (student.raw_name || student.name),
                    stars: existing ? (parseInt(existing.stars, 10) || 0) : (parseInt(student.stars, 10) || 0),
                    veto_count: existing ? (parseInt(existing.veto_count, 10) || 0) : (parseInt(student.veto_count, 10) || 0),
                    profile_data: existing ? (existing.profile_data || {}) : (student.profile_data || {})
                };
                return normalizeStudentMeta(mergedStudent);
            });

            const rollToId = new Map(newStudents.map(s => [String(s.roll).toUpperCase(), s.id]));
            const oldIdToRoll = new Map((data.students || []).map(s => [s.id, String(s.roll).toUpperCase()]));

            const newScores = (data.scores || []).map(score => {
                const roll = oldIdToRoll.get(score.studentId);
                const newId = roll ? rollToId.get(roll) : null;
                if (!newId) return null;
                return { ...score, studentId: newId };
            }).filter(Boolean);

            const remapStudentId = (studentId) => {
                const roll = oldIdToRoll.get(studentId);
                return roll ? rollToId.get(roll) : null;
            };

            const newParties = (data.parties || []).map(party => ({
                ...party,
                members: (party.members || []).map(member => {
                    const newId = remapStudentId(member.studentId);
                    return newId ? { ...member, studentId: newId } : null;
                }).filter(Boolean)
            }));

            const newClassReps = (data.class_reps || []).map(rep => {
                const newId = remapStudentId(rep.studentId);
                return newId ? { ...rep, studentId: newId } : null;
            }).filter(Boolean);

            const newGroupCRs = (data.group_crs || []).map(rep => {
                const newId = remapStudentId(rep.studentId);
                return newId ? { ...rep, studentId: newId } : null;
            }).filter(Boolean);

            const newCandidates = (data.election_candidates || []).map(candidate => {
                const newId = remapStudentId(candidate.studentId);
                return newId ? { ...candidate, studentId: newId } : null;
            }).filter(Boolean);

            const candidateIds = new Set(newCandidates.map(c => c.id));
            const newVotes = (data.election_votes || []).filter(v => candidateIds.has(v.candidateId));
            const newIndividualVotes = (data.election_individual_votes || []).map(vote => {
                const newVoterId = remapStudentId(vote.voterStudentId);
                if (!newVoterId) return null;
                const voteType = String(vote.voteType || 'candidate').toLowerCase();
                if (voteType === 'candidate') {
                    if (!candidateIds.has(vote.candidateId)) return null;
                }
                return {
                    ...vote,
                    voterStudentId: newVoterId,
                    candidateId: voteType === 'candidate' ? vote.candidateId : null,
                    voteType
                };
            }).filter(Boolean);
            const newRoleVetoGrants = (data.role_veto_grants || []).map(grant => {
                const newId = remapStudentId(grant.studentId);
                return newId ? { ...grant, studentId: newId } : null;
            }).filter(Boolean);
            const newPostHolderHistory = (data.post_holder_history || []).map(record => {
                const newId = remapStudentId(record.studentId);
                if (!record.studentId) return record;
                if (!newId) {
                    return { ...record, studentId: null };
                }
                const student = newStudents.find(item => item.id === newId);
                return {
                    ...record,
                    studentId: newId,
                    roll: student ? normalizeRoll(student.roll) : normalizeRoll(record.roll),
                    holder_name: student ? (student.base_name || student.name || record.holder_name || '') : (record.holder_name || '')
                };
            });

            db.saveData({
                ...data,
                students: newStudents,
                scores: newScores,
                month_students: monthStudents || data.month_students || {},
                month_extra_columns: monthExtraColumns || data.month_extra_columns || {},
                month_student_extras: monthStudentExtras || data.month_student_extras || {},
                month_roster_profiles: monthRosterProfiles || data.month_roster_profiles || {},
                parties: newParties,
                class_reps: newClassReps,
                group_crs: newGroupCRs,
                election_candidates: newCandidates,
                election_votes: newVotes,
                election_individual_votes: newIndividualVotes,
                role_veto_grants: newRoleVetoGrants,
                post_holder_history: newPostHolderHistory
            });
            db.ensureSchema();

            showAlert(`Students synced: ${newStudents.length} records`, 'success');
            loadStudents();
            loadScoreboard();
            loadParties();
            loadOfficeHolders();
            if (document.getElementById('candidatePost')) {
                populateVotingSelects();
                loadCandidates();
                loadVotingCandidates();
            }
        }

        function findFeb26MonthKey(monthStudentsMap) {
            const keys = Object.keys(monthStudentsMap || {});
            if (keys.includes('2026-02')) return '2026-02';
            const febCandidates = keys.filter(key => /^20\d{2}-02$/.test(key)).sort().reverse();
            return febCandidates[0] || null;
        }

        function applyActiveStatusFromMonth(monthKey, options = {}) {
            if (!monthKey) {
                if (!options.silent) showAlert('Target month not found for activation sync', 'warning');
                return;
            }
            const data = db.getData();
            const rosterProfiles = data.month_roster_profiles && data.month_roster_profiles[monthKey];
            if (Array.isArray(rosterProfiles) && rosterProfiles.length) {
                applyRosterProfilesForMonth(monthKey, rosterProfiles, {
                    skipSync: options.skipSync === true,
                    silent: options.silent === true,
                    forceGlobalActiveSync: true
                });
                return;
            }
            const roster = new Set((data.month_students && data.month_students[monthKey] || []).map(v => String(v || '').trim().toUpperCase()).filter(Boolean));
            if (!roster.size) {
                if (!options.silent) showAlert(`No roster found in ${monthKey}`, 'warning');
                return;
            }

            (data.students || []).forEach(student => {
                const rollKey = String(student.roll || '').trim().toUpperCase();
                const nameKey = String(student.base_name || student.name || '').trim().toUpperCase();
                const shouldBeActive = (rollKey && roster.has(rollKey)) || (!rollKey && nameKey && roster.has(nameKey));
                student.active = !!shouldBeActive;
            });
            db.saveData(data);
            loadStudents();
            loadScoreboard();
            initScoreForm();
            loadParties();
            loadOfficeHolders();
            loadVotingTab();
            if (!options.silent) {
                showAlert(`Activation synced from ${monthKey}: ${roster.size} roster entries`, 'success');
            }
        }

        function normalizeRosterValue(value) {
            return String(value || '').trim().toUpperCase();
        }

        function toRosterProfiles(studentsList) {
            const byRoll = new Map();
            (studentsList || []).forEach(student => {
                const roll = normalizeRosterValue(student && student.roll);
                const rawName = String(student && (student.raw_name || student.name || '')).trim();
                const parsed = extractNameMeta(rawName);
                const baseName = String(student && student.base_name ? student.base_name : parsed.baseName).trim();
                const classVal = parseInt(student && student.class, 10);
                if (!isValidRollNo(roll)) return;
                if (!isValidStudentName(baseName)) return;
                byRoll.set(roll, {
                    roll,
                    name: rawName || baseName,
                    base_name: baseName,
                    class: Number.isNaN(classVal) ? null : classVal
                });
            });
            return Array.from(byRoll.values());
        }

        function applyRosterProfilesForMonth(monthKey, rosterProfiles, options = {}) {
            const data = db.getData();
            if (!monthKey) return false;
            const normalizedProfiles = toRosterProfiles(rosterProfiles);
            if (!normalizedProfiles.length) return false;
            const rosterSet = new Set(normalizedProfiles.map(profile => profile.roll));
            const currentMonth = getCurrentMonthKey();
            const forceGlobalActiveSync = options.forceGlobalActiveSync !== false;
            let changed = false;

            data.month_students = data.month_students || {};
            data.month_roster_profiles = data.month_roster_profiles || {};

            const currentRoster = new Set((data.month_students[monthKey] || []).map(normalizeRosterValue).filter(Boolean));
            if (currentRoster.size !== rosterSet.size || Array.from(rosterSet).some(roll => !currentRoster.has(roll))) {
                data.month_students[monthKey] = Array.from(rosterSet);
                changed = true;
            }

            const currentProfiles = data.month_roster_profiles[monthKey] || [];
            const prevSignature = JSON.stringify(currentProfiles);
            const nextSignature = JSON.stringify(normalizedProfiles);
            if (prevSignature !== nextSignature) {
                data.month_roster_profiles[monthKey] = normalizedProfiles;
                changed = true;
            }

            const students = data.students || [];
            const byRoll = new Map();
            students.forEach(student => {
                const roll = normalizeRosterValue(student.roll);
                if (!roll) return;
                if (!byRoll.has(roll)) byRoll.set(roll, []);
                byRoll.get(roll).push(student);
            });

            let maxId = students.reduce((max, student) => Math.max(max, student.id || 0), 0);
            const selectedIds = new Set();

            normalizedProfiles.forEach(profile => {
                const candidates = byRoll.get(profile.roll) || [];
                const targetName = normalizeText(profile.base_name || profile.name);
                let chosen = candidates.find(candidate => normalizeText(candidate.base_name || candidate.name) === targetName);
                if (!chosen) {
                    chosen = candidates.find(candidate => candidate.active !== false) || candidates[0];
                }
                if (!chosen) {
                    maxId += 1;
                    chosen = {
                        id: maxId,
                        roll: profile.roll,
                        name: profile.name,
                        base_name: profile.base_name,
                        raw_name: profile.name,
                        class: profile.class,
                        group: deriveGroupFromRoll(profile.roll),
                        active: true
                    };
                    students.push(chosen);
                    if (!byRoll.has(profile.roll)) byRoll.set(profile.roll, []);
                    byRoll.get(profile.roll).push(chosen);
                    changed = true;
                }

                const nextName = profile.name || profile.base_name;
                const nextBaseName = profile.base_name || extractNameMeta(nextName).baseName;
                if ((chosen.name || '') !== nextName) {
                    chosen.name = nextName;
                    changed = true;
                }
                if ((chosen.base_name || '') !== nextBaseName) {
                    chosen.base_name = nextBaseName;
                    changed = true;
                }
                if ((chosen.raw_name || '') !== nextName) {
                    chosen.raw_name = nextName;
                    changed = true;
                }
                if (profile.class && chosen.class !== profile.class) {
                    chosen.class = profile.class;
                    changed = true;
                }
                if ((chosen.group || '') !== deriveGroupFromRoll(profile.roll)) {
                    chosen.group = deriveGroupFromRoll(profile.roll);
                    changed = true;
                }
                if (chosen.active === false) {
                    chosen.active = true;
                    changed = true;
                }

                selectedIds.add(chosen.id);
                (byRoll.get(profile.roll) || []).forEach(candidate => {
                    if (candidate.id === chosen.id) return;
                    if (candidate.active !== false) {
                        candidate.active = false;
                        changed = true;
                    }
                });
            });

            students.forEach(student => {
                const shouldBeActive = (forceGlobalActiveSync || monthKey === currentMonth)
                    ? selectedIds.has(student.id)
                    : (selectedIds.has(student.id) ? true : student.active !== false);
                if (student.active !== shouldBeActive) {
                    student.active = shouldBeActive;
                    changed = true;
                }
                normalizeStudentMeta(student);
            });

            data.students = students;

            const prevScoreCount = (data.scores || []).length;
            data.scores = (data.scores || []).filter(score => score.month !== monthKey || selectedIds.has(score.studentId));
            if (data.scores.length !== prevScoreCount) changed = true;

            if (data.month_student_extras && data.month_student_extras[monthKey]) {
                const allowedKeys = new Set([
                    ...normalizedProfiles.map(profile => normalizeRosterValue(profile.roll)),
                    ...normalizedProfiles.map(profile => normalizeRosterValue(profile.base_name))
                ]);
                const filteredExtras = {};
                Object.entries(data.month_student_extras[monthKey] || {}).forEach(([key, value]) => {
                    if (allowedKeys.has(normalizeRosterValue(key))) {
                        filteredExtras[key] = value;
                    }
                });
                if (Object.keys(filteredExtras).length !== Object.keys(data.month_student_extras[monthKey] || {}).length) {
                    data.month_student_extras[monthKey] = filteredExtras;
                    changed = true;
                }
            }

            if (!changed) return false;

            db.saveData(data, { skipSync: options.skipSync === true });
            if (!options.skipReload) {
                loadScoreboard();
                loadStudents();
                initScoreForm();
                loadParties();
                loadOfficeHolders();
                loadVotingTab();
            }
            if (!options.silent) {
                showAlert(`Roster applied for ${monthKey}: ${normalizedProfiles.length} active students`, 'success');
            }
            return true;
        }

        function applyFeb26RosterLock(options = {}) {
            const data = db.getData();
            const monthKey = findFeb26MonthKey(data.month_students || {}) || '2026-02';
            return applyRosterProfilesForMonth(monthKey, FEB26_STUDENT_ROSTER, {
                ...options,
                forceGlobalActiveSync: true
            });
        }

        function triggerStudentsImport() {
            const input = document.getElementById('studentsExcelFile');
            input.value = '';
            input.click();
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                importStudentsExcel(file);
            };
        }

        function triggerActiveRosterImport() {
            const input = document.getElementById('activeRosterExcelFile');
            input.value = '';
            input.click();
            input.onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                importActiveRosterFile(file);
            };
        }

        async function importStudentsExcel(file) {
            await ensureXlsxLoaded();
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const imported = parseWorkbook(workbook);
                    if (imported.students.length === 0) {
                        showAlert('No student data found in workbook', 'danger');
                        return;
                    }
                    syncStudentsFromList(
                        imported.students,
                        'Importing will update the Students tab from all sheets and remap scores by roll number. Continue?',
                        false,
                        imported.month_students || null,
                        imported.month_extra_columns || null,
                        imported.month_student_extras || null,
                        imported.month_roster_profiles || null
                    );
                    const febKey = findFeb26MonthKey(imported.month_students || {});
                    if (febKey && imported.month_roster_profiles && imported.month_roster_profiles[febKey]) {
                        applyRosterProfilesForMonth(febKey, imported.month_roster_profiles[febKey], { silent: true });
                    } else {
                        applyActiveStatusFromMonth(febKey, { silent: true });
                    }
                } catch (err) {
                    showAlert('Error reading Excel file: ' + err.message, 'danger');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        async function importActiveRosterFile(file, preferredMonth = '') {
            await ensureXlsxLoaded();
            const reader = new FileReader();
            reader.onload = (e) => {
                try {
                    const data = new Uint8Array(e.target.result);
                    const workbook = XLSX.read(data, { type: 'array' });
                    const imported = parseWorkbook(workbook);
                    const importedMonthKeys = Object.keys(imported.month_students || {}).sort().reverse();
                    let monthKey = preferredMonth || importedMonthKeys[0] || getCurrentMonthKey();
                    if (preferredMonth && importedMonthKeys.length && !importedMonthKeys.includes(preferredMonth)) {
                        monthKey = importedMonthKeys[0];
                        showAlert(`Selected month ${preferredMonth} not found. Using ${monthKey} from workbook.`, 'warning');
                    }
                    const sourceProfiles = (imported.month_roster_profiles && imported.month_roster_profiles[monthKey])
                        ? imported.month_roster_profiles[monthKey]
                        : imported.students;
                    if (!sourceProfiles || !sourceProfiles.length) {
                        showAlert('No valid roster profiles found in workbook', 'danger');
                        return;
                    }
                    if (!confirm(`Apply uploaded active roster to ${monthKey} and deactivate non-roster students?`)) {
                        return;
                    }
                    const changed = applyRosterProfilesForMonth(monthKey, sourceProfiles, {
                        forceGlobalActiveSync: true,
                        silent: false
                    });
                    if (!changed) {
                        showAlert('No roster changes detected', 'warning');
                    }
                } catch (err) {
                    showAlert('Error reading active roster workbook: ' + err.message, 'danger');
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function importActiveRosterExcel() {
            const file = getElementFile('activeRosterFile');
            if (!file) {
                showAlert('Please select the latest active roster workbook', 'danger');
                return;
            }
            const preferredMonth = getElementValue('activeRosterMonth') || '';
            importActiveRosterFile(file, preferredMonth);
        }

        function deleteStudent(studentId) {
            if (confirm('Are you sure you want to delete this student? All associated scores will be deleted.')) {
                db.deleteStudent(studentId);
                loadStudents();
                loadParties();
                showAlert('Student deleted', 'success');
            }
        }

        function removeStudentStars(studentId) {
            const student = db.getStudents().find(s => s.id === studentId);
            if (!student) {
                showAlert('Student not found', 'danger');
                return;
            }
            
            const currentStars = parseInt(student.stars, 10) || 0;
            if (currentStars === 0) {
                showAlert('This student has no stars to remove', 'warning');
                return;
            }
            
            const prompt_msg = `Remove accidental stars? (Current: ${currentStars})\n\nEnter number to remove (1-${currentStars}):`;
            const response = prompt(prompt_msg, '1');
            if (response === null) return;
            
            const removeCount = parseInt(response, 10);
            if (Number.isNaN(removeCount) || removeCount < 1 || removeCount > currentStars) {
                showAlert(`Enter a valid number between 1 and ${currentStars}`, 'danger');
                return;
            }
            
            const newStars = Math.max(0, currentStars - removeCount);
            student.stars = newStars;
            db.saveData(db.getData());
            
            loadStudents();
            loadScoreboard();
            showAlert(`Removed ${removeCount} star(s). Student now has ${newStars} stars.`, 'success');
        }

        function removeStudentVetos(studentId) {
            const student = db.getStudents().find(s => s.id === studentId);
            if (!student) {
                showAlert('Student not found', 'danger');
                return;
            }
            
            const currentVetos = parseInt(student.veto_count, 10) || 0;
            if (currentVetos === 0) {
                showAlert('This student has no VETOs to remove', 'warning');
                return;
            }
            
            const prompt_msg = `Remove accidental VETOs? (Current: ${currentVetos})\n\nEnter number to remove (1-${currentVetos}):`;
            const response = prompt(prompt_msg, '1');
            if (response === null) return;
            
            const removeCount = parseInt(response, 10);
            if (Number.isNaN(removeCount) || removeCount < 1 || removeCount > currentVetos) {
                showAlert(`Enter a valid number between 1 and ${currentVetos}`, 'danger');
                return;
            }
            
            const newVetos = Math.max(0, currentVetos - removeCount);
            student.veto_count = newVetos;
            db.saveData(db.getData());
            
            loadStudents();
            loadScoreboard();
            showAlert(`Removed ${removeCount} VETO(s). Student now has ${newVetos} VETOs.`, 'success');
        }

        function toggleStudentActive(studentId) {
            const student = db.getStudents().find(s => s.id === studentId);
            if (!student) return;
            const nextStatus = student.active === false;
            db.setStudentActive(studentId, nextStatus);
            loadStudents();
            loadScoreboard();
            initScoreForm();
            loadParties();
            loadOfficeHolders();
            loadVotingTab();
            showAlert(`Student ${nextStatus ? 'activated' : 'deactivated'}`, 'success');
        }

        function openEditStudent(studentId, options = {}) {
            const student = db.getStudents().find(s => s.id === studentId);
            if (!student) return;
            const selfOnly = options.selfOnly === true;
            isSelfProfileEditMode = selfOnly;

            document.getElementById('editStudentId').value = student.id;
            document.getElementById('editRoll').value = student.roll || '';
            document.getElementById('editName').value = student.base_name || student.name || '';
            document.getElementById('editClass').value = student.class || '';
            document.getElementById('editFees').value = coalesce(student.fees, 0);
            document.getElementById('editVotePower').value = computeVotePower(getStudentMonthTotal(student.id, getCurrentMonthKey()));
            document.getElementById('editStars').value = coalesce(student.stars, 0);
            document.getElementById('editVetos').value = coalesce(student.veto_count, 0);
            document.getElementById('editActive').value = student.active === false ? 'false' : 'true';
            const profile = student.profile_data || {};
            document.getElementById('editFatherName').value = profile.fatherName || '';
            document.getElementById('editMotherName').value = profile.motherName || '';
            document.getElementById('editDob').value = profile.dateOfBirth || '';
            document.getElementById('editBloodGroup').value = profile.bloodGroup || '';
            document.getElementById('editAadhar').value = profile.aadhar || '';
            document.getElementById('editPhone').value = profile.phone || '';
            document.getElementById('editEmail').value = profile.email || '';
            document.getElementById('editParentPhone').value = profile.parentPhone || '';
            document.getElementById('editAdmissionDate').value = profile.admissionDate || '';
            document.getElementById('editAcademicYear').value = profile.academicYear || '';
            document.getElementById('editAddress').value = profile.address || '';

            const lockIds = ['editRoll', 'editClass', 'editFees', 'editVotePower', 'editStars', 'editVetos', 'editActive'];
            lockIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.disabled = selfOnly;
            });
            const editableIds = ['editName', 'editFatherName', 'editMotherName', 'editDob', 'editBloodGroup', 'editAadhar', 'editPhone', 'editEmail', 'editParentPhone', 'editAdmissionDate', 'editAcademicYear', 'editAddress'];
            editableIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) element.disabled = false;
            });

            openModal('editStudentModal');
        }

        function openSelfProfileEdit() {
            if (currentUserRole !== 'student') return;
            const ownRoll = normalizeRoll(currentLoginId);
            const student = db.getStudents().find(item => normalizeRoll(item.roll) === ownRoll);
            if (!student) {
                showAlert('Your profile was not found. Contact Admin.', 'warning');
                return;
            }
            openEditStudent(student.id, { selfOnly: true });
        }

        async function saveStudentEdits() {
            const studentId = parseInt(document.getElementById('editStudentId').value);
            const roll = document.getElementById('editRoll').value.trim();
            const name = document.getElementById('editName').value.trim();
            const classNum = parseInt(document.getElementById('editClass').value);
            const fees = parseInt(document.getElementById('editFees').value) || 0;
            const stars = parseInt(document.getElementById('editStars').value, 10) || 0;
            const vetos = parseInt(document.getElementById('editVetos').value, 10) || 0;
            const isActive = document.getElementById('editActive').value === 'true';
            const profileData = {
                fatherName: document.getElementById('editFatherName').value.trim(),
                motherName: document.getElementById('editMotherName').value.trim(),
                dateOfBirth: document.getElementById('editDob').value,
                bloodGroup: document.getElementById('editBloodGroup').value.trim(),
                aadhar: document.getElementById('editAadhar').value.trim(),
                phone: document.getElementById('editPhone').value.trim(),
                email: document.getElementById('editEmail').value.trim(),
                parentPhone: document.getElementById('editParentPhone').value.trim(),
                admissionDate: document.getElementById('editAdmissionDate').value,
                academicYear: document.getElementById('editAcademicYear').value.trim(),
                address: document.getElementById('editAddress').value.trim()
            };

            if (currentUserRole === 'student') {
                const ownRoll = normalizeRoll(currentLoginId);
                const data = db.getData();
                const student = (data.students || []).find(item => item.id === studentId);
                if (!student || normalizeRoll(student.roll) !== ownRoll) {
                    showAlert('You can only edit your own profile.', 'warning');
                    return;
                }
                if (!name) {
                    showAlert('Please enter your name.', 'danger');
                    return;
                }
                if (!isValidStudentName(name)) {
                    showAlert('Student name is invalid. Please enter a valid name.', 'danger');
                    return;
                }

                const existingName = String(student.base_name || student.name || '').trim();
                const existingProfile = (student.profile_data && typeof student.profile_data === 'object') ? student.profile_data : {};

                const nameChanged = normalizeText(existingName) !== normalizeText(name);
                const changedFields = {};
                Object.keys(profileData || {}).forEach(key => {
                    const prev = String(existingProfile[key] || '');
                    const next = String(profileData[key] || '');
                    if (prev !== next) {
                        changedFields[key] = { from: prev, to: next };
                    }
                });

                if (!nameChanged && Object.keys(changedFields).length === 0) {
                    showAlert('No changes detected. Update fields and try again.', 'warning');
                    return;
                }

                const now = new Date().toISOString();
                const actor = normalizeRoll(currentLoginId || '');
                const record = {
                    type: 'profile_change',
                    subject: 'Profile Change Request',
                    message: `Student requested profile update for ${existingName} (${formatRollDisplay(student.roll)}).`,
                    from_role: 'student',
                    created_by: actor || 'Student',
                    target_role: 'admin',
                    forwarded_to: 'admin',
                    status: 'pending_admin',
                    recommendation: '',
                    student_id: studentId,
                    student_roll: actor || normalizeRoll(student.roll),
                    student_name: existingName,
                    requested_name: String(name || '').trim(),
                    requested_profile_data: profileData,
                    changed_fields: {
                        name: nameChanged ? { from: existingName, to: String(name || '').trim() } : null,
                        profile: changedFields
                    },
                    created_at: now,
                    updated_at: now
                };

                const created = db.addAppeal(record);

                if (SERVER_SYNC.enabled) {
                    try {
                        const resp = await fetchWithTimeout(SERVER_SYNC.dataUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            credentials: 'include',
                            body: JSON.stringify({ data: { appeals: [created] }, peers: getSyncBaseUrls() })
                        }, 4500);
                        if (resp.status === 401 || resp.status === 403) {
                            showAlert('Please re-login on this device.', 'warning');
                        } else if (!resp.ok) {
                            showAlert('Request queued locally but could not reach server. Try Master Update later.', 'warning');
                        }
                    } catch (err) {
                        showAlert('Request queued locally (offline). Try Master Update later.', 'warning');
                    }
                }

                isSelfProfileEditMode = false;
                closeModal('editStudentModal');
                loadProfileTab();
                loadAppealsTab();
                showAlert('Profile change request sent to Admin for approval.', 'success');
                return;
            }

            if (!roll || !name || !classNum) {
                showAlert('Please fill all required fields', 'danger');
                return;
            }
            if (!isValidRollNo(roll)) {
                showAlert('Roll number format must be EA followed by 5 letters/numbers (7 chars total)', 'danger');
                return;
            }
            if (!isValidStudentName(name)) {
                showAlert('Student name is invalid. Remove + sign or non-student placeholder words.', 'danger');
                return;
            }

            const normalizedRoll = normalizeRoll(roll);
            const duplicateRollHolder = db.getStudents().find(s =>
                s.id !== studentId &&
                normalizeRoll(s.roll) === normalizedRoll &&
                s.active !== false
            );
            if (duplicateRollHolder) {
                const dupName = duplicateRollHolder.base_name || duplicateRollHolder.name || 'Unknown';
                showAlert(`Roll ${formatRollDisplay(normalizedRoll)} is already assigned to ${dupName}. Use a unique roll to avoid roster shrink.`, 'danger');
                return;
            }

            db.updateStudent(studentId, {
                roll,
                name,
                base_name: name,
                raw_name: name,
                class: classNum,
                fees,
                vote_power: null,
                stars,
                veto_count: vetos,
                active: isActive,
                profile_data: profileData
            });

            isSelfProfileEditMode = false;
            closeModal('editStudentModal');
            loadStudents();
            loadScoreboard();
            loadParties();
            showAlert('Student updated successfully!', 'success');
        }

        function initRankingForm() {
            const months = db.getMonths();
            const rankingMonth = document.getElementById('rankingMonth');
            rankingMonth.innerHTML = '<option value="">Select Month...</option>' + 
                months.map(m => {
                    const date = new Date(m + '-01');
                    return `<option value="${m}">${date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</option>`;
                }).join('');
        }

        function loadRankings() {
            const month = document.getElementById('rankingMonth').value;
            if (!month) return;

            const scoreboard = db.getMonthlyScoreboard(month);
            const tbody = document.getElementById('rankingsBody');

            tbody.innerHTML = scoreboard.map((row, idx) => {
                const medals = ['gold', 'silver', 'bronze'];
                const medal = idx < 3 ? `<span class="medal ${medals[idx]}">${idx + 1}</span>` : idx + 1;

                return `<tr>
                    <td>${medal}</td>
                    <td>${renderStudentName(row.student, month)}</td>
                    <td>${row.student.class}</td>
                    <td style="font-weight: bold; color: var(--primary);">${row.total}</td>
                    <td>${idx === 0 ? '1st' : idx === 1 ? '2nd' : idx === 2 ? '3rd' : `#${idx + 1}`}</td>
                </tr>`;
            }).join('');

            if (scoreboard.length === 0) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center" style="padding: 40px;">No data for this month</td></tr>`;
            }
        }

        function loadGroupScoreboard() {
            const months = db.getMonths();
            const monthSelect = document.getElementById('groupMonthFilter');
            if (!monthSelect) return;
            monthSelect.innerHTML = months.map(m => {
                const date = new Date(m + '-01');
                return `<option value="${m}">${date.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })}</option>`;
            }).join('');
            if (!monthSelect.value && months.length) {
                monthSelect.value = months[0];
            }
            renderGroupScoreboard();
        }

        function renderGroupScoreboard() {
            const month = getElementValue('groupMonthFilter');
            const tbody = document.getElementById('groupScoreboardBody');
            const rosterBody = document.getElementById('groupRosterBody');
            const selectedGroup = getElementValue('groupFilterSelect') || 'all';
            if (!month || !tbody) return;

            let rows = db.getMonthlyScoreboard(month);
            if (selectedGroup !== 'all') {
                rows = rows.filter(row => getStudentGroup(row.student) === selectedGroup);
            }

            // Filter for students - show only their own group
            if (currentUserRole === 'student' && currentStudentRoll) {
                rows = rows.filter(row => {
                    const rollMatch = row && row.student && row.student.roll &&
                                    String(row.student.roll).trim().toUpperCase() ===
                                    String(currentStudentRoll).trim().toUpperCase();
                    return rollMatch;
                });
            }
            const groups = {};
            rows.forEach(row => {
                const key = getStudentGroup(row.student) || 'UNGROUPED';
                if (!groups[key]) {
                    groups[key] = {
                        group: key,
                        students: 0,
                        total: 0,
                        votePower: 0,
                        stars: 0,
                        vetos: 0
                    };
                }
                groups[key].students += 1;
                groups[key].total += row.total;
                groups[key].votePower += computeVotePower(row.total);
                groups[key].stars += parseInt(row.monthlyStars, 10) || 0;
                groups[key].vetos += parseInt(row.monthlyVetos, 10) || 0;
            });

            const ranked = Object.values(groups).sort((a, b) => {
                const groupDiff = getGroupSortRank(a.group) - getGroupSortRank(b.group);
                if (groupDiff !== 0) return groupDiff;
                return String(a.group || '').localeCompare(String(b.group || ''));
            });
            tbody.innerHTML = ranked.map((row, idx) => `
                <tr class="${getGroupRowClass(row.group)}">
                    <td class="rank-cell">${idx + 1}</td>
                    <td><strong>${row.group}</strong></td>
                    <td>${row.students}</td>
                    <td class="total-cell">${row.total}</td>
                    <td>${row.students ? Math.round(row.total / row.students) : 0}</td>
                    <td class="vote-cell">${row.votePower}</td>
                    <td>${row.stars}</td>
                    <td>${row.vetos}</td>
                </tr>
            `).join('');

            if (!ranked.length) {
                tbody.innerHTML = `<tr><td colspan="8" class="text-center" style="padding: 30px;">No data for selected month</td></tr>`;
            }

            if (rosterBody) {
                rosterBody.innerHTML = rows
                    .sort((a, b) => {
                        // First, sort by group rank (A, B, C, D, E, F, G, H, etc.)
                        const g = getGroupSortRank(getStudentGroup(a.student)) - getGroupSortRank(getStudentGroup(b.student));
                        if (g !== 0) return g;

                        // Then, sort by last 3 characters of roll number (e.g., A01, A02, A03...)
                        const aRoll = getLast3CharsFromRoll(a.student.roll);
                        const bRoll = getLast3CharsFromRoll(b.student.roll);
                        return aRoll.localeCompare(bRoll);
                    })
                    .map(row => `
                        <tr class="${getGroupRowClass(getStudentGroup(row.student) || 'UNGROUPED')}">
                            <td><strong>${getStudentGroup(row.student) || '-'}</strong></td>
                            <td>${formatRollDisplay(row.student.roll)}</td>
                            <td>${renderStudentName(row.student, month)}</td>
                            <td>${row.student.class || '-'}</td>
                            <td class="total-cell">${row.total}</td>
                            <td class="vote-cell">${computeVotePower(row.total)}</td>
                            <td>${coalesce(row.monthlyStars, 0)}</td>
                            <td>${coalesce(row.monthlyVetos, 0)}</td>
                        </tr>
                    `).join('');

                if (!rosterBody.innerHTML) {
                    rosterBody.innerHTML = `<tr><td colspan="8" class="text-center" style="padding: 30px;">No students for selected filters</td></tr>`;
                }
            }
            autoAdjustTableFonts();
        }

        function getGroupRowClass(groupValue) {
            const group = String(groupValue || '').trim().toUpperCase();
            if (group === 'A') return 'group-a-row';
            if (group === 'B') return 'group-b-row';
            if (group === 'C') return 'group-c-row';
            if (group === 'D') return 'group-d-row';
            if (group === 'E') return 'group-e-row';
            if (group === 'F') return 'group-f-row';
            if (group === 'G') return 'group-g-row';
            if (group === 'H') return 'group-h-row';
            return 'group-ungrouped-row';
        }

        /**
         * Extract last 3 characters from roll number for sorting
         * E.g., EA24A01 -> A01
         */
        function getLast3CharsFromRoll(roll) {
            if (!roll) return '';
            const rollStr = String(roll).trim().toUpperCase();
            // Extract last 3 characters (group letter + 2 digits)
            const match = rollStr.match(/^EA\d{2}([A-Z]\d{2})$/);
            return match ? match[1] : rollStr.slice(-3);
        }

        function loadCRTab() {
            const tbody = document.getElementById('crGroupBody');
            if (!tbody) return;
            const groupCRs = db.getGroupCRs();
            const students = db.getStudents();
            const studentMap = new Map(students.map(s => [s.id, s]));
            const todayKey = formatDateKey(new Date());
            const canEdit = currentUserRole === 'admin' || currentUserRole === 'teacher';
            const rows = DEFAULT_CR_GROUPS.map(group => {
                // Prefer an active/suspended CR over an ended one for display purposes
                const groupEntries = groupCRs.filter(item => String(item.group || '').toUpperCase() === group);
                const cr = groupEntries.find(item => normalizePostHolderStatus(item.status || 'active') !== 'ended')
                         || groupEntries[groupEntries.length - 1] || null;
                const defaultPost = `CR - Group ${group}`;
                const post = cr && cr.post ? cr.post : defaultPost;
                const candidateStudent = cr ? studentMap.get(cr.studentId) : null;
                const tenureMonths = getTenureMonthsForAssignment('group_cr', post);
                const extensionMonths = parseInt(safeProp(cr, 'tenure_extension_months'), 10) || 0;
                const isActiveAssignment = !!(cr && isAssignmentEffectivelyActive(safeProp(cr, 'status') || 'active', safeProp(cr, 'elected_on'), tenureMonths, extensionMonths, todayKey));
                const isSuspendedHolder = candidateStudent ? isStudentPostHolderSuspended(candidateStudent, todayKey) : false;
                const student = (isActiveAssignment && !isSuspendedHolder) ? candidateStudent : null;
                const tenure = getTenureStatus(safeProp(cr, 'elected_on'), tenureMonths, extensionMonths);
                const crNormalizedStatus = cr
                    ? getEffectivePostHolderStatus(
                        safeProp(cr, 'status') || 'active',
                        candidateStudent ? candidateStudent.id : safeProp(cr, 'studentId'),
                        todayKey
                    )
                    : '';
                return {
                    post,
                    group,
                    student,
                    electedOn: safeProp(cr, 'elected_on') || '',
                    tenure: !cr ? 'Vacant' : (crNormalizedStatus === 'ended' ? 'Ended' : (crNormalizedStatus === 'suspended' ? 'Suspended' : tenure.status))
                };
            });

            tbody.innerHTML = rows.map(row => `
                <tr>
                    <td>${row.post}</td>
                    <td>${row.student ? renderStudentName(row.student) : '-'}</td>
                    <td>${row.student ? formatRollDisplay(row.student.roll) : '-'}</td>
                    <td>${row.group}</td>
                    <td>${row.student ? coalesce(row.student.veto_count, 0) : '-'}</td>
                    <td>${formatDateLabel(row.electedOn)}</td>
                    <td>${row.tenure}</td>
                    <td>${canEdit
                        ? `<button class="secondary" onclick="editGroupCR('${row.group}')">Edit</button>`
                        : '-'}</td>
                </tr>
            `).join('');

            populateManualCRStudents();
            const manualDate = document.getElementById('crManualElectedOn');
            if (manualDate && !manualDate.value) {
                manualDate.value = new Date().toISOString().split('T')[0];
            }
            // Update Save button label for teachers
            const saveBtn = document.getElementById('crManualSaveBtn');
            if (saveBtn) saveBtn.textContent = currentUserRole === 'teacher' ? 'Submit for Approval' : 'Save CR';
            renderPendingCRRequests();
            autoAdjustTableFonts();
        }

        function populateManualCRStudents() {
            const studentSelect = document.getElementById('crManualStudent');
            if (!studentSelect) return;
            const month = getCurrentMonthKey();
            const profileMap = getMonthRosterProfileMap(month);
            let students = db.getStudents()
                .filter(student => isVisibleOutsideScoreboard(student))
                .sort(compareStudentsByGroup);
            if (!students.length) {
                students = getRecordScoreStudentCandidates(month, 'active').sort(compareStudentsByGroup);
            }
            studentSelect.innerHTML = '<option value="">Select Student...</option>' +
                students.map(student => {
                    const displayStudent = getMonthAwareStudent(student, month, profileMap);
                    return `<option value="${student.id}">${displayStudent.base_name || displayStudent.name} (${formatRollDisplay(displayStudent.roll)})</option>`;
                }).join('');
        }

        function clearManualGroupCRForm() {
            const postInput = document.getElementById('crManualPost');
            const groupSelect = document.getElementById('crManualGroup');
            const studentSelect = document.getElementById('crManualStudent');
            const dateInput = document.getElementById('crManualElectedOn');
            if (postInput) postInput.value = '';
            if (groupSelect) groupSelect.value = '';
            if (studentSelect) studentSelect.value = '';
            if (dateInput) dateInput.value = new Date().toISOString().split('T')[0];
        }

        /** Auto-fill the Post Name field when a group is selected in the CR edit form. */
        function autoFillCRPost() {
            const groupSelect = document.getElementById('crManualGroup');
            const postInput = document.getElementById('crManualPost');
            if (!groupSelect || !postInput) return;
            const g = String(groupSelect.value || '').trim().toUpperCase();
            postInput.value = g ? `CR - Group ${g}` : '';
        }

        function editGroupCR(group) {
            if (currentUserRole !== 'admin' && currentUserRole !== 'teacher') return;
            const groupKey = String(group || '').trim().toUpperCase();
            if (!groupKey) return;
            const data = db.getData();
            const existing = (data.group_crs || []).find(item => String(item.group || '').trim().toUpperCase() === groupKey);
            populateManualCRStudents();
            const postInput = document.getElementById('crManualPost');
            const groupSelect = document.getElementById('crManualGroup');
            const studentSelect = document.getElementById('crManualStudent');
            const dateInput = document.getElementById('crManualElectedOn');
            const noteInput = document.getElementById('crManualNote');
            if (groupSelect) groupSelect.value = groupKey;
            if (postInput) postInput.value = existing && existing.post ? existing.post : `CR - Group ${groupKey}`;
            if (studentSelect) studentSelect.value = existing && existing.studentId ? String(existing.studentId) : '';
            if (dateInput) dateInput.value = (existing && existing.elected_on) ? existing.elected_on : new Date().toISOString().split('T')[0];
            if (noteInput) noteInput.value = '';
            // Scroll to form
            const formCard = document.getElementById('crEditFormCard');
            if (formCard) formCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
        }

        function saveManualGroupCR() {
            if (currentUserRole !== 'admin' && currentUserRole !== 'teacher') {
                showAlert('Only Admin or Teacher can update CR posts.', 'warning');
                return;
            }
            const postInput = document.getElementById('crManualPost');
            const groupSelect = document.getElementById('crManualGroup');
            const studentSelect = document.getElementById('crManualStudent');
            const dateInput = document.getElementById('crManualElectedOn');
            const noteInput = document.getElementById('crManualNote');
            const post = String(postInput ? postInput.value : '').trim() || (groupSelect && groupSelect.value ? `CR - Group ${groupSelect.value.trim().toUpperCase()}` : '');
            const group = String(groupSelect ? groupSelect.value : '').trim().toUpperCase();
            const studentId = parseInt(studentSelect ? studentSelect.value : '', 10);
            const electedOn = (dateInput && dateInput.value) ? dateInput.value : new Date().toISOString().split('T')[0];
            const note = String(noteInput ? noteInput.value : '').trim();

            if (!group || !studentId) {
                showAlert('Group and Student are required for CR entry.', 'danger');
                return;
            }

            if (currentUserRole === 'teacher') {
                // Teacher: create a pending request that requires Admin approval
                const data = db.getData();
                data.pending_cr_requests = data.pending_cr_requests || [];
                data.pending_cr_requests.push({
                    id: Date.now(),
                    group,
                    post: post || `CR - Group ${group}`,
                    studentId,
                    elected_on: electedOn,
                    note,
                    requested_by: 'teacher',
                    requested_at: new Date().toISOString(),
                    status: 'pending'
                });
                db.saveData(data);
                scheduleServerPush(db.getData());
                showAlert('CR request submitted. Awaiting Admin approval.', 'success');
                clearManualGroupCRForm();
                renderPendingCRRequests();
                return;
            }

            // Admin: save directly and apply immediately
            const data = db.getData();
            data.group_crs = data.group_crs || [];
            const existing = data.group_crs.find(item => String(item.group || '').trim().toUpperCase() === group);
            if (existing) {
                existing.post = post || `CR - Group ${group}`;
                existing.studentId = studentId;
                existing.elected_on = electedOn;
                existing.status = 'active';
                existing.tenure_extension_months = 0;
                existing.tenure_extensions = [];
            } else {
                data.group_crs.push({
                    id: Date.now(),
                    group,
                    post: post || `CR - Group ${group}`,
                    studentId,
                    elected_on: electedOn,
                    status: 'active',
                    tenure_extension_months: 0,
                    tenure_extensions: []
                });
            }
            savePostHolderData(data);
            clearManualGroupCRForm();
            loadCRTab();
        }

        /**
         * Render the Pending CR Requests card.
         * Admin sees all pending requests with Approve/Reject buttons.
         * Teacher sees only their own pending requests (read-only).
         */
        function renderPendingCRRequests() {
            const card = document.getElementById('pendingCRCard');
            const body = document.getElementById('pendingCRBody');
            const subtitle = document.getElementById('pendingCRSubtitle');
            if (!card || !body) return;

            const data = db.getData();
            const requests = (data.pending_cr_requests || []).filter(r => r.status === 'pending');
            const students = db.getStudents();
            const studentMap = new Map(students.map(s => [parseInt(s.id, 10), s]));

            if (requests.length === 0) {
                card.style.display = 'none';
                return;
            }

            card.style.display = '';
            if (subtitle) {
                subtitle.textContent = currentUserRole === 'admin'
                    ? 'Review and approve or reject teacher-submitted CR changes below.'
                    : 'Your submitted CR requests are pending Admin review.';
            }

            body.innerHTML = requests.map(req => {
                const student = studentMap.get(parseInt(req.studentId, 10));
                const name = student ? (student.base_name || student.name || '-') : `Student #${req.studentId}`;
                const roll = student ? formatRollDisplay(student.roll || '') : '-';
                const reqAt = req.requested_at
                    ? new Date(req.requested_at).toLocaleDateString('en-IN', { day: '2-digit', month: 'short', year: 'numeric', hour: '2-digit', minute: '2-digit' })
                    : '-';
                const noteHtml = req.note ? `<br><small style="opacity:0.7;">${escapeHtml(req.note)}</small>` : '';
                const actions = currentUserRole === 'admin'
                    ? `<button class="secondary" style="font-size:12px;" onclick="approvePendingCRRequest(${req.id})">Approve</button>
                       <button class="secondary" style="font-size:12px;color:#f87171;" onclick="rejectPendingCRRequest(${req.id})">Reject</button>`
                    : '<span style="opacity:0.6;">Awaiting Admin</span>';
                return `<tr>
                    <td>Group ${escapeHtml(String(req.group || ''))}</td>
                    <td>${escapeHtml(name)}${noteHtml}</td>
                    <td>${roll}</td>
                    <td>${formatDateLabel(req.elected_on)}</td>
                    <td>${reqAt}</td>
                    <td><span style="color:#fbbf24;font-weight:700;">Pending</span></td>
                    <td>${actions}</td>
                </tr>`;
            }).join('');
        }

        /** Admin approves a pending CR request — applies it as an active group_cr entry. */
        function approvePendingCRRequest(reqId) {
            if (currentUserRole !== 'admin') return;
            const data = db.getData();
            const reqs = data.pending_cr_requests || [];
            const idx = reqs.findIndex(r => r.id === reqId && r.status === 'pending');
            if (idx === -1) { showAlert('Request not found.', 'warning'); return; }
            const req = reqs[idx];

            // Apply as active group_cr
            data.group_crs = data.group_crs || [];
            const existing = data.group_crs.find(item => String(item.group || '').trim().toUpperCase() === String(req.group || '').trim().toUpperCase());
            if (existing) {
                existing.post = req.post;
                existing.studentId = req.studentId;
                existing.elected_on = req.elected_on;
                existing.status = 'active';
                existing.tenure_extension_months = 0;
                existing.tenure_extensions = [];
            } else {
                data.group_crs.push({
                    id: Date.now(),
                    group: req.group,
                    post: req.post,
                    studentId: req.studentId,
                    elected_on: req.elected_on,
                    status: 'active',
                    tenure_extension_months: 0,
                    tenure_extensions: []
                });
            }
            // Mark request as approved
            reqs[idx].status = 'approved';
            reqs[idx].reviewed_at = new Date().toISOString();
            data.pending_cr_requests = reqs;

            savePostHolderData(data);
            showAlert(`CR for Group ${req.group} approved and applied.`, 'success');
            loadCRTab();
        }

        /** Admin rejects a pending CR request. */
        function rejectPendingCRRequest(reqId) {
            if (currentUserRole !== 'admin') return;
            const data = db.getData();
            const reqs = data.pending_cr_requests || [];
            const idx = reqs.findIndex(r => r.id === reqId && r.status === 'pending');
            if (idx === -1) { showAlert('Request not found.', 'warning'); return; }
            reqs[idx].status = 'rejected';
            reqs[idx].reviewed_at = new Date().toISOString();
            data.pending_cr_requests = reqs;
            db.saveData(data);
            scheduleServerPush(db.getData());
            showAlert('CR request rejected.', 'warning');
            renderPendingCRRequests();
        }

        function loadParties() {
            _showTableSkeleton('partyBody', 5, 3);
            const parties = db.getParties();
            const tbody = document.getElementById('partyBody');
            if (!activePartyId && parties.length) {
                activePartyId = parties[0].id;
            }

            const totalPower = parties.reduce((sum, party) => sum + getPartyPower(party), 0);
            tbody.innerHTML = parties.map(party => {
                const seatsUsed = (party.members || []).length;
                const power = getPartyPower(party);
                return `
                <tr>
                    <td>${formatPartyCode(party.code)}</td>
                    <td>${seatsUsed}/8</td>
                    <td>${power}</td>
                    <td>
                        <button class="secondary" onclick="setActiveParty(${party.id})" style="font-size: 12px;">Manage</button>
                        <button class="secondary" onclick="editParty(${party.id})" style="font-size: 12px;">Edit</button>
                        <button class="secondary" onclick="deleteParty(${party.id})" style="font-size: 12px;">Delete</button>
                    </td>
                </tr>
            `;
            }).join('') + (parties.length ? `
                <tr>
                    <td><strong>Total</strong></td>
                    <td></td>
                    <td><strong>${totalPower}</strong></td>
                    <td></td>
                </tr>
            ` : '');

            if (parties.length === 0) {
                tbody.innerHTML = `<tr><td colspan="4" class="text-center" style="padding: 40px;">No parties added yet</td></tr>`;
            }
            loadPartyMemberOptions();
            loadPartyMembers();
            if (document.getElementById('voteParty')) {
                populateVotingSelects();
            }
        }

        function getPartyPower(party) {
            const students = db.getActiveStudents();
            const studentMap = new Map(students.map(s => [s.id, s]));
            return (party.members || []).reduce((sum, member) => {
                const student = studentMap.get(member.studentId);
                return sum + getStudentVotePower(student);
            }, 0);
        }

        function saveParty() {
            const code = normalizePartyCode(document.getElementById('partyCode').value);

            if (!code) {
                showAlert('Please enter party code', 'danger');
                return;
            }

            const parties = db.getParties();
            const conflicting = parties.find(p =>
                normalizePartyCode(p.code) === code && (!editingPartyId || p.id !== editingPartyId)
            );

            if (editingPartyId) {
                if (conflicting) {
                    showAlert('This party code already exists. Duplicate codes are not allowed.', 'warning');
                    return;
                }
                db.updateParty(editingPartyId, { code });
                showAlert('Party updated successfully!', 'success');
            } else {
                if (conflicting) {
                    showAlert('This party already exists. Opening existing party instead of creating duplicate.', 'info');
                    setActiveParty(conflicting.id);
                    clearPartyForm();
                    loadParties();
                    return;
                }
                db.addParty({ code, members: [] });
                showAlert('Party added successfully!', 'success');
            }

            clearPartyForm();
            loadParties();
            loadOfficeHolders();
        }

        function editParty(partyId) {
            const party = db.getParties().find(p => p.id === partyId);
            if (!party) return;
            editingPartyId = partyId;
            document.getElementById('partyCode').value = normalizePartyCode(party.code) || 'MAP';
        }

        function deleteParty(partyId) {
            if (confirm('Delete this party entry?')) {
                db.deleteParty(partyId);
                if (activePartyId === partyId) {
                    activePartyId = null;
                }
                loadParties();
                loadOfficeHolders();
                showAlert('Party deleted', 'success');
            }
        }

        function clearPartyForm() {
            editingPartyId = null;
            document.getElementById('partyCode').value = 'MAP';
        }

        function loadPartyMemberOptions() {
            const parties = db.getParties();
            const students = db.getActiveStudents();
            const partySelect = document.getElementById('partyMemberParty');
            const studentSelect = document.getElementById('partyMemberStudent');
            const electedOnInput = document.getElementById('partyMemberElectedOn');

            partySelect.innerHTML = parties.map(p => `<option value="${p.id}">${formatPartyCode(p.code)}</option>`).join('');

            if (activePartyId) {
                partySelect.value = activePartyId;
            } else if (parties.length) {
                activePartyId = parties[0].id;
                partySelect.value = activePartyId;
            }

            studentSelect.innerHTML = '<option value="">Select Student...</option>' +
                students.map(s => `<option value="${s.id}">${s.base_name || s.name} (${s.roll}) [*${s.stars || 0} V${s.veto_count || 0}]</option>`).join('');

            updatePartyMemberStudentOptions();
            if (electedOnInput && !electedOnInput.value) {
                electedOnInput.value = new Date().toISOString().split('T')[0];
            }
        }

        function updatePartyMemberStudentOptions() {
            const party = db.getParties().find(p => p.id === activePartyId);
            const studentSelect = document.getElementById('partyMemberStudent');
            if (!party || !studentSelect) return;

            const students = db.getActiveStudents();
            const memberIds = new Set((party.members || []).map(m => m.studentId));
            const editingMember = (party.members || []).find(m => m.id === editingPartyMemberId);
            const allowId = editingMember ? editingMember.studentId : null;

            const filtered = students.filter(s => !memberIds.has(s.id) || s.id === allowId);
            const selected = studentSelect.value;
            studentSelect.innerHTML = '<option value="">Select Student...</option>' +
                filtered.map(s => `<option value="${s.id}">${s.base_name || s.name} (${s.roll}) [*${s.stars || 0} V${s.veto_count || 0}]</option>`).join('');
            if (selected) {
                studentSelect.value = selected;
            }
        }

        function setActiveParty(partyId) {
            activePartyId = partyId;
            const select = document.getElementById('partyMemberParty');
            if (select) {
                select.value = partyId;
            }
            editingPartyMemberId = null;
            clearPartyMemberForm(true);
            loadPartyMembers();
            updatePartyMemberStudentOptions();
        }

        function openPartyManagement(partyId) {
            switchTab('party');
            setActiveParty(partyId);
        }

        function setActivePartyFromSelect() {
            const select = document.getElementById('partyMemberParty');
            if (select && select.value) {
                activePartyId = parseInt(select.value, 10);
            }
            editingPartyMemberId = null;
            clearPartyMemberForm(true);
            loadPartyMembers();
            updatePartyMemberStudentOptions();
        }

        function loadPartyMembers() {
            const tbody = document.getElementById('partyMembersBody');
            const party = db.getParties().find(p => p.id === activePartyId);
            if (!party) {
                tbody.innerHTML = `<tr><td colspan="6" class="text-center" style="padding: 30px;">Select a party to view members</td></tr>`;
                return;
            }

            const students = db.getActiveStudents();
            const studentMap = new Map(students.map(s => [s.id, s]));
            const members = party.members || [];

            tbody.innerHTML = members.map(member => {
                const student = studentMap.get(member.studentId);
                if (!student) return '';
                const roll = student ? formatRollDisplay(student.roll) : '';
                const power = getStudentVotePower(student);
                const electionLabel = formatDateLabel(member.elected_on);
                const designationLabel = formatDesignationShort(member.designation);
                return `
                    <tr>
                        <td>${student ? renderStudentName(student) : 'Unknown'}</td>
                        <td>${roll}</td>
                        <td>${power}</td>
                        <td>${designationLabel || '-'}</td>
                        <td>${electionLabel}</td>
                        <td>
                            <button class="secondary" onclick="editPartyMember(${member.id})" style="font-size: 12px;">Edit</button>
                            <button class="secondary" onclick="deletePartyMember(${member.id})" style="font-size: 12px;">Remove</button>
                        </td>
                    </tr>
                `;
            }).filter(Boolean).join('');

            if (!tbody.innerHTML) {
                tbody.innerHTML = `<tr><td colspan="6" class="text-center" style="padding: 30px;">No members added yet</td></tr>`;
            }
        }

        function savePartyMember() {
            const partySelect = document.getElementById('partyMemberParty');
            const studentSelect = document.getElementById('partyMemberStudent');
            const designationInput = document.getElementById('partyMemberDesignation');
            const electedOnInput = document.getElementById('partyMemberElectedOn');
            const partyId = parseInt(partySelect.value, 10);
            const studentId = parseInt(studentSelect.value, 10);
            const designation = formatDesignationShort(designationInput.value.trim());
            const electedOn = electedOnInput.value || new Date().toISOString().split('T')[0];

            if (!partyId || !studentId) {
                showAlert('Select both party and student', 'danger');
                return;
            }
            activePartyId = partyId;

            const party = db.getParties().find(p => p.id === partyId);
            if (!party) return;
            const members = party.members || [];
            const existingMember = members.find(m => m.studentId === studentId);

            if (!editingPartyMemberId && members.length >= 8) {
                showAlert('This party already has 8 members', 'danger');
                return;
            }

            if (editingPartyMemberId) {
                const member = members.find(m => m.id === editingPartyMemberId);
                if (!member) return;
                if (existingMember && existingMember.id !== editingPartyMemberId) {
                    showAlert('This student is already in the party', 'danger');
                    return;
                }
                member.studentId = studentId;
                member.designation = designation;
                member.elected_on = electedOn;
                member.status = normalizePostHolderStatus(member.status || 'active');
                showAlert('Party member updated', 'success');
            } else {
                if (existingMember) {
                    showAlert('This student is already in the party', 'danger');
                    return;
                }
                members.push({
                    id: Date.now(),
                    studentId,
                    designation,
                    elected_on: electedOn,
                    status: 'active'
                });
                showAlert('Party member added', 'success');
            }

            db.updateParty(partyId, { members });
            clearPartyMemberForm();
            loadParties();
            loadOfficeHolders();
        }

        function editPartyMember(memberId) {
            const party = db.getParties().find(p => p.id === activePartyId);
            if (!party) return;
            const member = (party.members || []).find(m => m.id === memberId);
            if (!member) return;
            editingPartyMemberId = memberId;
            document.getElementById('partyMemberParty').value = party.id;
            document.getElementById('partyMemberStudent').value = member.studentId;
            document.getElementById('partyMemberDesignation').value = formatDesignationShort(member.designation) || '';
            document.getElementById('partyMemberElectedOn').value = member.elected_on || '';
            updatePartyMemberStudentOptions();
        }

        function deletePartyMember(memberId) {
            const party = db.getParties().find(p => p.id === activePartyId);
            if (!party) return;
            if (confirm('Remove this member from the party?')) {
                party.members = (party.members || []).filter(m => m.id !== memberId);
                db.updateParty(party.id, { members: party.members });
                loadParties();
                loadOfficeHolders();
                showAlert('Party member removed', 'success');
            }
        }

        function clearPartyMemberForm(keepParty = false) {
            editingPartyMemberId = null;
            if (!keepParty) {
                document.getElementById('partyMemberParty').value = activePartyId || '';
            }
            document.getElementById('partyMemberStudent').value = '';
            document.getElementById('partyMemberDesignation').value = '';
            document.getElementById('partyMemberElectedOn').value = new Date().toISOString().split('T')[0];
            updatePartyMemberStudentOptions();
        }

        function loadLeadership() {
            const posts = db.getLeadership();
            const tbody = document.getElementById('leadershipBody');
            const electedOnInput = document.getElementById('leadershipElectedOn');
            if (electedOnInput) {
                const today = new Date().toISOString().split('T')[0];
                if (!electedOnInput.value) {
                    electedOnInput.value = today;
                }
                electedOnInput.max = today;
            }

            tbody.innerHTML = posts.map(post => {
                const electedDate = post.elected_on ? formatDateLabel(post.elected_on) : '-';
                return `
                    <tr>
                        <td>${post.post}</td>
                        <td>${post.holder || '-'}</td>
                        <td>${formatRollDisplay(post.roll || '') || '-'}</td>
                        <td>${electedDate}</td>
                        <td>
                            <button class="secondary" onclick="editLeadership(${post.id})" style="font-size: 12px;">Edit</button>
                            <button class="secondary" onclick="deleteLeadership(${post.id})" style="font-size: 12px;">Delete</button>
                        </td>
                    </tr>
                `;
            }).join('');

            if (posts.length === 0) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center" style="padding: 40px;">No leadership posts added yet</td></tr>`;
            }
        }

        function saveLeadershipPost() {
            const post = document.getElementById('leadershipPost').value.trim();
            const rollInput = document.getElementById('leadershipRoll');
            const holderInput = document.getElementById('leadershipHolder');
            const roll = normalizeRoll(rollInput ? rollInput.value : '');
            if (roll && !isValidRollNo(roll)) {
                showAlert('Invalid roll number format. Use EA followed by 5 letters/numbers.', 'danger');
                return;
            }
            const matchedStudent = roll ? findStudentByRoll(roll) : null;
            const holder = matchedStudent ? (matchedStudent.base_name || matchedStudent.name || '') : String(safeProp(holderInput, 'value') || '').trim();
            const electedOn = document.getElementById('leadershipElectedOn').value || new Date().toISOString().split('T')[0];

            if (!post) {
                showAlert('Post name is required', 'danger');
                return;
            }

            const today = new Date().toISOString().split('T')[0];
            if (electedOn > today) {
                showAlert('Election date cannot be in the future.', 'danger');
                return;
            }

            if (!holder && !roll) {
                showAlert('Either roll number or holder name is required.', 'danger');
                return;
            }

            const allPosts = db.getLeadership();
            const isDuplicate = !editingLeadershipId && allPosts.some(item => 
                String(item.post || '').trim().toLowerCase() === String(post || '').trim().toLowerCase() &&
                normalizePostHolderStatus(item.status) === 'active'
            );
            if (isDuplicate) {
                showAlert('A leadership post with this name is already assigned. Edit or delete the existing post first.', 'warning');
                return;
            }

            const existing = editingLeadershipId ? db.getLeadership().find(item => item.id === editingLeadershipId) : null;
            const nextStatus = existing ? normalizePostHolderStatus(safeProp(existing, 'status') || 'active') : 'active';
            if (editingLeadershipId) {
                db.updateLeadership(editingLeadershipId, { post, holder, roll, elected_on: electedOn, status: nextStatus });
                showAlert('Leadership post updated successfully!', 'success');
            } else {
                db.addLeadership({ post, holder, roll, elected_on: electedOn, status: 'active' });
                showAlert('Leadership post added successfully!', 'success');
            }

            clearLeadershipForm();
            // Comprehensive refresh to update all tabs immediately
            refreshAllPostHolderViews();
        }

        function editLeadership(postId) {
            const post = db.getLeadership().find(p => p.id === postId);
            if (!post) return;
            editingLeadershipId = postId;
            const postSelect = document.getElementById('leadershipPost');
            const nextPost = post && post.post ? String(post.post).trim() : '';
            const hasOption = Array.from(postSelect.options).some(option => option.value === nextPost);
            postSelect.value = hasOption ? nextPost : 'LEADER (L)';
            const resolvedStudent = resolveLeadershipStudent(post);
            document.getElementById('leadershipRoll').value = formatRollDisplay(post.roll || safeProp(resolvedStudent, 'roll') || '');
            document.getElementById('leadershipHolder').value = resolvedStudent ? (resolvedStudent.base_name || resolvedStudent.name || '') : (post.holder || '');
            const electedOnField = document.getElementById('leadershipElectedOn');
            electedOnField.value = (post.elected_on || '').trim() ? post.elected_on : new Date().toISOString().split('T')[0];
            const details = document.getElementById('leadershipAutoDetails');
            if (details) {
                details.textContent = resolvedStudent
                    ? `${formatRollDisplay(resolvedStudent.roll)} | ${getStudentProfileHint(resolvedStudent)}`
                    : 'Enter roll number to auto-fill holder details.';
            }
        }

        function editLeadershipFromOffice(postId) {
            switchTab('leadership');
            editLeadership(postId);
        }

        function deleteLeadership(postId) {
            const post = db.getLeadership().find(p => p.id === postId);
            if (!post) {
                showAlert('Leadership post not found.', 'warning');
                return;
            }
            const confirmMsg = normalizePostHolderStatus(post.status) === 'active' 
                ? `Delete active post "${post.post || 'Unknown'}" and all associated records?`
                : `Delete "${post.post || 'Unknown'}" post?`;
            if (confirm(confirmMsg)) {
                db.deleteLeadership(postId);
                // Comprehensive refresh to update all tabs immediately
                refreshAllPostHolderViews();
                showAlert('Leadership post deleted. All views updated.', 'success');
            }
        }

        function clearLeadershipForm() {
            editingLeadershipId = null;
            document.getElementById('leadershipPost').value = 'LEADER (L)';
            document.getElementById('leadershipRoll').value = '';
            document.getElementById('leadershipHolder').value = '';
            const electedOnField = document.getElementById('leadershipElectedOn');
            const today = new Date().toISOString().split('T')[0];
            electedOnField.value = today;
            electedOnField.max = today;
            const details = document.getElementById('leadershipAutoDetails');
            if (details) {
                details.textContent = 'Enter roll number to auto-fill holder details.';
            }
        }

        function loadOfficeHolders() {
            if (currentUserRole === 'admin' || currentUserRole === 'teacher') {
                // Safety: opening/rendering this tab must not write/sync authoritative data.
                syncPostHolderHistory({ persist: false });
                applyMonthlyRoleVetoGrants({ persist: false });
            }
            const endAllBtn = document.getElementById('endAllTenuresBtn');
            if (endAllBtn) endAllBtn.disabled = currentUserRole !== 'admin';
            const extendBtn = document.getElementById('extendAllTenuresBtn');
            if (extendBtn) extendBtn.disabled = currentUserRole !== 'admin';
            const extendMonths = document.getElementById('extendTenureMonths');
            if (extendMonths) extendMonths.disabled = currentUserRole !== 'admin';
            const extendReason = document.getElementById('extendTenureReason');
            if (extendReason) extendReason.disabled = currentUserRole !== 'admin';
            renderLeadershipOverview();
            loadClassRepOptions();
            loadClassReps();
            renderPartyPresidents();
            populatePostHistoryMonthFilter();
            loadPostHolderHistoryReport();
            loadCRTab();
            updateNotificationsTabNotification();
            applyRolePermissions();
        }

        function renderLeadershipOverview() {
            const posts = db.getLeadership();
            const tbody = document.getElementById('officeLeadershipBody');
            if (!tbody) return;
            const todayKey = formatDateKey(new Date());
            tbody.innerHTML = posts.map(post => {
                const tenureMonths = getTenureMonthsForAssignment('leadership', post.post);
                const extensionMonths = parseInt(post.tenure_extension_months, 10) || 0;
                const holderStudent = resolveLeadershipStudent(post);
                const holderSid = holderStudent ? (holderStudent.id || 0) : 0;
                // If no holder is assigned (both holder name and roll empty, and no resolved student),
                // treat the post as Vacant regardless of stored status.
                const isVacant = !holderStudent && !String(post.holder || '').trim() && !String(post.roll || '').trim();
                const effectiveStatus = isVacant ? 'vacant' : getEffectivePostHolderStatus(post.status, holderSid, todayKey);
                const statusInfo = getPostHolderStatusInfo(effectiveStatus, post.elected_on, tenureMonths, extensionMonths);
                const holderName = holderStudent
                    ? (statusInfo.key === 'active'
                        ? renderStudentName(holderStudent)
                        : escapeHtml(holderStudent.base_name || holderStudent.name || '-'))
                    : (post.holder || '-');
                const holderRoll = holderStudent ? formatRollDisplay(holderStudent.roll || '') : formatRollDisplay(post.roll || '');
                const canManageStatus = currentUserRole === 'admin' || currentUserRole === 'teacher';
                const canEnd = currentUserRole === 'admin';
                const canEdit = currentUserRole === 'admin';
                const hasWaiver = !!post.auto_suspend_waived;
                const hasShield = !!post.veto_shield_active;
                return `
                    <tr>
                        <td>${post.post}</td>
                        <td>${holderName}</td>
                        <td>${holderRoll || '-'}</td>
                        <td>${formatDateLabel(post.elected_on)}</td>
                        <td>${formatDateLabel(statusInfo.end)}</td>
                        <td>${renderPostStatusBadge(statusInfo)}</td>
                        <td>
                            <button class="secondary" onclick="editLeadershipFromOffice(${post.id})" style="font-size: 12px;" ${canEdit ? '' : 'disabled'}>Edit</button>
                            <button class="secondary" onclick="toggleLeadershipSuspension(${post.id})" style="font-size: 12px;" data-teacher-allow="true" ${canManageStatus ? '' : 'disabled'}>${statusInfo.key === 'suspended' ? 'Resume' : 'Suspend'}</button>
                            <button class="secondary" onclick="endLeadershipTenure(${post.id})" style="font-size: 12px;" ${canEnd ? '' : 'disabled'}>End</button>
                            <button class="secondary" onclick="toggleAutoSuspendWaiver(${post.id}, 'leadership')" style="font-size: 11px;${hasWaiver ? ' background:rgba(59,130,246,0.2);color:#93c5fd;' : ''}" ${canEnd ? '' : 'disabled'} title="${hasWaiver ? 'Admin waiver active — click to remove' : 'Waive auto-suspend rule for this holder'}">${hasWaiver ? 'Waiver ON' : 'Waive'}</button>
                            <button class="secondary" onclick="toggleVetoShield(${post.id}, 'leadership', ${holderSid})" style="font-size: 11px;${hasShield ? ' background:rgba(16,185,129,0.2);color:#6ee7b7;' : ''}" ${canEnd ? '' : 'disabled'} title="${hasShield ? 'VETO Shield active (one-time) — click to deactivate' : 'Use 1 VETO to shield from next auto-suspension'}">${hasShield ? 'Shield ON' : 'VETO Shield'}</button>
                        </td>
                    </tr>
                `;
            }).join('');

            if (posts.length === 0) {
                tbody.innerHTML = `<tr><td colspan="7" class="text-center" style="padding: 30px;">No posts added yet</td></tr>`;
            }
        }

        function loadClassRepOptions() {
            const students = db.getActiveStudents();
            const studentSelect = document.getElementById('crStudent');
            if (!studentSelect) return;
            studentSelect.innerHTML = '<option value="">Select Student...</option>' +
                students.map(s => `<option value="${s.id}">${s.base_name || s.name} (${s.roll}) [*${s.stars || 0} V${s.veto_count || 0}]</option>`).join('');
            const electedOn = document.getElementById('crElectedOn');
            if (electedOn && !electedOn.value) {
                electedOn.value = new Date().toISOString().split('T')[0];
            }
        }

        function loadClassReps() {
            const groupReps = db.getGroupCRs();
            const students = db.getStudents().filter(student => isVisibleOutsideScoreboard(student));
            const studentMap = new Map(students.map(s => [s.id, s]));
            const tbody = document.getElementById('classRepBody');
            if (!tbody) return;
            const todayKey = formatDateKey(new Date());

            const canEdit = currentUserRole === 'admin' || currentUserRole === 'teacher';
            const canManageStatus = currentUserRole === 'admin' || currentUserRole === 'teacher';
            const canEnd = currentUserRole === 'admin';

            const groupRows = groupReps.map(rep => {
                const student = studentMap.get(rep.studentId);
                if (!student) return '';
                const roll = formatRollDisplay(student.roll || '');
                const tenureMonths = getTenureMonthsForAssignment('group_cr', rep.post || 'CR');
                const extensionMonths = parseInt(rep.tenure_extension_months, 10) || 0;
                const effectiveStatus = getEffectivePostHolderStatus(rep.status, student.id, todayKey);
                const statusInfo = getPostHolderStatusInfo(effectiveStatus, rep.elected_on, tenureMonths, extensionMonths);
                const groupLabel = `Group ${escapeHtml(rep.group || '-')}`;
                const editBtnTitle = currentUserRole === 'teacher' ? 'Submit edit request for Admin approval' : 'Edit';
                const repSid = student.id || 0;
                const hasWaiver = !!rep.auto_suspend_waived;
                const hasShield = !!rep.veto_shield_active;
                return `
                    <tr>
                        <td>${groupLabel}</td>
                        <td>${statusInfo.key === 'active' ? renderStudentName(student) : escapeHtml(student.base_name || student.name || 'Unknown')}</td>
                        <td>${roll}</td>
                        <td>${formatDateLabel(rep.elected_on)}</td>
                        <td>${formatDateLabel(statusInfo.end)}</td>
                        <td>${renderPostStatusBadge(statusInfo)}</td>
                        <td>
                            <button class="secondary" onclick="editGroupCRFromOffice('${escapeHtml(String(rep.group || '').toUpperCase())}')" style="font-size: 12px;" title="${editBtnTitle}" ${canEdit ? '' : 'disabled'}>Edit</button>
                            <button class="secondary" onclick="toggleGroupCRSuspension(${rep.id})" style="font-size: 12px;" data-teacher-allow="true" ${canManageStatus ? '' : 'disabled'}>${statusInfo.key === 'suspended' ? 'Resume' : 'Suspend'}</button>
                            <button class="secondary" onclick="endGroupCRTenure(${rep.id})" style="font-size: 12px;" ${canEnd ? '' : 'disabled'}>End</button>
                            <button class="secondary" onclick="toggleAutoSuspendWaiver(${rep.id}, 'group_crs')" style="font-size: 11px;${hasWaiver ? ' background:rgba(59,130,246,0.2);color:#93c5fd;' : ''}" ${canEnd ? '' : 'disabled'} title="${hasWaiver ? 'Admin waiver active — click to remove' : 'Waive auto-suspend rule for this CR'}">${hasWaiver ? 'Waiver ON' : 'Waive'}</button>
                            <button class="secondary" onclick="toggleVetoShield(${rep.id}, 'group_crs', ${repSid})" style="font-size: 11px;${hasShield ? ' background:rgba(16,185,129,0.2);color:#6ee7b7;' : ''}" ${canEnd ? '' : 'disabled'} title="${hasShield ? 'VETO Shield active (one-time) — click to deactivate' : 'Use 1 VETO to shield from next auto-suspension'}">${hasShield ? 'Shield ON' : 'VETO Shield'}</button>
                        </td>
                    </tr>
                `;
            }).filter(Boolean);

            tbody.innerHTML = groupRows.join('');

            if (!tbody.innerHTML) {
                tbody.innerHTML = `<tr><td colspan="7" class="text-center" style="padding: 30px;">No group CRs assigned yet. Use the CR Tab to assign.</td></tr>`;
            }
        }

        /**
         * Edit a Group CR from the Post Holders tab — redirects to CR Tab edit form.
         * Teacher's edit goes through the pending approval flow.
         */
        function editGroupCRFromOffice(group) {
            // Switch to CR tab and open the edit form there
            switchTab('cr');
            // Small delay to let tab render, then populate the form
            setTimeout(() => editGroupCR(group), 100);
        }

        function saveClassRep() {
            const classValue = document.getElementById('crClass').value;
            const studentId = parseInt(document.getElementById('crStudent').value, 10);
            const electedOn = document.getElementById('crElectedOn').value || new Date().toISOString().split('T')[0];

            if (!classValue || !studentId) {
                showAlert('Select class and student', 'danger');
                return;
            }

            const existingForClass = db.getClassReps().find(rep => String(rep.class) === String(classValue));

            if (editingClassRepId) {
                const existing = db.getClassReps().find(rep => rep.id === editingClassRepId);
                db.updateClassRep(editingClassRepId, { class: classValue, studentId, elected_on: electedOn, status: normalizePostHolderStatus(safeProp(existing, 'status') || 'active') });
                showAlert('Class representative updated', 'success');
            } else if (existingForClass) {
                if (!confirm('This class already has a CR. Replace?')) {
                    return;
                }
                db.updateClassRep(existingForClass.id, { class: classValue, studentId, elected_on: electedOn, status: normalizePostHolderStatus(safeProp(existingForClass, 'status') || 'active') });
                showAlert('Class representative updated', 'success');
            } else {
                db.addClassRep({ class: classValue, studentId, elected_on: electedOn, status: 'active' });
                showAlert('Class representative added', 'success');
            }

            clearClassRepForm();
            loadClassReps();
            loadOfficeHolders();
        }

        function editClassRep(repId) {
            const rep = db.getClassReps().find(r => r.id === repId);
            if (!rep) return;
            editingClassRepId = repId;
            document.getElementById('crClass').value = rep.class;
            document.getElementById('crStudent').value = rep.studentId;
            document.getElementById('crElectedOn').value = rep.elected_on || '';
        }

        function deleteClassRep(repId) {
            if (confirm('Delete this class representative?')) {
                db.deleteClassRep(repId);
                loadClassReps();
                loadOfficeHolders();
                showAlert('Class representative deleted', 'success');
            }
        }

        function clearClassRepForm() {
            editingClassRepId = null;
            document.getElementById('crClass').value = '';
            document.getElementById('crStudent').value = '';
            document.getElementById('crElectedOn').value = new Date().toISOString().split('T')[0];
        }

        function getPartyPresident(party, studentMap) {
            const member = (party.members || []).find(m => isPartyPresidentDesignation(m.designation));
            if (!member) return null;
            const student = studentMap.get(member.studentId);
            return { member, student };
        }

        function renderPartyPresidents() {
            const parties = db.getParties();
            const students = db.getActiveStudents();
            const studentMap = new Map(students.map(s => [s.id, s]));
            const tbody = document.getElementById('partyPresidentBody');
            const todayKey = formatDateKey(new Date());

            tbody.innerHTML = parties.map(party => {
                const pp = getPartyPresident(party, studentMap);
                if (!pp) {
                    const canManageStatus = currentUserRole === 'admin' || currentUserRole === 'teacher';
                    const canManage = currentUserRole === 'admin';
                    return `
                        <tr>
                            <td>${formatPartyCode(party.code)}</td>
                            <td>-</td>
                            <td>-</td>
                            <td>-</td>
                            <td>-</td>
                            <td>${renderPostStatusBadge(getPostHolderStatusInfo('vacant', ''))}</td>
                            <td>
                                <button class="secondary" onclick="openPartyManagement(${party.id})" style="font-size: 12px;" ${canManage ? '' : 'disabled'}>Manage</button>
                                <button class="secondary" onclick="togglePartyPresidentSuspension(${party.id})" style="font-size: 12px;" data-teacher-allow="true" disabled>${canManageStatus ? 'Suspend' : 'Suspend'}</button>
                            </td>
                        </tr>
                    `;
                }
                const tenureMonths = getTenureMonthsForAssignment('party_president', 'Party President');
                const extensionMonths = parseInt(pp.member.tenure_extension_months, 10) || 0;
                const ppSid = pp.student ? (pp.student.id || 0) : 0;
                const effectiveStatus = getEffectivePostHolderStatus(pp.member.status, ppSid, todayKey);
                const statusInfo = getPostHolderStatusInfo(effectiveStatus, pp.member.elected_on, tenureMonths, extensionMonths);
                const canManageStatus = currentUserRole === 'admin' || currentUserRole === 'teacher';
                const canEnd = currentUserRole === 'admin';
                const canManage = currentUserRole === 'admin';
                const hasWaiver = !!pp.member.auto_suspend_waived;
                const hasShield = !!pp.member.veto_shield_active;
                return `
                    <tr>
                        <td>${formatPartyCode(party.code)}</td>
                        <td>${pp.student ? (statusInfo.key === 'active' ? renderStudentName(pp.student) : escapeHtml(pp.student.base_name || pp.student.name || 'Unknown')) : 'Unknown'}</td>
                        <td>${pp.student ? formatRollDisplay(pp.student.roll) : ''}</td>
                        <td>${formatDateLabel(pp.member.elected_on)}</td>
                        <td>${formatDateLabel(statusInfo.end)}</td>
                        <td>${renderPostStatusBadge(statusInfo)}</td>
                        <td>
                            <button class="secondary" onclick="openPartyManagement(${party.id})" style="font-size: 12px;" ${canManage ? '' : 'disabled'}>Manage</button>
                            <button class="secondary" onclick="togglePartyPresidentSuspension(${party.id})" style="font-size: 12px;" data-teacher-allow="true" ${canManageStatus ? '' : 'disabled'}>${statusInfo.key === 'suspended' ? 'Resume' : 'Suspend'}</button>
                            <button class="secondary" onclick="endPartyPresidentTenure(${party.id})" style="font-size: 12px;" ${canEnd ? '' : 'disabled'}>End</button>
                            <button class="secondary" onclick="toggleAutoSuspendWaiver(${party.id}, 'party')" style="font-size: 11px;${hasWaiver ? ' background:rgba(59,130,246,0.2);color:#93c5fd;' : ''}" ${canEnd ? '' : 'disabled'} title="${hasWaiver ? 'Admin waiver active — click to remove' : 'Waive auto-suspend rule for this PP'}">${hasWaiver ? 'Waiver ON' : 'Waive'}</button>
                            <button class="secondary" onclick="toggleVetoShield(${party.id}, 'party', ${ppSid})" style="font-size: 11px;${hasShield ? ' background:rgba(16,185,129,0.2);color:#6ee7b7;' : ''}" ${canEnd ? '' : 'disabled'} title="${hasShield ? 'VETO Shield active (one-time) — click to deactivate' : 'Use 1 VETO to shield from next auto-suspension'}">${hasShield ? 'Shield ON' : 'VETO Shield'}</button>
                        </td>
                    </tr>
                `;
            }).join('');

            if (parties.length === 0) {
                tbody.innerHTML = `<tr><td colspan="7" class="text-center" style="padding: 30px;">No parties available</td></tr>`;
            }
        }

        function savePostHolderData(data) {
            const todayKey = formatDateKey(new Date());
            // Ensure suffix/veto recalculation uses fresh role/suspension sets for the updated payload.
            suspendedPostHolderCache.key = '';
            suspendedPostHolderCache.ids = new Set();
            votePowerSuspendedPostHolderCache.key = '';
            votePowerSuspendedPostHolderCache.ids = new Set();
            roleDisplayCache.key = '';
            roleDisplayCache.ctx = null;
            syncStudentPostHolderSuffixes(data, todayKey);
            const saveOptions = currentUserRole === 'teacher' ? { allowTeacher: true } : {};
            db.saveData(data, saveOptions);
            applyMonthlyRoleVetoGrants({ persist: true, dateKey: todayKey });
            const syncOptions = currentUserRole === 'teacher' ? { saveOptions: { allowTeacher: true } } : {};
            syncPostHolderHistory(syncOptions);
            const activeMonth = localStorage.getItem(ACTIVE_SCOREBOARD_MONTH_KEY) || getCurrentMonthKey();
            loadMonthScoreboard(activeMonth);
            loadOfficeHolders();
            loadStudents();
            loadParties();
            loadLeadership();
            showAlert('Post holder update saved', 'success');
        }

        function _resolvePostHolderActionTarget(data, table, targetId) {
            const id = parseInt(targetId, 10) || 0;
            const key = String(table || '').trim().toLowerCase();
            if (!id || !key) return null;
            if (key === 'leadership') {
                const post = (data.leadership || []).find(item => item.id === id);
                if (!post) return null;
                const holder = resolveLeadershipStudent(post);
                const holderLabel = holder ? (holder.base_name || holder.name || '-') : String(post.holder || '-').trim();
                return {
                    table: key,
                    id,
                    status: normalizePostHolderStatus(post.status || 'active'),
                    label: `${String(post.post || 'Leadership').trim()} (${holderLabel})`
                };
            }
            if (key === 'group_crs') {
                const rep = (data.group_crs || []).find(item => item.id === id);
                if (!rep) return null;
                const student = (data.students || []).find(s => parseInt(s.id, 10) === parseInt(rep.studentId, 10));
                const holderLabel = student ? (student.base_name || student.name || '-') : `Student #${rep.studentId || '-'}`;
                return {
                    table: key,
                    id,
                    status: normalizePostHolderStatus(rep.status || 'active'),
                    label: `Group ${String(rep.group || '-').trim().toUpperCase()} CR (${holderLabel})`
                };
            }
            if (key === 'class_reps') {
                const rep = (data.class_reps || []).find(item => item.id === id);
                if (!rep) return null;
                const student = (data.students || []).find(s => parseInt(s.id, 10) === parseInt(rep.studentId, 10));
                const holderLabel = student ? (student.base_name || student.name || '-') : `Student #${rep.studentId || '-'}`;
                return {
                    table: key,
                    id,
                    status: normalizePostHolderStatus(rep.status || 'active'),
                    label: `Class ${String(rep.class || '-').trim()} CR (${holderLabel})`
                };
            }
            if (key === 'party') {
                const party = (data.parties || []).find(item => item.id === id);
                if (!party) return null;
                const member = (party.members || []).find(item => isPartyPresidentDesignation(item.designation));
                if (!member) return null;
                const student = (data.students || []).find(s => parseInt(s.id, 10) === parseInt(member.studentId, 10));
                const holderLabel = student ? (student.base_name || student.name || '-') : `Student #${member.studentId || '-'}`;
                return {
                    table: key,
                    id,
                    status: normalizePostHolderStatus(member.status || 'active'),
                    label: `Party ${formatPartyCode(party.code)} PP (${holderLabel})`
                };
            }
            return null;
        }

        function submitPostHolderActionRequest(table, targetId, requestedStatus) {
            if (currentUserRole !== 'teacher') return false;
            const desired = normalizePostHolderStatus(requestedStatus);
            if (desired !== 'active' && desired !== 'suspended') return false;
            const data = db.getData();
            const target = _resolvePostHolderActionTarget(data, table, targetId);
            if (!target) {
                showAlert('Post holder record not found.', 'warning');
                return false;
            }
            if (normalizePostHolderStatus(target.status) === desired) {
                showAlert(`This post is already ${desired}.`, 'info');
                return false;
            }
            const pendingExists = (db.getAppeals() || []).some(appeal => {
                const status = String(appeal && appeal.status || '').trim().toLowerCase();
                if (status !== 'pending_admin' && status !== 'recommended') return false;
                return (
                    String(appeal && appeal.type || '').trim().toLowerCase() === 'post_holder_action' &&
                    String(appeal && appeal.target_table || '').trim().toLowerCase() === target.table &&
                    (parseInt(appeal && appeal.target_id, 10) || 0) === target.id &&
                    normalizePostHolderStatus(appeal && appeal.requested_status || '') === desired
                );
            });
            if (pendingExists) {
                showAlert('A similar request is already pending Admin approval.', 'info');
                return false;
            }

            const nowIso = new Date().toISOString();
            const actionLabel = desired === 'suspended' ? 'Suspend' : 'Resume';
            db.addAppeal({
                type: 'post_holder_action',
                subject: `Post Holder ${actionLabel} Request`,
                message: `Teacher requested ${actionLabel.toLowerCase()} for ${target.label}.`,
                from_role: 'teacher',
                created_by: currentLoginId || 'Teacher',
                target_role: 'admin',
                forwarded_to: 'admin',
                status: 'pending_admin',
                recommendation: '',
                target_table: target.table,
                target_id: target.id,
                target_label: target.label,
                current_status: normalizePostHolderStatus(target.status || 'active'),
                requested_status: desired,
                created_at: nowIso,
                updated_at: nowIso
            });
            updateAppealsTabNotification();
            showAlert(`${actionLabel} request submitted for Admin approval.`, 'success');
            return true;
        }

        function applyApprovedPostHolderAction(appeal) {
            if (!appeal || appeal.type !== 'post_holder_action') return false;
            const table = String(appeal.target_table || '').trim().toLowerCase();
            const targetId = parseInt(appeal.target_id, 10) || 0;
            const desired = normalizePostHolderStatus(appeal.requested_status || '');
            if (!targetId || (desired !== 'active' && desired !== 'suspended')) return false;
            const data = db.getData();
            let applied = false;

            if (table === 'leadership') {
                const post = (data.leadership || []).find(item => item.id === targetId);
                if (!post) return false;
                post.status = desired;
                applied = true;
            } else if (table === 'group_crs') {
                const rep = (data.group_crs || []).find(item => item.id === targetId);
                if (!rep) return false;
                rep.status = desired;
                applied = true;
            } else if (table === 'class_reps') {
                const rep = (data.class_reps || []).find(item => item.id === targetId);
                if (!rep) return false;
                rep.status = desired;
                applied = true;
            } else if (table === 'party') {
                const party = (data.parties || []).find(item => item.id === targetId);
                if (!party) return false;
                const member = (party.members || []).find(item => isPartyPresidentDesignation(item.designation));
                if (!member) return false;
                member.status = desired;
                applied = true;
            }

            if (!applied) return false;
            savePostHolderData(data);
            return true;
        }

        function toggleLeadershipSuspension(postId) {
            if (!(currentUserRole === 'admin' || currentUserRole === 'teacher')) return;
            const data = db.getData();
            const post = (data.leadership || []).find(item => item.id === postId);
            if (!post) return;
            const isSuspending = normalizePostHolderStatus(post.status) !== 'suspended';
            if (currentUserRole === 'teacher') {
                submitPostHolderActionRequest('leadership', postId, isSuspending ? 'suspended' : 'active');
                return;
            }
            pushUndoSnapshot(isSuspending ? 'Suspend leader' : 'Reinstate leader');
            post.status = isSuspending ? 'suspended' : 'active';
            savePostHolderData(data);
        }

        // ── Admin Waiver: Admin can waive automatic suspension for a post holder ──
        // Stores auto_suspend_waived=true on the post record. When the 72h enforcement
        // block fires, it checks this flag first and skips suspension.
        // Also clears any active 72h warning clocks when the waiver is granted.
        function toggleAutoSuspendWaiver(postId, table) {
            if (currentUserRole !== 'admin') { showAlert('Only Admin can manage auto-suspend waivers.', 'warning'); return; }
            const data = db.getData();
            let entry = null;
            if (table === 'leadership') {
                entry = (data.leadership || []).find(e => e.id === postId);
            } else if (table === 'group_crs') {
                entry = (data.group_crs || []).find(e => e.id === postId);
            } else if (table === 'class_reps') {
                entry = (data.class_reps || []).find(e => e.id === postId);
            } else if (table === 'party') {
                const party = (data.parties || []).find(p => p.id === postId);
                if (party) entry = (party.members || []).find(m => isPartyPresidentDesignation(m.designation));
            }
            if (!entry) { showAlert('Post record not found.', 'danger'); return; }
            const newState = !entry.auto_suspend_waived;
            entry.auto_suspend_waived = newState;
            if (newState) {
                // Granting waiver: clear any active 72h warning clocks for this student
                const sid = parseInt(entry.studentId, 10);
                if (sid) {
                    localStorage.removeItem(`ea_rank_warn_${sid}`);
                    localStorage.removeItem(`ea_veto_warn_${sid}`);
                }
            }
            savePostHolderData(data);
        }

        // ── VETO Shield: Post holder spends 1 VETO power to block the next auto-suspension ──
        // Costs 1 veto_count from the student. The shield is a one-time protection:
        // when the 72h enforcement triggers, _consumeAutoSuspendExemption clears the flag.
        // Admin can also deactivate the shield (no cost refunded).
        function toggleVetoShield(postId, table, studentId) {
            if (currentUserRole !== 'admin') { showAlert('Only Admin can manage VETO shields.', 'warning'); return; }
            const data = db.getData();
            let entry = null;
            if (table === 'leadership') {
                entry = (data.leadership || []).find(e => e.id === postId);
            } else if (table === 'group_crs') {
                entry = (data.group_crs || []).find(e => e.id === postId);
            } else if (table === 'class_reps') {
                entry = (data.class_reps || []).find(e => e.id === postId);
            } else if (table === 'party') {
                const party = (data.parties || []).find(p => p.id === postId);
                if (party) entry = (party.members || []).find(m => isPartyPresidentDesignation(m.designation));
            }
            if (!entry) { showAlert('Post record not found.', 'danger'); return; }

            if (entry.veto_shield_active) {
                // Deactivate — no VETO refunded, admin override
                if (!confirm('Remove VETO Shield? The holder will no longer be protected from auto-suspension.\nNote: the VETO spent to activate it is not refunded.')) return;
                entry.veto_shield_active = false;
                savePostHolderData(data);
                return;
            }

            // Activate — costs 1 VETO from the student
            const sid = parseInt(studentId, 10);
            const student = (data.students || []).find(s => parseInt(s.id, 10) === sid);
            if (!student) { showAlert('Student not found for this post.', 'danger'); return; }
            const currentVetos = parseInt(student.veto_count, 10) || 0;
            if (currentVetos <= 0) {
                showAlert(`${student.base_name || student.name} has no VETO power left (${currentVetos}).`, 'warning');
                return;
            }
            if (!confirm(
                `Activate VETO Shield for ${student.base_name || student.name}?\n\n` +
                `This uses 1 of their VETO power tokens.\n` +
                `The shield will block the NEXT auto-suspension trigger once, then it is consumed.\n\n` +
                `Current VETOs: ${currentVetos}  →  ${currentVetos - 1} after activation.`
            )) return;

            student.veto_count = currentVetos - 1;
            entry.veto_shield_active = true;
            const _shieldDate = new Date().toISOString().split('T')[0];
            entry.veto_shield_used_on = _shieldDate;
            // Clear active warning clocks — gives a fresh grace window after the shield
            localStorage.removeItem(`ea_rank_warn_${sid}`);
            localStorage.removeItem(`ea_veto_warn_${sid}`);
            // Record the VETO expenditure as a score entry so it appears on the scoreboard
            // that day (shows 'V' cell with reason, exactly like a regular VETO use).
            // We write directly into data.scores so savePostHolderData saves it in one shot.
            if (!data.scores) data.scores = [];
            const _existingScore = data.scores.find(s => s.studentId === sid && s.date === _shieldDate);
            const _shieldNote = '[VETO Shield] Auto-suspend blocked by VETO power';
            if (_existingScore) {
                _existingScore.vetos = (parseInt(_existingScore.vetos, 10) || 0) - 1;
                _existingScore.notes = (_existingScore.notes ? _existingScore.notes + ' | ' : '') + _shieldNote;
                _existingScore.updated_at = new Date().toISOString();
            } else {
                data.scores.push({
                    id: Date.now(),
                    studentId: sid,
                    date: _shieldDate,
                    month: _shieldDate.substring(0, 7),
                    points: 0,
                    stars: 0,
                    vetos: -1,
                    notes: _shieldNote,
                    recordedBy: 'system',
                    updated_at: new Date().toISOString()
                });
            }
            savePostHolderData(data);
        }
        // ─────────────────────────────────────────────────────────────────────────

        function toggleClassRepSuspension(repId) {
            if (!(currentUserRole === 'admin' || currentUserRole === 'teacher')) return;
            const data = db.getData();
            const rep = (data.class_reps || []).find(item => item.id === repId);
            if (!rep) return;
            const isSuspending = normalizePostHolderStatus(rep.status) !== 'suspended';
            if (currentUserRole === 'teacher') {
                submitPostHolderActionRequest('class_reps', repId, isSuspending ? 'suspended' : 'active');
                return;
            }
            rep.status = normalizePostHolderStatus(rep.status) === 'suspended' ? 'active' : 'suspended';
            savePostHolderData(data);
        }

        function toggleGroupCRSuspension(repId) {
            if (!(currentUserRole === 'admin' || currentUserRole === 'teacher')) return;
            const data = db.getData();
            const rep = (data.group_crs || []).find(item => item.id === repId);
            if (!rep) return;
            const isSuspending = normalizePostHolderStatus(rep.status) !== 'suspended';
            if (currentUserRole === 'teacher') {
                submitPostHolderActionRequest('group_crs', repId, isSuspending ? 'suspended' : 'active');
                return;
            }
            rep.status = normalizePostHolderStatus(rep.status) === 'suspended' ? 'active' : 'suspended';
            savePostHolderData(data);
        }

        function togglePartyPresidentSuspension(partyId) {
            if (!(currentUserRole === 'admin' || currentUserRole === 'teacher')) return;
            const data = db.getData();
            const party = (data.parties || []).find(item => item.id === partyId);
            if (!party) return;
            const member = (party.members || []).find(item => isPartyPresidentDesignation(item.designation));
            if (!member) {
                showAlert('No party president is currently assigned for this party.', 'warning');
                return;
            }
            const isSuspending = normalizePostHolderStatus(member.status) !== 'suspended';
            if (currentUserRole === 'teacher') {
                submitPostHolderActionRequest('party', partyId, isSuspending ? 'suspended' : 'active');
                return;
            }
            member.status = normalizePostHolderStatus(member.status) === 'suspended' ? 'active' : 'suspended';
            savePostHolderData(data);
        }

        function endLeadershipTenure(postId) {
            if (currentUserRole !== 'admin') return;
            const data = db.getData();
            data.leadership = (data.leadership || []).filter(item => item.id !== postId);
            savePostHolderData(data);
        }

        function endClassRepTenure(repId) {
            if (currentUserRole !== 'admin') return;
            const data = db.getData();
            const rep = (data.class_reps || []).find(item => item.id === repId);
            if (!rep) { showAlert('CR entry not found.', 'warning'); return; }
            rep.status = 'ended';
            rep.ended_on = new Date().toISOString().split('T')[0];
            savePostHolderData(data);
        }

        function endGroupCRTenure(repId) {
            if (currentUserRole !== 'admin') return;
            const data = db.getData();
            const cr = (data.group_crs || []).find(item => item.id === repId);
            if (!cr) { showAlert('CR entry not found.', 'warning'); return; }
            cr.status = 'ended';
            cr.ended_on = new Date().toISOString().split('T')[0];
            savePostHolderData(data);
        }

        function endPartyPresidentTenure(partyId) {
            if (currentUserRole !== 'admin') return;
            const data = db.getData();
            const party = (data.parties || []).find(item => item.id === partyId);
            if (!party) return;
            const member = (party.members || []).find(item => isPartyPresidentDesignation(item.designation));
            if (!member) {
                showAlert('No party president is currently assigned for this party.', 'warning');
                return;
            }
            member.designation = '';
            member.status = 'vacant';
            savePostHolderData(data);
        }

        function endAllPostHolderTenures() {
            if (currentUserRole !== 'admin') return;
            if (!confirm('End tenure of all current post holders? This will vacate leadership, CR and party president roles immediately.')) return;
            const data = db.getData();
            data.leadership = [];
            data.class_reps = [];
            data.group_crs = [];
            (data.parties || []).forEach(party => {
                (party.members || []).forEach(member => {
                    if (isPartyPresidentDesignation(member.designation)) {
                        member.designation = '';
                        member.status = 'vacant';
                    }
                });
            });
            savePostHolderData(data);
        }

        function extendAllPostHolderTenures() {
            if (currentUserRole !== 'admin') return;
            const monthsInput = document.getElementById('extendTenureMonths');
            const reasonInput = document.getElementById('extendTenureReason');
            const months = parseInt(safeProp(monthsInput, 'value'), 10);
            const reason = String(safeProp(reasonInput, 'value') || '').trim();

            if (!Number.isFinite(months) || months < 1 || months > 12) {
                showAlert('Enter extension months between 1 and 12.', 'danger');
                return;
            }
            if (!reason) {
                showAlert('Enter reason for tenure extension.', 'warning');
                return;
            }

            const confirmMsg = `Extend tenure of all active post holders by ${months} month(s)?`;
            if (!confirm(confirmMsg)) return;

            const data = db.getData();
            const nowIso = new Date().toISOString();
            const byUser = currentLoginId || 'Admin';
            let updated = 0;
            const applyExtension = (item, fallbackStatus = 'active') => {
                const status = normalizePostHolderStatus(safeProp(item, 'status') || fallbackStatus);
                if (status !== 'active') return;
                const current = parseInt(safeProp(item, 'tenure_extension_months'), 10) || 0;
                item.tenure_extension_months = current + months;
                item.tenure_extensions = Array.isArray(item.tenure_extensions) ? item.tenure_extensions : [];
                item.tenure_extensions.push({
                    months,
                    reason,
                    by: byUser,
                    at: nowIso
                });
                updated += 1;
            };

            (data.leadership || []).forEach(post => applyExtension(post, 'active'));
            (data.class_reps || []).forEach(rep => applyExtension(rep, 'active'));
            (data.group_crs || []).forEach(rep => applyExtension(rep, 'active'));
            (data.parties || []).forEach(party => {
                (party.members || []).forEach(member => {
                    if (!isPartyPresidentDesignation(member.designation)) return;
                    applyExtension(member, 'active');
                });
            });

            if (!updated) {
                showAlert('No active post holders found for extension.', 'warning');
                return;
            }

            savePostHolderData(data);
            if (reasonInput) reasonInput.value = '';
        }

        function buildSystemNotifications() {
            const today = formatDateKey(new Date());
            const messages = [];
            const data = db.getData();
            const students = new Map((data.students || []).map(student => [student.id, student]));

            const pushTenureMessage = (title, holder, roll, electedOn, statusValue, tenureMonths, extensionMonths) => {
                const statusInfo = getPostHolderStatusInfo(
                    statusValue,
                    electedOn,
                    parseInt(tenureMonths, 10) || 2,
                    parseInt(extensionMonths, 10) || 0
                );
                if (statusInfo.key === 'suspended') {
                    messages.push({
                        level: 'warn',
                        title: `${title} is suspended`,
                        detail: `${holder || '-'} (${roll || '-'}) is currently suspended.`,
                        meta: `Selection: ${formatDateLabel(electedOn)}`
                    });
                    return;
                }
                if (statusInfo.key !== 'active') return;
                if (statusInfo.overdue) {
                    messages.push({
                        level: 'danger',
                        title: `${title} tenure is overdue`,
                        detail: `${holder || '-'} (${roll || '-'}) crossed tenure end date on ${formatDateLabel(statusInfo.end)}.`,
                        meta: `Selection: ${formatDateLabel(electedOn)}`
                    });
                    return;
                }
                if (statusInfo.dueSoon) {
                    messages.push({
                        level: 'warn',
                        title: `${title} tenure ending soon`,
                        detail: `${holder || '-'} (${roll || '-'}) will complete tenure on ${formatDateLabel(statusInfo.end)}.`,
                        meta: `Selection: ${formatDateLabel(electedOn)}`
                    });
                }
            };

            (data.leadership || []).forEach(post => {
                const resolved = resolveLeadershipStudent(post);
                const holder = resolved ? (resolved.base_name || resolved.name || post.holder || '-') : (post.holder || '-');
                const roll = resolved ? formatRollDisplay(resolved.roll || post.roll || '') : formatRollDisplay(post.roll || '');
                const tenureMonths = getTenureMonthsForAssignment('leadership', post.post);
                const extensionMonths = parseInt(post.tenure_extension_months, 10) || 0;
                pushTenureMessage(String(post.post || 'Leadership Post'), holder, roll, post.elected_on, post.status, tenureMonths, extensionMonths);
            });

            (data.class_reps || []).forEach(rep => {
                const student = students.get(rep.studentId);
                const holder = student ? (student.base_name || student.name || '-') : '-';
                const roll = student ? formatRollDisplay(student.roll || '') : '-';
                const tenureMonths = getTenureMonthsForAssignment('class_rep', rep.post || 'CR');
                const extensionMonths = parseInt(rep.tenure_extension_months, 10) || 0;
                pushTenureMessage(`Class Representative - Class ${rep.class}`, holder, roll, rep.elected_on, rep.status, tenureMonths, extensionMonths);
            });

            (data.group_crs || []).forEach(rep => {
                const student = students.get(rep.studentId);
                const holder = student ? (student.base_name || student.name || '-') : '-';
                const roll = student ? formatRollDisplay(student.roll || '') : '-';
                const tenureMonths = getTenureMonthsForAssignment('group_cr', rep.post || 'CR');
                const extensionMonths = parseInt(rep.tenure_extension_months, 10) || 0;
                pushTenureMessage(`Group CR - Group ${rep.group || '-'}`, holder, roll, rep.elected_on, rep.status, tenureMonths, extensionMonths);
            });

            (data.parties || []).forEach(party => {
                const member = (party.members || []).find(item => isPartyPresidentDesignation(item.designation));
                if (!member) return;
                const student = students.get(member.studentId);
                const holder = student ? (student.base_name || student.name || '-') : '-';
                const roll = student ? formatRollDisplay(student.roll || '') : '-';
                const tenureMonths = getTenureMonthsForAssignment('party_president', 'Party President');
                const extensionMonths = parseInt(member.tenure_extension_months, 10) || 0;
                pushTenureMessage(`Party President - ${formatPartyCode(party.code)}`, holder, roll, member.elected_on, member.status, tenureMonths, extensionMonths);
            });

            if (currentUserRole === 'admin') {
                const pendingAppeals = db.getAppeals().filter(a => (a.target_role === 'admin' || a.forwarded_to === 'admin') && (a.status === 'pending_admin' || a.status === 'recommended')).length;
                if (pendingAppeals > 0) {
                    messages.push({
                        level: 'info',
                        title: 'Appeals pending admin action',
                        detail: `${pendingAppeals} appeal(s) are waiting for admin review.`,
                        meta: `As on ${formatDateLabel(today)}`
                    });
                }
                const pendingHomework = db.getHomework().filter(item => item.perusal_status === 'pending_admin').length;
                if (pendingHomework > 0) {
                    messages.push({
                        level: 'info',
                        title: 'Homework perusal pending',
                        detail: `${pendingHomework} homework endorsement record(s) are pending admin perusal.`,
                        meta: `As on ${formatDateLabel(today)}`
                    });
                }
            }

            return messages;
        }

        function getNotificationFingerprint(item) {
            if (!item) return '';
            const title = String(item.title || '').trim();
            const detail = String(item.detail || '').trim();
            const meta = String(item.meta || '').trim();
            return `${title}||${detail}||${meta}`.toLowerCase();
        }

        function archiveNotifications(messages) {
            const items = Array.isArray(messages) ? messages : [];
            if (!items.length) return false;
            const digest = items.map(getNotificationFingerprint).filter(Boolean).sort().join('##');
            if (digest && digest === lastNotificationArchiveDigest) {
                return false;
            }
            lastNotificationArchiveDigest = digest;

            const data = db.getData();
            data.notification_history = Array.isArray(data.notification_history) ? data.notification_history : [];
            const history = data.notification_history;
            const existing = new Set(history.map(item => String(item.fingerprint || getNotificationFingerprint(item) || '').trim()).filter(Boolean));
            const nowIso = new Date().toISOString();
            let changed = false;

            items.forEach(item => {
                const fp = getNotificationFingerprint(item);
                if (!fp || existing.has(fp)) return;
                history.push({
                    id: Date.now() + Math.floor(Math.random() * 1000) + history.length,
                    fingerprint: fp,
                    level: String(item.level || 'info'),
                    title: String(item.title || 'Notification'),
                    detail: String(item.detail || '-'),
                    meta: String(item.meta || ''),
                    logged_at: nowIso
                });
                existing.add(fp);
                changed = true;
            });

            if (!changed) return false;
            if (currentUserRole === 'teacher') {
                db.saveData(data, { allowTeacher: true });
            } else if (currentUserRole === 'admin') {
                db.saveData(data);
            } else {
                db._cacheData = data;
            }
            return true;
        }

        function getNotificationHistory() {
            const data = db.getData();
            const history = Array.isArray(data.notification_history) ? data.notification_history : [];
            return history.slice().sort((a, b) => {
                const aStamp = Date.parse(String(a.logged_at || '')) || 0;
                const bStamp = Date.parse(String(b.logged_at || '')) || 0;
                return bStamp - aStamp;
            });
        }

        function updateNotificationsTabNotification() {
            const button = document.getElementById('notificationsTabButton');
            if (!button) return;
            const currentMessages = buildSystemNotifications();
            archiveNotifications(currentMessages);
            notificationCache = currentMessages;
            const danger = currentMessages.filter(m => m.level === 'danger').length;
            const warn   = currentMessages.filter(m => m.level === 'warn').length;
            const pending = currentMessages.length;
            button.classList.toggle('tab-alert', pending > 0);
            let badge = '';
            if (danger > 0) badge = `<span class="tab-count" style="background:#ef4444">${danger}</span>`;
            else if (warn > 0) badge = `<span class="tab-count" style="background:#f59e0b">${warn}</span>`;
            else if (pending > 0) badge = `<span class="tab-count">${pending}</span>`;
            button.innerHTML = `<i class="fas fa-bell"></i> Notifications${badge}`;
        }

        function _notifLevelIcon(level) {
            if (level === 'danger') return 'fas fa-exclamation-circle';
            if (level === 'warn')   return 'fas fa-exclamation-triangle';
            return 'fas fa-info-circle';
        }

        function openNotificationSpotlight(idx) {
            _notifSelectedIdx = idx;
            const panel = document.getElementById('notifDetailPanel');
            if (!panel) return;
            const item = notificationCache[idx];
            if (!item) { panel.style.display = 'none'; return; }
            panel.className = 'notif-detail-panel ' + (item.level || 'info');
            panel.style.display = '';
            panel.innerHTML = `
                <div class="ndp-icon ${item.level === 'danger' ? 'style="color:#f87171"' : item.level === 'warn' ? 'style="color:#fbbf24"' : 'style="color:#38bdf8"'}">
                    <i class="${_notifLevelIcon(item.level)}"></i>
                </div>
                <div class="ndp-title">${escapeHtml(item.title || 'Notification')}</div>
                <div class="ndp-detail">${escapeHtml(item.detail || '-')}</div>
                <div class="ndp-meta">${escapeHtml(item.meta || '')}</div>
            `;
            // Highlight selected card
            document.querySelectorAll('#notifLiveList .notif-card').forEach((el, i) => {
                el.classList.toggle('selected', i === idx);
            });
        }

        // Kept for backward compatibility (was called from old onclick inline HTML that may persist in cache)
        function openNotificationDetailsModal(index) { openNotificationSpotlight(index); }

        function setNotifFilter(level) {
            _notifFilter = level || 'all';
            // Update button active states
            ['all','danger','warn','info'].forEach(l => {
                const btn = document.getElementById('notifF_' + l);
                if (!btn) return;
                btn.className = '';
                if (l === _notifFilter) {
                    btn.className = l === 'all' ? 'nf-active' : `nf-${l}-active`;
                }
            });
            _renderNotifLiveSection();
        }

        function _renderNotifLiveSection() {
            const liveList = document.getElementById('notifLiveList');
            const countBadge = document.getElementById('notifLiveCount');
            if (!liveList) return;

            const liveMsgs = buildSystemNotifications();
            notificationCache = liveMsgs;

            const filtered = _notifFilter === 'all' ? liveMsgs : liveMsgs.filter(m => m.level === _notifFilter);
            if (countBadge) countBadge.textContent = liveMsgs.length;

            if (!filtered.length) {
                const emptyMsg = _notifFilter === 'all'
                    ? '<i class="fas fa-check-circle" style="color:#22c55e"></i><p>All clear — no active alerts.</p>'
                    : `<i class="fas fa-filter"></i><p>No ${_notifFilter} alerts right now.</p>`;
                liveList.innerHTML = `<div class="notif-empty">${emptyMsg}</div>`;
                const panel = document.getElementById('notifDetailPanel');
                if (panel) panel.style.display = 'none';
                return;
            }

            liveList.innerHTML = filtered.map((item, idx) => {
                const realIdx = liveMsgs.indexOf(item);
                return `<button class="notif-card ${escapeHtml(item.level || 'info')}${realIdx === _notifSelectedIdx ? ' selected' : ''}"
                    onclick="openNotificationSpotlight(${realIdx})" data-allow="true">
                    <i class="notif-card-icon ${_notifLevelIcon(item.level)}"></i>
                    <div class="notif-card-body">
                        <div class="notif-card-title">${escapeHtml(item.title || 'Notification')}</div>
                        <div class="notif-card-detail">${escapeHtml(item.detail || '-')}</div>
                        <div class="notif-card-meta">${escapeHtml(item.meta || '')}</div>
                    </div>
                    <div class="notif-live-dot ${escapeHtml(item.level || 'info')}"></div>
                </button>`;
            }).join('');

            // Auto-open first item in panel
            if (_notifSelectedIdx < 0 || !liveMsgs[_notifSelectedIdx]) {
                openNotificationSpotlight(0);
            }
        }

        function _renderNotifHistorySection() {
            const histList  = document.getElementById('notifHistoryList');
            const clearBtn  = document.getElementById('notifClearHistBtn');
            if (!histList) return;

            const liveFPs = new Set(buildSystemNotifications().map(getNotificationFingerprint).filter(Boolean));
            const history = getNotificationHistory();

            if (clearBtn) clearBtn.style.display = (currentUserRole === 'admin' && history.length > 0) ? '' : 'none';

            if (!history.length) {
                histList.innerHTML = '<div class="notif-empty"><i class="fas fa-inbox"></i><p>No log entries yet.</p></div>';
                return;
            }

            histList.innerHTML = history.map(item => {
                const fp    = String(item.fingerprint || getNotificationFingerprint(item) || '');
                const isLive = fp && liveFPs.has(fp);
                const stamp  = item.logged_at ? formatDateLabel(item.logged_at) : '';
                return `<div class="notif-history-row ${escapeHtml(item.level || 'info')}${isLive ? ' live-in-log' : ''}">
                    <div class="nhr-dot"></div>
                    <div class="nhr-body">
                        <div class="nhr-title">${escapeHtml(item.title || 'Notification')}</div>
                        <div class="nhr-stamp">${escapeHtml(item.detail || '-')}${stamp ? ' · ' + stamp : ''}</div>
                    </div>
                </div>`;
            }).join('');
        }

        function loadNotificationsTab() {
            _notifSelectedIdx = -1;
            archiveNotifications(buildSystemNotifications());
            _renderNotifLiveSection();
            _renderNotifHistorySection();
            updateNotificationsTabNotification();
        }

        function clearNotificationHistory() {
            if (currentUserRole !== 'admin') return;
            if (!confirm('Clear the full notification log? This cannot be undone.')) return;
            const data = db.getData();
            data.notification_history = [];
            db.saveData(data);
            lastNotificationArchiveDigest = '';
            _renderNotifHistorySection();
            showAlert('Notification log cleared.', 'success');
        }

        function refreshPostHolderNotifications() {
            updateNotificationsTabNotification();
            const notificationsTab = document.getElementById('notifications-tab');
            if (notificationsTab && !notificationsTab.classList.contains('hidden')) {
                loadNotificationsTab();
            }
            showAlert('Notifications refreshed.', 'success');
        }

        function getActivityLogRows() {
            const data = db.getData();
            const rows = Array.isArray(data.activity_log) ? data.activity_log : [];
            return rows.slice().sort((a, b) => {
                const aa = Date.parse(String(a && a.logged_at || '')) || 0;
                const bb = Date.parse(String(b && b.logged_at || '')) || 0;
                return bb - aa;
            });
        }

        function populateActivityLogUserFilter(rows) {
            const select = document.getElementById('activityLogUserFilter');
            if (!select) return;
            const current = select.value || '';
            const users = Array.from(new Set((rows || [])
                .map(r => String(r && r.actor_login_id || '').trim())
                .filter(Boolean))).sort((a, b) => a.localeCompare(b));
            select.innerHTML = '<option value="">All Users</option>' + users.map(u => `<option value="${escapeHtml(u)}">${escapeHtml(u)}</option>`).join('');
            if (users.includes(current)) select.value = current;
        }

        function populateActivityLogClassFilter(rows) {
            const select = document.getElementById('activityLogClassFilter');
            if (!select) return;
            const current = select.value || '';
            const classes = Array.from(new Set((rows || [])
                .map(r => String(r && r.class || '').trim())
                .filter(Boolean))).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));
            select.innerHTML = '<option value="">All Classes</option>' + classes.map(c => `<option value="${escapeHtml(c)}">${escapeHtml(c)}</option>`).join('');
            if (classes.includes(current)) select.value = current;
        }

        function resetActivityLogFilters() {
            const ids = [
                'activityLogUserFilter',
                'activityLogClassFilter',
                'activityLogStudentFilter',
                'activityLogMonthFilter',
                'activityLogFromDate',
                'activityLogToDate'
            ];
            ids.forEach(id => {
                const el = document.getElementById(id);
                if (!el) return;
                if (el.tagName === 'SELECT') el.value = '';
                else el.value = '';
            });
            loadActivityLogTab();
        }

        function loadActivityLogTab() {
            const tbody = document.getElementById('activityLogBody');
            if (!tbody) return;
            const rows = getActivityLogRows();
            populateActivityLogUserFilter(rows);
            populateActivityLogClassFilter(rows);

            const userFilter = String(getElementValue('activityLogUserFilter') || '').trim().toLowerCase();
            const classFilter = String(getElementValue('activityLogClassFilter') || '').trim();
            const studentFilter = String(getElementValue('activityLogStudentFilter') || '').trim().toLowerCase();
            const monthFilter = String(getElementValue('activityLogMonthFilter') || '').trim();
            const fromDate = String(getElementValue('activityLogFromDate') || '').trim();
            const toDate = String(getElementValue('activityLogToDate') || '').trim();

            const filtered = rows.filter(item => {
                if (!item || typeof item !== 'object') return false;
                const actor = String(item.actor_login_id || '').trim().toLowerCase();
                const cls = String(item.class || '').trim();
                const roll = String(item.student_roll || '').trim().toLowerCase();
                const name = String(item.student_name || '').trim().toLowerCase();
                const month = String(item.month || '').trim();
                const date = String(item.date || '').trim();
                if (userFilter && actor !== userFilter) return false;
                if (classFilter && cls !== classFilter) return false;
                if (studentFilter && !roll.includes(studentFilter) && !name.includes(studentFilter)) return false;
                if (monthFilter && month !== monthFilter) return false;
                if (fromDate && date && date < fromDate) return false;
                if (toDate && date && date > toDate) return false;
                return true;
            }).slice(0, 3000);

            if (!filtered.length) {
                tbody.innerHTML = '<tr><td colspan="9" class="text-center" style="padding: 24px;">No activity log entries for selected filters.</td></tr>';
                return;
            }

            tbody.innerHTML = filtered.map(item => {
                const ts = item.logged_at ? formatDateLabel(item.logged_at) : '-';
                const studentLabel = [String(item.student_roll || '').trim(), String(item.student_name || '').trim()].filter(Boolean).join(' - ');
                return `<tr>
                    <td>${escapeHtml(ts)}</td>
                    <td>${escapeHtml(String(item.actor_login_id || '-'))}</td>
                    <td>${escapeHtml(String(item.actor_role || '-'))}</td>
                    <td>${escapeHtml(String(item.class || '-'))}</td>
                    <td>${escapeHtml(studentLabel || '-')}</td>
                    <td>${escapeHtml(String(item.entity || '-'))}</td>
                    <td>${escapeHtml(String(item.action || '-'))}</td>
                    <td>${escapeHtml(String(item.date || '-'))}</td>
                    <td>${escapeHtml(String(item.detail || '-'))}</td>
                </tr>`;
            }).join('');
        }

        function getPostHistoryStatus(record) {
            if (!record) return 'Unknown';
            if (record.end_date) return 'Ended';
            if (normalizePostHolderStatus(record.status) === 'suspended') return 'Suspended';
            return 'Active';
        }

        function getHistoryDurationLabel(startDate, endDate) {
            if (!startDate) return '-';
            const start = new Date(startDate);
            if (Number.isNaN(start.getTime())) return '-';
            const end = endDate ? new Date(endDate) : new Date();
            if (Number.isNaN(end.getTime())) return '-';
            const diff = Math.max(1, Math.ceil((end - start) / (1000 * 60 * 60 * 24)));
            return `${diff} day${diff === 1 ? '' : 's'}`;
        }

        function populatePostHistoryMonthFilter() {
            const select = document.getElementById('postHistoryMonth');
            if (!select) return;
            const currentValue = select.value || '';
            const months = new Set(db.getMonths());
            db.getPostHolderHistory().forEach(record => {
                if (record.start_date) months.add(String(record.start_date).substring(0, 7));
                if (record.end_date) months.add(String(record.end_date).substring(0, 7));
            });
            const sorted = Array.from(months).filter(Boolean).sort().reverse();
            select.innerHTML = '<option value=\"\">All Months</option>' + sorted.map(month => {
                const label = new Date(`${month}-01`).toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                return `<option value="${month}">${label}</option>`;
            }).join('');
            if (sorted.includes(currentValue)) {
                select.value = currentValue;
            }
        }

        function clearPostHistoryFilters() {
            const month = document.getElementById('postHistoryMonth');
            const from = document.getElementById('postHistoryFrom');
            const to = document.getElementById('postHistoryTo');
            const status = document.getElementById('postHistoryStatus');
            if (month) month.value = '';
            if (from) from.value = '';
            if (to) to.value = '';
            if (status) status.value = 'all';
            loadPostHolderHistoryReport();
        }

        function doesHistoryRecordMatchFilters(record, monthFilter, fromDate, toDate, statusFilter) {
            const status = getPostHistoryStatus(record).toLowerCase();
            if (statusFilter === 'active' && status !== 'active') return false;
            if (statusFilter === 'suspended' && status !== 'suspended') return false;
            if (statusFilter === 'ended' && status !== 'ended') return false;

            const recordStart = String(record.start_date || '');
            const recordEnd = String(record.end_date || '');

            if (monthFilter) {
                const monthStart = `${monthFilter}-01`;
                const monthEnd = addMonths(monthStart, 1) ? addDays(addMonths(monthStart, 1), -1) : `${monthFilter}-31`;
                const effectiveEnd = recordEnd || '9999-12-31';
                if (recordStart > monthEnd || effectiveEnd < monthStart) return false;
            }

            if (fromDate) {
                const effectiveEnd = recordEnd || '9999-12-31';
                if (effectiveEnd < fromDate) return false;
            }
            if (toDate) {
                if (recordStart > toDate) return false;
            }
            return true;
        }

        function loadPostHolderHistoryReport() {
            const tbody = document.getElementById('postHistoryBody');
            if (!tbody) return;
            const monthFilter = getElementValue('postHistoryMonth');
            const fromDate = getElementValue('postHistoryFrom');
            const toDate = getElementValue('postHistoryTo');
            const statusFilter = getElementValue('postHistoryStatus') || 'all';
            const studentMap = new Map(db.getStudents().map(student => [student.id, student]));

            const rows = db.getPostHolderHistory()
                .filter(record => doesHistoryRecordMatchFilters(record, monthFilter, fromDate, toDate, statusFilter))
                .sort((a, b) => String(b.start_date || '').localeCompare(String(a.start_date || '')));

            tbody.innerHTML = rows.map(record => {
                const student = studentMap.get(record.studentId);
                const holderName = student
                    ? renderStudentName(student, String(record.start_date || '').substring(0, 7))
                    : escapeHtml(record.holder_name || '-');
                const status = getPostHistoryStatus(record);
                return `
                    <tr>
                        <td>${escapeHtml(record.post || '-')}</td>
                        <td>${holderName}</td>
                        <td>${formatRollDisplay(record.roll)}</td>
                        <td>${formatDateLabel(record.start_date)}</td>
                        <td>${formatDateLabel(record.end_date)}</td>
                        <td>${getHistoryDurationLabel(record.start_date, record.end_date)}</td>
                        <td>${status}</td>
                    </tr>
                `;
            }).join('');

            if (!rows.length) {
                tbody.innerHTML = '<tr><td colspan="7" class="text-center" style="padding: 30px;">No post holder history for selected filters.</td></tr>';
            }
        }

        function loadProfilePostHistory(studentId) {
            const tbody = document.getElementById('profilePostHistoryBody');
            const empty = document.getElementById('profilePostHistoryEmpty');
            if (!tbody) return;
            if (!studentId) {
                tbody.innerHTML = '<tr><td colspan="6" class="text-center" style="padding: 24px;">Select a student to view post history.</td></tr>';
                if (empty) empty.textContent = 'Select a student to view post history.';
                return;
            }
            const rows = db.getPostHolderHistory()
                .filter(record => record.studentId === studentId)
                .sort((a, b) => String(b.start_date || '').localeCompare(String(a.start_date || '')));

            tbody.innerHTML = rows.map(record => {
                const status = getPostHistoryStatus(record);
                return `
                    <tr>
                        <td>${escapeHtml(record.post || '-')}</td>
                        <td>${formatRollDisplay(record.roll)}</td>
                        <td>${formatDateLabel(record.start_date)}</td>
                        <td>${formatDateLabel(record.end_date)}</td>
                        <td>${getHistoryDurationLabel(record.start_date, record.end_date)}</td>
                        <td>${status}</td>
                    </tr>
                `;
            }).join('');

            if (!rows.length) {
                tbody.innerHTML = '<tr><td colspan="6" class="text-center" style="padding: 24px;">No post holder history.</td></tr>';
            }
            if (empty) {
                const activeCount = rows.filter(record => !record.end_date).length;
                empty.textContent = activeCount > 0
                    ? `${activeCount} active post assignment(s) currently running.`
                    : 'No active post assignments.';
            }
        }

        function loadVotingTab() {
            populateVotingSelects();
            populateGroupVoteStudentSelect();
            updateCandidateStudentsByPost();
            loadCandidates();
            loadVotingCandidates();
            updateGroupVoteStudentDetails();
            loadGroupVotingCandidates();
            loadPendingElectionApprovals();
            // Re-populate after paint in case tab rendering/sync updates students asynchronously.
            setTimeout(() => {
                populateGroupVoteStudentSelect();
                updateGroupVoteStudentDetails();
            }, 120);
        }

        function loadTeachersTab() {
            const tbody = document.getElementById('teacherBody');
            if (!tbody) return;
            const teachers = db.getTeachers();
            if (!teachers.length) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center" style="padding: 24px;">No teachers added yet.</td></tr>`;
                return;
            }
            tbody.innerHTML = teachers.map(t => {
                const active = t.active !== false;
                return `
                    <tr>
                        <td>${escapeHtml(t.name || '')}</td>
                        <td>${escapeHtml(t.roll || '')}</td>
                        <td>${escapeHtml(t.subject || '')}</td>
                        <td>${active ? '<span class="badge success">Active</span>' : '<span class="badge warning">Inactive</span>'}</td>
                        <td>
                            <button class="secondary" style="font-size:12px;" onclick="openEditTeacher(${t.id})">Edit</button>
                            <button class="danger" style="font-size:12px;" onclick="deleteTeacher(${t.id})">Delete</button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function resetTeacherForm() {
            editingTeacherId = null;
            const name = document.getElementById('teacherName');
            const roll = document.getElementById('teacherRoll');
            const subject = document.getElementById('teacherSubject');
            const active = document.getElementById('teacherActive');
            if (name) name.value = '';
            if (roll) roll.value = '';
            if (subject) subject.value = '';
            if (active) active.value = 'true';
        }

        function openEditTeacher(teacherId) {
            const teacher = db.getTeachers().find(t => t.id === teacherId);
            if (!teacher) return;
            editingTeacherId = teacherId;
            const name = document.getElementById('teacherName');
            const roll = document.getElementById('teacherRoll');
            const subject = document.getElementById('teacherSubject');
            const active = document.getElementById('teacherActive');
            if (name) name.value = teacher.name || '';
            if (roll) roll.value = teacher.roll || '';
            if (subject) subject.value = teacher.subject || '';
            if (active) active.value = teacher.active !== false ? 'true' : 'false';
        }

        function saveTeacher() {
            const name = (document.getElementById('teacherName')?.value || '').trim();
            const roll = (document.getElementById('teacherRoll')?.value || '').trim();
            const subject = (document.getElementById('teacherSubject')?.value || '').trim();
            const active = document.getElementById('teacherActive')?.value !== 'false';
            if (!name) {
                showAlert('Teacher name is required.', 'danger');
                return;
            }
            if (editingTeacherId) {
                db.updateTeacher(editingTeacherId, { name, roll, subject, active });
                showAlert('Teacher updated.', 'success');
            } else {
                db.addTeacher({ name, roll, subject, active });
                showAlert('Teacher added.', 'success');
            }
            resetTeacherForm();
            loadTeachersTab();
            loadTeacherVotingTab();
        }

        function deleteTeacher(teacherId) {
            if (!confirm('Delete this teacher?')) return;
            db.deleteTeacher(teacherId);
            loadTeachersTab();
            loadTeacherVotingTab();
            showAlert('Teacher removed.', 'success');
        }

        function getMaxStudentVotePower() {
            const students = db.getActiveStudents();
            let maxPower = 0;
            students.forEach(s => {
                const power = getStudentVotePower(s);
                if (power > maxPower) maxPower = power;
            });
            return maxPower;
        }

        function getTeacherVotePower() {
            return getMaxStudentVotePower() + 5;
        }

        function populateTeacherVoteSelects() {
            const teacherSelect = document.getElementById('teacherVoteTeacher');
            const postSelect = document.getElementById('teacherVotePost');
            if (!teacherSelect || !postSelect) return;
            const prevTeacher = teacherSelect.value;
            const prevPost = postSelect.value;
            const teachers = db.getTeachers().filter(t => t.active !== false);
            if (!teachers.length) {
                teacherSelect.innerHTML = '<option value="">No teachers added</option>';
            } else {
                teacherSelect.innerHTML = '<option value="">Select Teacher...</option>' +
                    teachers.map(t => `<option value="${t.id}">${escapeHtml(t.name || '')}${t.roll ? ` (${escapeHtml(t.roll)})` : ''}</option>`).join('');
            }
            if (prevTeacher && Array.from(teacherSelect.options).some(o => o.value === prevTeacher)) {
                teacherSelect.value = prevTeacher;
            }
            const posts = getVotingPosts();
            if (!posts.length) {
                postSelect.innerHTML = '<option value="">No posts available</option>';
            } else {
                postSelect.innerHTML = '<option value="">Select Post...</option>' +
                    posts.map(p => `<option value="${p}">${p}</option>`).join('');
            }
            if (prevPost && Array.from(postSelect.options).some(o => o.value === prevPost)) {
                postSelect.value = prevPost;
            }
        }

        function updateTeacherVotePower() {
            const display = document.getElementById('teacherVotePowerDisplay');
            if (!display) return;
            const power = getTeacherVotePower();
            display.textContent = power > 0 ? power : '-';
        }

        function loadTeacherVotingTab() {
            populateTeacherVoteSelects();
            updateTeacherVotePower();
            loadTeacherVotingCandidates();
        }

        function loadTeacherVotingCandidates() {
            const tbody = document.getElementById('teacherVotingBody');
            const statusEl = document.getElementById('teacherVoteStatus');
            const post = getElementValue('teacherVotePost');
            const teacherId = getElementValue('teacherVoteTeacher');
            if (!tbody || !statusEl) return;
            if (!post || !teacherId) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center loading">Select teacher & post</td></tr>`;
                statusEl.textContent = 'Select teacher and post to start voting.';
                return;
            }
            const candidates = db.getCandidates().filter(c => c.post === post);
            const students = db.getActiveStudents();
            const studentMap = new Map(students.map(s => [s.id, s]));
            const votes = db.getTeacherVotes().filter(v => String(v.post || '') === String(post));
            const teacherVote = votes.find(v => String(v.teacherId) === String(teacherId));
            const voteCounts = votes.reduce((acc, v) => {
                acc[v.candidateId] = (acc[v.candidateId] || 0) + 1;
                return acc;
            }, {});
            const teacherPower = getTeacherVotePower();
            const canVote = !!teacherId && !!post;
            statusEl.textContent = teacherVote
                ? `This teacher has already voted for ${teacherVote.candidateId ? 'a candidate' : 'this post'}.`
                : 'Ready to vote.';
            tbody.innerHTML = candidates.map(candidate => {
                const student = studentMap.get(candidate.studentId);
                if (!student) return '';
                const count = voteCounts[candidate.id] || 0;
                const weight = count * teacherPower;
                const votedThis = teacherVote && String(teacherVote.candidateId) === String(candidate.id);
                const buttonLabel = votedThis ? 'Voted' : 'Vote';
                const disabled = (!canVote || teacherVote) ? 'disabled' : '';
                return `
                    <tr>
                        <td>${student ? renderStudentName(student) : 'Unknown'}</td>
                        <td>${student ? formatRollDisplay(student.roll) : ''}</td>
                        <td>${student ? student.class : '-'}</td>
                        <td>${weight.toFixed(1)}</td>
                        <td>
                            <button class="secondary" onclick="castTeacherVote(${candidate.id})" style="font-size: 12px;" ${disabled}>${buttonLabel}</button>
                        </td>
                    </tr>
                `;
            }).filter(Boolean).join('');

            if (!tbody.innerHTML) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center" style="padding: 24px;">No candidates for this post.</td></tr>`;
            }
        }

        function castTeacherVote(candidateId) {
            const post = getElementValue('teacherVotePost');
            const teacherId = getElementValue('teacherVoteTeacher');
            if (!post || !teacherId) {
                showAlert('Select teacher and post before voting.', 'warning');
                return;
            }
            db.recordTeacherVote({
                post,
                teacherId: parseInt(teacherId, 10) || teacherId,
                candidateId,
                voteType: 'candidate',
                timestamp: new Date().toISOString()
            });
            showAlert('Teacher vote recorded.', 'success');
            loadTeacherVotingCandidates();
        }

        function getPendingResult(post, source) {
            return db.getPendingResults().find(r =>
                String(r.post || '').trim().toLowerCase() === String(post || '').trim().toLowerCase() &&
                String(r.source || '').trim().toLowerCase() === String(source || '').trim().toLowerCase() &&
                String(r.status || 'pending').trim().toLowerCase() === 'pending'
            );
        }

        function queuePendingElectionResult({ post, candidateId, source, detail = '', summary = '' }) {
            if (!post || !candidateId || !source) return;
            const pending = {
                post,
                candidateId,
                source,
                status: 'pending',
                detail,
                summary,
                created_at: new Date().toISOString(),
                decided_at: ''
            };
            db.upsertPendingResult(pending);
            loadPendingElectionApprovals();
        }

        function reconcilePendingElectionApprovals() {
            if (currentUserRole !== 'admin') return false;
            const data = db.getData();
            const pendingList = (data.pending_election_results || []);
            let changed = false;
            const nowIso = new Date().toISOString();
            pendingList.forEach(item => {
                if (String(item.status || 'pending').trim().toLowerCase() !== 'pending') return;
                const candidate = (data.election_candidates || []).find(c => parseInt(c.id, 10) === parseInt(item.candidateId, 10));
                if (!candidate) return;
                const applied = isElectionOutcomeApplied(item.post, candidate.studentId);
                if (!applied) return;
                item.status = 'approved';
                item.decided_at = nowIso;
                item.updated_at = nowIso;
                changed = true;
            });
            if (changed) {
                db.saveData(data);
            }
            return changed;
        }

        function reconcileApprovedElectionOutcomes() {
            if (currentUserRole !== 'admin') return false;
            const records = db.getPendingResults() || [];
            if (!records.length) return false;
            const approvedByPost = new Map();
            records.forEach(item => {
                const status = String(item.status || '').trim().toLowerCase();
                if (status !== 'approved') return;
                const postKey = String(item.post || '').trim().toLowerCase();
                if (!postKey) return;
                const prev = approvedByPost.get(postKey);
                const prevStamp = parseSyncStamp(prev?.decided_at || prev?.updated_at || prev?.created_at || '');
                const nextStamp = parseSyncStamp(item.decided_at || item.updated_at || item.created_at || '');
                if (!prev || nextStamp >= prevStamp) {
                    approvedByPost.set(postKey, item);
                }
            });
            let changed = false;
            const nowIso = new Date().toISOString();
            approvedByPost.forEach((item, postKey) => {
                const candidate = (db.getCandidates() || []).find(c => parseInt(c.id, 10) === parseInt(item.candidateId, 10));
                if (!candidate) return;
                if (!isElectionOutcomeApplied(item.post, candidate.studentId)) {
                    const ok = db.applyElectionOutcome(item.post, item.candidateId, (item.decided_at || nowIso).split('T')[0]);
                    if (ok) changed = true;
                }
                records.forEach(other => {
                    const samePost = String(other.post || '').trim().toLowerCase() === postKey;
                    const otherStatus = String(other.status || 'pending').trim().toLowerCase();
                    if (!samePost || other === item || otherStatus !== 'pending') return;
                    other.status = 'superseded';
                    other.decided_at = item.decided_at || nowIso;
                    other.updated_at = nowIso;
                    changed = true;
                });
            });
            if (changed) {
                const data = db.getData();
                db.saveData(data);
            }
            return changed;
        }

        function loadPendingElectionApprovals() {
            const card = document.getElementById('pendingElectionCard');
            const tbody = document.getElementById('pendingElectionBody');
            if (!card || !tbody) return;
            if (currentUserRole !== 'admin') {
                card.classList.add('hidden');
                return;
            }
            card.classList.remove('hidden');
            reconcileApprovedElectionOutcomes();
            reconcilePendingElectionApprovals();
            const pending = db.getPendingResults().filter(item => String(item.status || 'pending').trim().toLowerCase() === 'pending');
            if (!pending.length) {
                tbody.innerHTML = `<tr><td colspan="6" class="text-center" style="padding: 24px;">No pending approvals.</td></tr>`;
                return;
            }
            const studentMap = new Map(db.getStudents().map(s => [s.id, s]));
            tbody.innerHTML = pending.map(item => {
                const candidate = db.getCandidates().find(c => c.id === item.candidateId);
                const student = candidate ? studentMap.get(candidate.studentId) : null;
                return `
                    <tr>
                        <td>${escapeHtml(item.post || '')}</td>
                        <td>${student ? renderStudentName(student) : 'Candidate'}</td>
                        <td>${escapeHtml(item.source || '')}</td>
                        <td>${escapeHtml(item.status || 'pending')}</td>
                        <td>${formatDateLabel(item.created_at)}</td>
                        <td>
                            <button class="secondary" style="font-size:12px;" onclick="approvePendingResult('${escapeHtml(item.post)}','${escapeHtml(item.source)}')">Approve</button>
                            <button class="danger" style="font-size:12px;" onclick="denyPendingResult('${escapeHtml(item.post)}','${escapeHtml(item.source)}')">Deny</button>
                        </td>
                    </tr>
                `;
            }).join('');
        }

        function approvePendingResult(post, source) {
            if (currentUserRole !== 'admin') return;
            const pending = getPendingResult(post, source);
            if (!pending) {
                showAlert('Pending record not found.', 'warning');
                loadPendingElectionApprovals();
                return;
            }
            const applied = db.applyElectionOutcome(pending.post, pending.candidateId, new Date().toISOString().split('T')[0]);
            if (!applied) {
                showAlert('Approval failed: candidate or post mapping is invalid.', 'danger');
                return;
            }
            db.decidePendingResult(pending.post, pending.source, 'approved');
            loadOfficeHolders();
            loadCRTab();
            loadPendingElectionApprovals();
            showAlert('Approved and applied.', 'success');
        }

        function denyPendingResult(post, source) {
            if (currentUserRole !== 'admin') return;
            db.decidePendingResult(post, source, 'denied');
            loadPendingElectionApprovals();
            showAlert('Pending result denied.', 'warning');
        }

        function renderTeacherVoteResults(post, forceConclude = false, showModal = false) {
            const result = document.getElementById('teacherVoteResult');
            if (!result) return;
            if (!post) {
                result.textContent = '';
                return;
            }
            const teachers = db.getTeachers().filter(t => t.active !== false);
            const totalEligible = teachers.length;
            if (totalEligible === 0) {
                result.textContent = 'No active teachers available for voting.';
                return;
            }
            const votes = db.getTeacherVotes().filter(v => String(v.post || '') === String(post));
            const votesCast = new Set(votes.map(v => String(v.teacherId))).size;
            const teacherPower = getTeacherVotePower();
            const totalEligibleWeight = totalEligible * teacherPower;
            const avgEligibleWeight = teacherPower;
            const majorityWeight = totalEligibleWeight / 2;
            const concluded = forceConclude || votesCast >= totalEligible;

            const weightByCandidate = votes.reduce((acc, v) => {
                if (!v.candidateId) return acc;
                acc[v.candidateId] = (acc[v.candidateId] || 0) + teacherPower;
                return acc;
            }, {});
            const topEntry = Object.entries(weightByCandidate).sort((a, b) => b[1] - a[1])[0] || [null, 0];
            const topCandidateId = topEntry[0] ? parseInt(topEntry[0], 10) : null;
            const topWeight = topEntry[1] || 0;
            const secondWeight = Object.entries(weightByCandidate).sort((a, b) => b[1] - a[1])[1]?.[1] || 0;

            if (!concluded) {
                const msg = `Waiting for votes: ${votesCast}/${totalEligible}.`;
                result.textContent = msg;
                if (showModal) {
                    const html = `
                        <ul class="result-list">
                            <li class="result-term-status"><span class="result-term-label">Status:</span> <span class="result-term-value">Voting In Progress</span></li>
                            <li class="result-term-votes"><span class="result-term-label">Votes Cast:</span> <span class="result-term-value">${votesCast}/${totalEligible}</span></li>
                        </ul>`;
                    openGroupVoteResultModal('Voting In Progress', msg, '', html);
                }
                return;
            }

            const winnerCandidate = db.getCandidates().find(item => item.id === topCandidateId && String(item.post || '') === post);
            const winnerStudent = winnerCandidate ? db.getStudents().find(item => item.id === winnerCandidate.studentId) : null;
            const passesAvg = topWeight >= avgEligibleWeight;
            const clearLead = topWeight > secondWeight;
            const passesMajorityWeight = topWeight >= majorityWeight;

            if (winnerCandidate && passesAvg && clearLead && passesMajorityWeight) {
                if (!isElectionOutcomeApplied(post, winnerCandidate.studentId)) {
                    queuePendingElectionResult({
                        post,
                        candidateId: topCandidateId,
                        source: 'teacher',
                        summary: `Teacher voting winner awaiting admin approval.`,
                        detail: `Weighted Votes ${topWeight.toFixed(1)} / Threshold ${avgEligibleWeight.toFixed(1)}`
                    });
                }
                const msg = `Winner pending admin approval: ${(winnerStudent ? (winnerStudent.base_name || winnerStudent.name) : 'Candidate')} | Weighted Votes: ${topWeight.toFixed(1)}.`;
                result.textContent = msg;
                if (showModal) {
                    const winnerName = winnerStudent ? escapeHtml(winnerStudent.base_name || winnerStudent.name) : 'Candidate';
                    const html = `
                        <ul class="result-list">
                            <li class="result-term-winner"><span class="result-term-label">Winner (Pending Approval):</span> <span class="result-term-value">${winnerName}</span></li>
                            <li class="result-term-votes"><span class="result-term-label">Weighted Votes:</span> <span class="result-term-value">${topWeight.toFixed(1)}</span></li>
                            <li class="result-term-threshold"><span class="result-term-label">Majority Threshold:</span> <span class="result-term-value">${majorityWeight.toFixed(1)}</span></li>
                        </ul>`;
                    openGroupVoteResultModal('Pending Admin Approval', msg, 'celebrate', html);
                }
            } else {
                const reason = !winnerCandidate ? 'No candidate votes' :
                    !passesAvg ? 'Top candidate did not meet average threshold' :
                    !clearLead ? 'No clear lead (tie)' :
                    !passesMajorityWeight ? 'Weighted majority not reached' : 'Election nullified';
                const msg = `Election nullified: ${reason}.`;
                result.textContent = msg;
                if (showModal) {
                    const html = `
                        <ul class="result-list">
                            <li class="result-term-status"><span class="result-term-label">Result:</span> <span class="result-term-value">Election Nullified</span></li>
                            <li class="result-term-reason"><span class="result-term-label">Reason:</span> <span class="result-term-value">${escapeHtml(reason)}</span></li>
                        </ul>`;
                    openGroupVoteResultModal('Election Nullified', msg, 'melancholy', html);
                }
            }
        }

        function getVotingPosts() {
            const leadershipPosts = db.getLeadership().map(p => p.post).filter(Boolean);
            const crPosts = DEFAULT_CR_GROUPS.map(group => `CR - Group ${group}`);
            return Array.from(new Set([...leadershipPosts, ...crPosts, ...DEFAULT_CR_COMBINED_POSTS]));
        }

        function getCRGroupsFromPost(post) {
            const text = String(post || '').trim();
            if (!/^CR\s*-\s*Group/i.test(text)) return [];
            const suffix = text.replace(/^CR\s*-\s*Group\s*/i, '').trim();
            if (!suffix) return [];
            const normalized = suffix.replace(/and/gi, '&').replace(/\s+/g, '');
            const matches = normalized.match(/[A-D]/gi) || [];
            return Array.from(new Set(matches.map(m => m.toUpperCase())));
        }

        function getCRGroupFromPost(post) {
            const groups = getCRGroupsFromPost(post);
            return groups.length ? groups[0] : '';
        }

        function updateCandidateStudentsByPost() {
            const post = getElementValue('candidatePost') || '';
            const groups = getCRGroupsFromPost(post);
            let students = db.getActiveStudents();
            if (groups.length) {
                students = students.filter(s => groups.includes(getStudentGroup(s)));
            }
            const candidateStudent = document.getElementById('candidateStudent');
            if (!candidateStudent) return;
            candidateStudent.innerHTML = '<option value="">Select Student...</option>' +
                students.map(s => `<option value="${s.id}">${escapeHtml(getStudentDisplayNamePlain(s))} (${escapeHtml(String(s.roll || ''))}) [*${s.stars || 0} V${s.veto_count || 0}]</option>`).join('');
        }

        function populateVotingSelects() {
            const posts = getVotingPosts();
            const candidatePost = document.getElementById('candidatePost');
            const votePost = document.getElementById('votePost');
            const voteParty = document.getElementById('voteParty');
            const groupVotePost = document.getElementById('groupVotePost');
            const groupVoteStudent = document.getElementById('groupVoteStudent');
            const groupVoteGroupFilter = document.getElementById('groupVoteGroupFilter');

            const postOptions = posts.map(p => `<option value="${p}">${p}</option>`).join('');
            const prevCandidatePost = candidatePost ? candidatePost.value : '';
            const prevVotePost = votePost ? votePost.value : '';
            const prevGroupVotePost = groupVotePost ? groupVotePost.value : '';

            if (candidatePost) {
                candidatePost.innerHTML = postOptions || '<option value="">No posts</option>';
                if (prevCandidatePost && Array.from(candidatePost.options).some(o => o.value === prevCandidatePost)) {
                    candidatePost.value = prevCandidatePost;
                }
            }
            if (votePost) {
                votePost.innerHTML = '<option value="">Select Post...</option>' + postOptions;
                if (prevVotePost && Array.from(votePost.options).some(o => o.value === prevVotePost)) {
                    votePost.value = prevVotePost;
                }
            }
            if (groupVotePost) {
                groupVotePost.innerHTML = '<option value="">Select Post...</option>' + postOptions;
                if (prevGroupVotePost && Array.from(groupVotePost.options).some(o => o.value === prevGroupVotePost)) {
                    groupVotePost.value = prevGroupVotePost;
                }
            }
            if (candidatePost) {
                updateCandidateStudentsByPost();
            }

            const parties = db.getParties();
            const prevVoteParty = voteParty ? voteParty.value : '';
            if (voteParty) {
                voteParty.innerHTML = '<option value="">Select Party...</option>' +
                    parties.map(p => `<option value="${p.id}">${formatPartyCode(p.code)}</option>`).join('');
                if (prevVoteParty && Array.from(voteParty.options).some(o => o.value === prevVoteParty)) {
                    voteParty.value = prevVoteParty;
                }
            }

            if (groupVoteGroupFilter && groupVoteGroupFilter.options.length === 0) {
                groupVoteGroupFilter.innerHTML = `
                    <option value=\"\">All Groups</option>
                    <option value=\"A\">Group A</option>
                    <option value=\"B\">Group B</option>
                    <option value=\"C\">Group C</option>
                    <option value=\"D\">Group D</option>`;
            }

            populateGroupVoteStudentSelect();
        }

        function populateGroupVoteStudentSelect() {
            const groupVoteStudent = document.getElementById('groupVoteStudent');
            if (!groupVoteStudent) return;
            const selectedStudent = groupVoteStudent.value || '';
            const groupFilterEl = document.getElementById('groupVoteGroupFilter');
            const groupFilter = groupFilterEl ? String(groupFilterEl.value || '').trim().toUpperCase() : '';
            let students = [];
            try {
                const currentMonth = getCurrentMonthKey();
                const monthActive = filterStudentsByStatus(db.getStudents(), 'active', currentMonth);
                students = monthActive.length ? monthActive : db.getStudents().filter(student => student.active !== false);
            } catch (err) {
                students = (db.getStudents() || []).filter(student => student.active !== false);
            }
            if (groupFilter) {
                students = students.filter(student => getStudentGroup(student) === groupFilter);
            }
            students = sortStudents(students);
            groupVoteStudent.innerHTML = '<option value="">Select Student...</option>' +
                students.map(student => `<option value="${student.id}">${escapeHtml(getStudentDisplayNamePlain(student))} (${escapeHtml(String(student.roll || ''))})</option>`).join('');
            if (selectedStudent && Array.from(groupVoteStudent.options).some(option => option.value === selectedStudent)) {
                groupVoteStudent.value = selectedStudent;
            }
        }

        function getStudentPartyLabels(studentId) {
            const labels = [];
            const sid = parseInt(studentId, 10);
            (db.getParties() || []).forEach(party => {
                const code = normalizePartyCode(party.code) || String(party.code || '').trim().toUpperCase();
                const member = (party.members || []).find(item => parseInt(item.studentId, 10) === sid);
                if (!member) return;
                labels.push(code);
            });
            return Array.from(new Set(labels));
        }

        function getGroupVoteSelectedStudent() {
            const studentId = parseInt(getElementValue('groupVoteStudent'), 10);
            if (!studentId) return null;
            return db.getActiveStudents().find(student => parseInt(student.id, 10) === studentId) || null;
        }

        function getGroupVoteSelectedPost() {
            return String(getElementValue('groupVotePost') || '').trim();
        }

        function samePostKey(a, b) {
            return String(a || '').trim().toLowerCase() === String(b || '').trim().toLowerCase();
        }

        function getCandidatesForPost(post) {
            return db.getCandidates().filter(candidate => samePostKey(candidate.post, post));
        }

        function getCurrentRoundStartStamp(post) {
            const candidates = getCandidatesForPost(post);
            if (!candidates.length) return 0;
            let minStamp = Number.MAX_SAFE_INTEGER;
            candidates.forEach(candidate => {
                const stamp = parseSyncStamp(candidate.created_on || candidate.created_at || candidate.updated_at || '');
                if (stamp > 0 && stamp < minStamp) minStamp = stamp;
            });
            return minStamp === Number.MAX_SAFE_INTEGER ? 0 : minStamp;
        }

        function getRoundScopedIndividualVotes(post) {
            const roundStart = getCurrentRoundStartStamp(post);
            const candidateIds = new Set(getCandidatesForPost(post).map(candidate => parseInt(candidate.id, 10)));
            return db.getIndividualVotes().filter(vote => {
                if (!samePostKey(vote.post, post)) return false;
                const stamp = parseSyncStamp(vote.timestamp || vote.updated_at || vote.created_at || '');
                if (roundStart > 0 && stamp > 0 && stamp < roundStart) return false;
                const voteType = String(vote.voteType || 'candidate').toLowerCase();
                if (voteType === 'candidate') {
                    return candidateIds.has(parseInt(vote.candidateId, 10));
                }
                return voteType === 'abstain' || voteType === 'nota';
            });
        }

        function getEligibleIndividualVoters(post) {
            const groups = getCRGroupsFromPost(post);
            let students = sortStudents(db.getActiveStudents());
            if (groups.length) {
                students = students.filter(student => groups.includes(getStudentGroup(student)));
            }
            return students;
        }

        function isStudentEligibleForPost(student, post) {
            if (!student || !post) return false;
            const groups = getCRGroupsFromPost(post);
            if (!groups.length) return true;
            return groups.includes(getStudentGroup(student));
        }

        function hasIndividualVoteForPost(studentId, post) {
            if (!studentId || !post) return false;
            return getRoundScopedIndividualVotes(post).some(vote => String(vote.voterStudentId) === String(studentId));
        }

        function updateGroupVoteStudentDetails() {
            const student = getGroupVoteSelectedStudent();
            const classEl = document.getElementById('groupVoteStudentClass');
            const groupEl = document.getElementById('groupVoteStudentGroup');
            const partyEl = document.getElementById('groupVoteStudentParty');
            if (!classEl || !groupEl || !partyEl) return;
            if (!student) {
                classEl.textContent = '-';
                groupEl.textContent = '-';
                partyEl.textContent = '-';
                return;
            }
            const parties = getStudentPartyLabels(student.id);
            classEl.textContent = String(student.class || '-');
            groupEl.textContent = getStudentGroup(student) || '-';
            partyEl.textContent = parties.length ? parties.join(', ') : 'Independent';
            groupVoteSession.studentId = student.id;
        }

        function loadCandidates() {
            const candidates = db.getCandidates();
            const students = db.getStudents();
            const studentMap = new Map(students.map(s => [parseInt(s.id, 10), s]));
            const tbody = document.getElementById('candidateBody');

            tbody.innerHTML = candidates.map(candidate => {
                const student = studentMap.get(parseInt(candidate.studentId, 10));
                if (!student) return '';
                return `
                    <tr>
                        <td>${candidate.post}</td>
                        <td>${student ? renderStudentName(student) : 'Unknown'}</td>
                        <td>${student ? formatRollDisplay(student.roll) : ''}</td>
                        <td>${student ? student.class : '-'}</td>
                        <td>
                            <button class="secondary" onclick="deleteCandidate(${candidate.id})" style="font-size: 12px;">Remove</button>
                        </td>
                    </tr>
                `;
            }).filter(Boolean).join('');

            if (!tbody.innerHTML) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center" style="padding: 30px;">No candidates added yet</td></tr>`;
            }
        }

        function saveCandidate() {
            const postSelect = document.getElementById('candidatePost');
            const post = postSelect ? postSelect.value : '';
            const studentId = parseInt(document.getElementById('candidateStudent').value, 10);
            if (!post || !studentId) {
                showAlert('Select post and student', 'danger');
                return;
            }
            const crGroups = getCRGroupsFromPost(post);
            if (crGroups.length) {
                const student = db.getActiveStudents().find(s => s.id === studentId);
                if (!student || !crGroups.includes(getStudentGroup(student))) {
                    showAlert(`For ${post}, candidate must belong to Group ${crGroups.join(' or ')}`, 'danger');
                    return;
                }
            }

            const existing = db.getCandidates().find(c => c.post === post && c.studentId === studentId);
            if (existing) {
                showAlert('Candidate already exists for this post', 'danger');
                return;
            }

            const savedCandidate = db.addCandidate({ post, studentId, created_on: new Date().toISOString() });
            if (!savedCandidate) {
                showAlert('Candidate not saved. This login may be read-only or sync blocked.', 'warning');
                return;
            }
            showAlert('Candidate added', 'success');
            clearCandidateForm();
            loadCandidates();
            loadVotingCandidates();
            loadGroupVotingCandidates();
            if (postSelect && post && Array.from(postSelect.options).some(o => o.value === post)) {
                postSelect.value = post;
            }
        }

        function deleteCandidate(candidateId) {
            if (confirm('Remove this candidate?')) {
                db.deleteCandidate(candidateId);
                loadCandidates();
                loadVotingCandidates();
                loadGroupVotingCandidates();
                showAlert('Candidate removed', 'success');
            }
        }

        function clearCandidateForm() {
            const postSelect = document.getElementById('candidatePost');
            const currentPost = postSelect ? postSelect.value : '';
            const studentSelect = document.getElementById('candidateStudent');
            if (studentSelect) studentSelect.value = '';
            updateCandidateStudentsByPost();
            if (postSelect && currentPost && Array.from(postSelect.options).some(o => o.value === currentPost)) {
                postSelect.value = currentPost;
            }
        }

        let autoVoteVerifyTimer = null;
        function autoVerifyPartyPresident() {
            if (autoVoteVerifyTimer) clearTimeout(autoVoteVerifyTimer);
            autoVoteVerifyTimer = setTimeout(() => {
                const post = getElementValue('votePost');
                const partyId = getElementValue('voteParty');
                const rollInput = document.getElementById('voteRoll');
                if (rollInput) {
                    rollInput.value = normalizeRoll(rollInput.value);
                }
                if (!post || !partyId || !rollInput || !rollInput.value.trim()) {
                    return;
                }
                verifyPartyPresident();
                autoVoteVerifyTimer = null;
            }, 120);
        }

        function verifyPartyPresident() {
            const post = document.getElementById('votePost').value;
            const partyId = parseInt(document.getElementById('voteParty').value, 10);
            const rollInput = document.getElementById('voteRoll').value.trim();
            const status = document.getElementById('voteStatus');

            if (!post || !partyId || !rollInput) {
                status.textContent = 'Please select post, party, and enter PP roll number.';
                status.classList.remove('flash');
                return;
            }

            const parties = db.getParties();
            const party = parties.find(p => p.id === partyId);
            const students = db.getStudents();
            const studentMap = new Map(students.map(s => [s.id, s]));
            const pp = party ? getPartyPresident(party, studentMap) : null;

            if (!pp || !pp.student) {
                status.textContent = 'No Party President assigned for this party.';
                status.classList.remove('flash');
                return;
            }

            if (pp.student.roll.toLowerCase() !== rollInput.toLowerCase()) {
                status.textContent = 'Incorrect Roll Number for selected party.';
                status.classList.add('flash');
                return;
            }

            const existingVote = db.getVotes().find(v => v.post === post && v.partyId === partyId);
            if (existingVote) {
                status.textContent = 'This party has already voted for the selected post.';
                status.classList.add('flash');
                return;
            }

            voteSession.verified = true;
            voteSession.partyId = partyId;
            voteSession.post = post;
            status.textContent = `Verified ${(pp.student.base_name || pp.student.name)} (${pp.student.roll}). You can vote now.`;
            status.classList.remove('flash');
            loadVotingCandidates();
        }

        function resetVoteSession() {
            voteSession.verified = false;
            voteSession.partyId = null;
            voteSession.post = null;
            document.getElementById('voteRoll').value = '';
            const status = document.getElementById('voteStatus');
            status.textContent = '';
            status.classList.remove('flash');
            loadVotingCandidates();
        }

        function loadVotingCandidates() {
            const post = document.getElementById('votePost').value;
            if (voteSession.post && voteSession.post !== post) {
                resetVoteSession();
            }
            const candidates = db.getCandidates().filter(c => c.post === post);
            const students = db.getActiveStudents();
            const studentMap = new Map(students.map(s => [s.id, s]));
            const votes = db.getVotes().filter(v => v.post === post);
            const voteCounts = votes.reduce((acc, v) => {
                acc[v.candidateId] = (acc[v.candidateId] || 0) + 1;
                return acc;
            }, {});

            const tbody = document.getElementById('votingBody');
            if (!post) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center" style="padding: 30px;">Select a post to vote</td></tr>`;
                document.getElementById('voteResult').textContent = '';
                return;
            }

            tbody.innerHTML = candidates.map(candidate => {
                const student = studentMap.get(candidate.studentId);
                if (!student) return '';
                const count = voteCounts[candidate.id] || 0;
                const canVote = voteSession.verified && voteSession.post === post && voteSession.partyId;
                const buttonLabel = canVote ? 'Vote' : 'Locked';
                const buttonDisabled = canVote ? '' : 'disabled';
                return `
                    <tr>
                        <td>${student ? renderStudentName(student) : 'Unknown'}</td>
                        <td>${student ? formatRollDisplay(student.roll) : ''}</td>
                        <td>${student ? student.class : '-'}</td>
                        <td>${count}</td>
                        <td>
                            <button class="secondary" onclick="castVote(${candidate.id})" style="font-size: 12px;" ${buttonDisabled}>${buttonLabel}</button>
                        </td>
                    </tr>
                `;
            }).filter(Boolean).join('');

            if (!tbody.innerHTML) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center" style="padding: 30px;">No candidates for this post</td></tr>`;
            }

            renderVoteResults(post);
        }

        function loadGroupVotingCandidates() {
            const post = getGroupVoteSelectedPost();
            const selectedStudent = getGroupVoteSelectedStudent();
            const tbody = document.getElementById('groupVotingBody');
            const statusEl = document.getElementById('groupVoteStatus');
            const resultEl = document.getElementById('groupVoteResult');
            if (!tbody || !statusEl || !resultEl) return;
            groupVoteSession.post = post || null;
            groupVoteSession.studentId = selectedStudent ? selectedStudent.id : null;

            if (!post) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center" style="padding: 30px;">Select a post to load candidates</td></tr>`;
                statusEl.textContent = 'Select voter and post to start student voting.';
                resultEl.textContent = '';
                return;
            }

            const candidates = getCandidatesForPost(post);
            const students = db.getStudents();
            const studentMap = new Map(students.map(student => [parseInt(student.id, 10), student]));
            const votes = getRoundScopedIndividualVotes(post);
            const voteCounts = votes.reduce((acc, vote) => {
                if (String(vote.voteType || 'candidate') !== 'candidate') return acc;
                acc[vote.candidateId] = (acc[vote.candidateId] || 0) + 1;
                return acc;
            }, {});

            const studentValid = !!selectedStudent;
            const eligible = isStudentEligibleForPost(selectedStudent, post);
            const alreadyVoted = studentValid ? hasIndividualVoteForPost(selectedStudent.id, post) : false;
            const groups = getCRGroupsFromPost(post);

            if (!studentValid) {
                statusEl.textContent = 'Select a student voter to continue.';
                statusEl.classList.remove('flash');
            } else if (!eligible) {
                statusEl.textContent = groups.length
                    ? `Selected voter is not eligible. ${post} allows only Group ${groups.join(' & ')} students.`
                    : 'Selected voter is not eligible for this post.';
                statusEl.classList.add('flash');
            } else if (alreadyVoted) {
                statusEl.textContent = `${getStudentDisplayNamePlain(selectedStudent)} has already voted for ${post}.`;
                statusEl.classList.remove('flash');
            } else {
                statusEl.textContent = `${getStudentDisplayNamePlain(selectedStudent)} is eligible to vote for ${post}.`;
                statusEl.classList.remove('flash');
            }

            tbody.innerHTML = candidates.map(candidate => {
                const student = studentMap.get(parseInt(candidate.studentId, 10));
                if (!student) return '';
                const count = voteCounts[candidate.id] || 0;
                const canOpenBooth = studentValid && eligible && !alreadyVoted;
                return `
                    <tr>
                        <td>${renderStudentName(student)}</td>
                        <td>${formatRollDisplay(student.roll)}</td>
                        <td>${student.class || '-'}</td>
                        <td>${count}</td>
                        <td>
                            <button class="secondary" style="font-size: 12px;" onclick="openGroupVoteDialog()" ${canOpenBooth ? '' : 'disabled'}>Cast Vote</button>
                        </td>
                    </tr>
                `;
            }).filter(Boolean).join('');

            if (!tbody.innerHTML) {
                tbody.innerHTML = `<tr><td colspan="5" class="text-center" style="padding: 30px;">No candidates for this post</td></tr>`;
            }

            renderGroupVoteResults(post);
        }

        function openGroupVoteDialog() {
            const post = getGroupVoteSelectedPost();
            const voter = getGroupVoteSelectedStudent();
            if (!post || !voter) {
                showAlert('Select student and post before opening voting booth.', 'warning');
                return;
            }
            if (hasIndividualVoteForPost(voter.id, post)) {
                showAlert('This student has already voted for this post.', 'warning');
                return;
            }

            const candidates = getCandidatesForPost(post);
            if (!candidates.length) {
                showAlert('No candidates found for selected post.', 'warning');
                return;
            }
            const studentMap = new Map(db.getStudents().map(student => [parseInt(student.id, 10), student]));
            const cardsHtml = candidates.map(candidate => {
                const candidateStudent = studentMap.get(parseInt(candidate.studentId, 10));
                if (!candidateStudent) return '';
                return `
                    <div class="group-vote-card">
                        <h4>${escapeHtml(getStudentDisplayNamePlain(candidateStudent))}</h4>
                        <div class="meta">
                            ${escapeHtml(formatRollDisplay(candidateStudent.roll))} | Class ${escapeHtml(String(candidateStudent.class || '-'))} | Group ${escapeHtml(getStudentGroup(candidateStudent) || '-')}
                        </div>
                        <button onclick="submitGroupVoteChoice('candidate', ${candidate.id})">Vote</button>
                    </div>
                `;
            }).filter(Boolean).join('');

            if (!cardsHtml) {
                showAlert('Candidates unavailable for the selected post.', 'warning');
                return;
            }

            groupVoteSession.studentId = voter.id;
            groupVoteSession.post = post;
            const dialog = document.getElementById('groupVoteDialog');
            const titleEl = document.getElementById('groupVoteDialogTitle');
            const metaEl = document.getElementById('groupVoteDialogMeta');
            const cardsEl = document.getElementById('groupVoteCandidateCards');
            if (!dialog || !titleEl || !metaEl || !cardsEl) return;
            titleEl.textContent = 'Cast Your Vote Now';
            metaEl.textContent = `Voter: ${getStudentDisplayNamePlain(voter)} (${voter.roll}) | Post: ${post}`;
            cardsEl.innerHTML = cardsHtml;
            dialog.classList.remove('hidden');
        }

        function closeGroupVoteDialog() {
            const dialog = document.getElementById('groupVoteDialog');
            if (!dialog) return;
            dialog.classList.add('hidden');
        }

        function openGroupVoteResultModal(title, message, moodClass = '', htmlMessage = '') {
            const modal = document.getElementById('groupVoteResultModal');
            const titleEl = document.getElementById('groupVoteResultTitle');
            const msgEl = document.getElementById('groupVoteResultMessage');
            const bannerEl = document.getElementById('groupVoteResultBanner');
            const confetti = document.getElementById('groupVoteResultConfetti');
            const rain = document.getElementById('groupVoteResultRain');
            if (!modal || !titleEl || !msgEl) return;
            titleEl.textContent = title || 'Voting Results';
            if (bannerEl) bannerEl.textContent = title || 'Voting Results';
            if (htmlMessage) {
                msgEl.innerHTML = htmlMessage;
            } else {
                msgEl.textContent = message || '';
            }
            modal.classList.remove('hidden');
            const content = modal.querySelector('.result-modal-content') || modal;
            content.classList.remove('celebrate', 'melancholy');
            if (moodClass) content.classList.add(moodClass);
            if (confetti) confetti.style.display = moodClass === 'celebrate' ? 'block' : 'none';
            if (rain) rain.style.display = moodClass === 'melancholy' ? 'block' : 'none';
        }

        function closeGroupVoteResultModal() {
            const modal = document.getElementById('groupVoteResultModal');
            if (!modal) return;
            modal.classList.add('hidden');
            const content = modal.querySelector('.result-modal-content') || modal;
            content.classList.remove('celebrate', 'melancholy');
            const confetti = document.getElementById('groupVoteResultConfetti');
            const rain = document.getElementById('groupVoteResultRain');
            if (confetti) confetti.style.display = 'none';
            if (rain) rain.style.display = 'none';
        }

        function submitGroupVoteChoice(voteType, candidateId = null) {
            const post = groupVoteSession.post || getGroupVoteSelectedPost();
            const voterId = groupVoteSession.studentId || parseInt(getElementValue('groupVoteStudent'), 10);
            if (!post || !voterId) {
                showAlert('Invalid vote context. Select voter and post again.', 'danger');
                return;
            }
            const voter = db.getActiveStudents().find(student => student.id === voterId);
            if (!voter) {
                showAlert('Voter not found.', 'danger');
                return;
            }
            if (!isStudentEligibleForPost(voter, post)) {
                showAlert('Selected voter is not eligible for this post.', 'danger');
                return;
            }
            if (hasIndividualVoteForPost(voterId, post)) {
                showAlert('Vote already recorded for this student and post.', 'warning');
                closeGroupVoteDialog();
                loadGroupVotingCandidates();
                return;
            }

            const normalizedType = String(voteType || '').toLowerCase();
            let finalType = normalizedType;
            let finalCandidateId = candidateId;
            if (normalizedType === 'candidate') {
                const valid = getCandidatesForPost(post).some(candidate => parseInt(candidate.id, 10) === parseInt(candidateId, 10));
                if (!valid) {
                    showAlert('Invalid candidate selected.', 'danger');
                    return;
                }
            } else if (normalizedType === 'abstain' || normalizedType === 'nota') {
                finalCandidateId = null;
            } else {
                finalType = 'abstain';
                finalCandidateId = null;
            }

            db.recordIndividualVote({
                post,
                voterStudentId: voterId,
                candidateId: finalCandidateId,
                voteType: finalType,
                timestamp: new Date().toISOString()
            });

            showAlert('Vote recorded successfully.', 'success');
            closeGroupVoteDialog();
            loadGroupVotingCandidates();
        }

        function isElectionOutcomeApplied(post, winnerStudentId) {
            const data = db.getData();
            const group = getCRGroupFromPost(post);
            if (group) {
                const existing = (data.group_crs || []).find(item => String(item.group || '').toUpperCase() === group);
                if (!existing) return false;
                return parseInt(existing.studentId, 10) === parseInt(winnerStudentId, 10) && normalizePostHolderStatus(existing.status) === 'active';
            }
            const leadershipPost = (data.leadership || []).find(item =>
                String(item.post || '').trim().toLowerCase() === String(post || '').trim().toLowerCase()
            );
            if (!leadershipPost) return false;
            const winner = db.getStudents().find(student => student.id === winnerStudentId);
            if (!winner) return false;
            return normalizeRoll(leadershipPost.roll || '') === normalizeRoll(winner.roll || '');
        }

        function renderGroupVoteResults(post, forceConclude = false, showModal = false) {
            const result = document.getElementById('groupVoteResult');
            if (!result) return;
            if (!post) {
                result.textContent = '';
                result.classList.remove('flash');
                return;
            }
            const eligibleVoters = getEligibleIndividualVoters(post);
            const totalEligible = eligibleVoters.length;
            const votes = getRoundScopedIndividualVotes(post);
            const votesCast = new Set(votes.map(vote => String(vote.voterStudentId))).size;
            const abstainWeight = votes
                .filter(v => String(v.voteType || '') === 'abstain')
                .reduce((sum, v) => sum + getStudentVotePower(db.getStudents().find(s => s.id === v.voterStudentId)), 0);
            const notaWeight = votes
                .filter(v => String(v.voteType || '') === 'nota')
                .reduce((sum, v) => sum + getStudentVotePower(db.getStudents().find(s => s.id === v.voterStudentId)), 0);

            if (totalEligible === 0) {
                result.textContent = 'No eligible student voters found for selected post.';
                result.classList.add('flash');
                return;
            }

            const voterMap = new Map(db.getStudents().map(s => [s.id, s]));
            const totalEligibleWeight = eligibleVoters.reduce((sum, voter) => sum + getStudentVotePower(voter), 0);
            const avgEligibleWeight = totalEligible > 0 ? totalEligibleWeight / totalEligible : 0;

            const weightByCandidate = votes.reduce((acc, vote) => {
                const voteType = String(vote.voteType || '');
                if (voteType !== 'candidate') return acc;
                const candidateId = vote.candidateId;
                if (!candidateId) return acc;
                const voter = voterMap.get(vote.voterStudentId);
                const weight = getStudentVotePower(voter);
                acc[candidateId] = (acc[candidateId] || 0) + weight;
                return acc;
            }, {});

            const topEntry = Object.entries(weightByCandidate).sort((a, b) => b[1] - a[1])[0] || [null, 0];
            const topCandidateId = topEntry[0] ? parseInt(topEntry[0], 10) : null;
            const topWeight = topEntry[1] || 0;
            const secondWeight = Object.entries(weightByCandidate).sort((a, b) => b[1] - a[1])[1]?.[1] || 0;
            const majorityWeight = totalEligibleWeight / 2;
            const concluded = forceConclude || votesCast >= totalEligible;

            const abstainCount = votes.filter(vote => String(vote.voteType || '') === 'abstain').length;
            const notaCount = votes.filter(vote => String(vote.voteType || '') === 'nota').length;

            result.classList.remove('flash', 'celebrate', 'melancholy');
            if (!concluded) {
                const msg = `Waiting for votes: ${votesCast}/${totalEligible}. Abstain weight: ${abstainWeight}, NOTA weight: ${notaWeight}.`;
                result.textContent = msg;
                if (showModal) {
                    const html = `
                        <ul class="result-list">
                            <li class="result-term-status"><span class="result-term-label">Status:</span> <span class="result-term-value">Voting In Progress</span></li>
                            <li class="result-term-votes"><span class="result-term-label">Votes Cast:</span> <span class="result-term-value">${votesCast}/${totalEligible}</span></li>
                            <li class="result-term-abstain"><span class="result-term-label">Abstain Weight:</span> <span class="result-term-value">${abstainWeight.toFixed(1)}</span></li>
                            <li class="result-term-nota"><span class="result-term-label">NOTA Weight:</span> <span class="result-term-value">${notaWeight.toFixed(1)}</span></li>
                        </ul>`;
                    openGroupVoteResultModal('Voting In Progress', msg, '', html);
                }
                return;
            }

            const winnerCandidate = getCandidatesForPost(post).find(item => parseInt(item.id, 10) === parseInt(topCandidateId, 10));
            const winnerStudent = winnerCandidate ? db.getStudents().find(item => item.id === winnerCandidate.studentId) : null;
            const passesAvg = topWeight >= avgEligibleWeight;
            const clearLead = topWeight > secondWeight;
            const passesMajorityWeight = topWeight >= majorityWeight;

            if (winnerCandidate && passesAvg && clearLead && passesMajorityWeight) {
                if (!isElectionOutcomeApplied(post, winnerCandidate.studentId)) {
                    const existingPending = getPendingResult(post, 'student');
                    if (!existingPending || existingPending.candidateId !== topCandidateId) {
                        queuePendingElectionResult({
                            post,
                            candidateId: topCandidateId,
                            source: 'student',
                            summary: 'Student voting winner awaiting admin approval.',
                            detail: `Weighted ${topWeight.toFixed(1)} / Avg ${avgEligibleWeight.toFixed(1)} / Majority ${majorityWeight.toFixed(1)}`
                        });
                    }
                }
                const msg = `Winner pending admin approval: ${(winnerStudent ? (winnerStudent.base_name || winnerStudent.name) : 'Candidate')} | Weighted Votes: ${topWeight.toFixed(1)} | Avg Threshold: ${avgEligibleWeight.toFixed(1)} | Abstain: ${abstainWeight.toFixed(1)}, NOTA: ${notaWeight.toFixed(1)}.`;
                result.textContent = msg;
                result.classList.add('celebrate');
                if (showModal) {
                    const winnerName = winnerStudent ? escapeHtml(winnerStudent.base_name || winnerStudent.name) : 'Candidate';
                    const html = `
                        <ul class="result-list">
                            <li class="result-term-winner"><span class="result-term-label">Winner (Pending Approval):</span> <span class="result-term-value">${winnerName}</span></li>
                            <li class="result-term-votes"><span class="result-term-label">Weighted Votes:</span> <span class="result-term-value">${topWeight.toFixed(1)}</span></li>
                            <li class="result-term-threshold"><span class="result-term-label">Avg Threshold:</span> <span class="result-term-value">${avgEligibleWeight.toFixed(1)}</span></li>
                            <li class="result-term-threshold"><span class="result-term-label">Majority Threshold:</span> <span class="result-term-value">${majorityWeight.toFixed(1)}</span></li>
                            <li class="result-term-abstain"><span class="result-term-label">Abstain Weight:</span> <span class="result-term-value">${abstainWeight.toFixed(1)}</span></li>
                            <li class="result-term-nota"><span class="result-term-label">NOTA Weight:</span> <span class="result-term-value">${notaWeight.toFixed(1)}</span></li>
                        </ul>`;
                    openGroupVoteResultModal('Pending Admin Approval', msg, 'celebrate', html);
                }
            } else {
                const reason = !winnerCandidate ? 'No candidate votes' :
                    !passesAvg ? 'Top candidate did not meet average vote power threshold' :
                    !clearLead ? 'No clear lead (tie)' :
                    !passesMajorityWeight ? 'Weighted majority not reached' : 'Election nullified';
                const msg = `Election nullified: ${reason}. Top weight ${topWeight.toFixed(1)} / Avg ${avgEligibleWeight.toFixed(1)} / Majority ${majorityWeight.toFixed(1)}. Abstain: ${abstainWeight.toFixed(1)}, NOTA: ${notaWeight.toFixed(1)}.`;
                result.textContent = msg;
                result.classList.add('melancholy');
                if (showModal) {
                    const html = `
                        <ul class="result-list">
                            <li class="result-term-status"><span class="result-term-label">Result:</span> <span class="result-term-value">Election Nullified</span></li>
                            <li class="result-term-reason"><span class="result-term-label">Reason:</span> <span class="result-term-value">${escapeHtml(reason)}</span></li>
                            <li class="result-term-votes"><span class="result-term-label">Top Weight:</span> <span class="result-term-value">${topWeight.toFixed(1)}</span></li>
                            <li class="result-term-threshold"><span class="result-term-label">Avg Threshold:</span> <span class="result-term-value">${avgEligibleWeight.toFixed(1)}</span></li>
                            <li class="result-term-threshold"><span class="result-term-label">Majority Threshold:</span> <span class="result-term-value">${majorityWeight.toFixed(1)}</span></li>
                            <li class="result-term-abstain"><span class="result-term-label">Abstain Weight:</span> <span class="result-term-value">${abstainWeight.toFixed(1)}</span></li>
                            <li class="result-term-nota"><span class="result-term-label">NOTA Weight:</span> <span class="result-term-value">${notaWeight.toFixed(1)}</span></li>
                        </ul>`;
                    openGroupVoteResultModal('Election Nullified', msg, 'melancholy', html);
                }
            }
        }

        function castVote(candidateId) {
            if (!voteSession.verified || !voteSession.partyId || !voteSession.post) {
                showAlert('Verify Party President before voting', 'danger');
                return;
            }

            db.recordVote({
                post: voteSession.post,
                partyId: voteSession.partyId,
                candidateId,
                timestamp: new Date().toISOString()
            });

            showAlert('Vote recorded', 'success');
            resetVoteSession();
            loadVotingCandidates();
        }

        function renderVoteResults(post) {
            const result = document.getElementById('voteResult');
            const parties = db.getParties();
            const students = db.getActiveStudents();
            const studentMap = new Map(students.map(s => [s.id, s]));
            const eligibleParties = parties.filter(p => {
                const pp = getPartyPresident(p, studentMap);
                return pp && pp.student;
            });
            const totalEligible = eligibleParties.length;
            const votes = db.getVotes().filter(v => v.post === post);
            const votesCast = new Set(votes.map(v => v.partyId)).size;

            if (totalEligible === 0) {
                result.textContent = 'No Party Presidents available for voting.';
                result.classList.add('flash');
                return;
            }

            if (votesCast < totalEligible) {
                result.textContent = `Waiting for votes: ${votesCast}/${totalEligible} parties have voted.`;
                result.classList.remove('flash');
                return;
            }

            const countByCandidate = votes.reduce((acc, v) => {
                acc[v.candidateId] = (acc[v.candidateId] || 0) + 1;
                return acc;
            }, {});
            let topCandidateId = null;
            let topVotes = 0;
            Object.entries(countByCandidate).forEach(([candidateId, count]) => {
                if (count > topVotes) {
                    topVotes = count;
                    topCandidateId = parseInt(candidateId, 10);
                }
            });

            const majority = Math.floor(totalEligible / 2) + 1;
            if (topVotes >= majority) {
                const candidate = db.getCandidates().find(c => c.id === topCandidateId);
                const student = candidate ? studentMap.get(candidate.studentId) : null;
                if (candidate && !isElectionOutcomeApplied(post, candidate.studentId)) {
                    const existingPending = getPendingResult(post, 'party');
                    if (!existingPending || existingPending.candidateId !== topCandidateId) {
                        queuePendingElectionResult({
                            post,
                            candidateId: topCandidateId,
                            source: 'party',
                            summary: `Party voting winner awaiting admin approval.`,
                            detail: `${topVotes}/${totalEligible} votes`
                        });
                    }
                }
                result.textContent = `Winner pending admin approval: ${student ? getStudentDisplayNamePlain(student) : 'Candidate'} with ${topVotes}/${totalEligible} votes.`;
                result.classList.remove('flash');
            } else {
                result.textContent = `No majority reached. Top votes: ${topVotes}/${totalEligible}.`;
                result.classList.add('flash');
            }
        }

        function getAppealTargetOptions() {
            if (currentUserRole === 'admin') {
                return [];
            }
            if (currentUserRole === 'teacher') {
                return [{ value: 'admin', label: 'Admin' }];
            }
            return [
                { value: 'teacher', label: 'Teacher' },
                { value: 'admin', label: 'Admin' }
            ];
        }

        function renderAppealMessage(appeal) {
            if (appeal.type === 'score_adjustment') {
                const studentLabel = `${appeal.student_name || 'Student'} (${appeal.student_roll || '-'})`;
                return `
                    <strong>Teacher Star/VETO Request</strong><br>
                    ${escapeHtml(studentLabel)} | Date: ${escapeHtml(appeal.score_date || '-')}<br>
                    Requested: <strong>*${parseInt(appeal.requested_stars, 10) || 0}</strong>, <strong>V${parseInt(appeal.requested_vetos, 10) || 0}</strong>
                `;
            }
            if (appeal.type === 'profile_change') {
                const studentLabel = `${appeal.student_name || 'Student'} (${formatRollDisplay(appeal.student_roll || '-')})`;
                const requestedName = String(appeal.requested_name || '').trim();
                const profileChanges = safeProp(safeProp(appeal, 'changed_fields'), 'profile') || {};
                const requestedProfile = (appeal.requested_profile_data && typeof appeal.requested_profile_data === 'object') ? appeal.requested_profile_data : {};
                let keys = Object.keys(profileChanges || {});
                if (!keys.length) {
                    keys = Object.keys(requestedProfile || {});
                }
                const fieldsLabel = keys.length ? keys.join(', ') : '-';
                return `
                    <strong>Profile Change Request</strong><br>
                    ${escapeHtml(studentLabel)}<br>
                    Requested Name: ${escapeHtml(requestedName || '-')}<br>
                    Fields: ${escapeHtml(fieldsLabel)}
                `;
            }
            if (appeal.type === 'post_holder_action') {
                const action = normalizePostHolderStatus(appeal.requested_status || '') === 'suspended' ? 'Suspend' : 'Resume';
                const target = String(appeal.target_label || appeal.message || '').trim();
                const by = String(appeal.created_by || '').trim();
                return `
                    <strong>Post Holder Action Request</strong><br>
                    Action: ${escapeHtml(action)}<br>
                    Target: ${escapeHtml(target || '-')}<br>
                    Requested by: ${escapeHtml(by || '-')}
                `;
            }
            return `<strong>${escapeHtml(appeal.subject || 'Appeal')}</strong><br>${escapeHtml(appeal.message || '')}`;
        }

        function renderScoreAdjustmentActions(appeal) {
            const reqStars = parseInt(appeal.requested_stars, 10) || 0;
            const reqVetos = parseInt(appeal.requested_vetos, 10) || 0;
            return `
                <div style="display:grid; gap:6px; min-width:220px;">
                    <div style="display:flex; gap:6px; align-items:center;">
                        <label style="font-size:11px;">*</label>
                        <input type="number" id="adjStars_${appeal.id}" value="${reqStars}" style="width:74px; padding:6px;">
                        <label style="font-size:11px;">V</label>
                        <input type="number" id="adjVetos_${appeal.id}" value="${reqVetos}" style="width:74px; padding:6px;">
                    </div>
                    <div style="display:flex; gap:6px; flex-wrap:wrap;">
                        <button onclick="adminDecisionScoreAdjustment(${appeal.id}, 'approved')" style="font-size: 12px;">Approve</button>
                        <button class="danger" onclick="adminDecisionScoreAdjustment(${appeal.id}, 'denied')" style="font-size: 12px;">Deny</button>
                    </div>
                </div>
            `;
        }

        function applyApprovedScoreAdjustment(appeal, approvedStars, approvedVetos) {
            const data = db.getData();
            const studentId = parseInt(appeal.student_id, 10);
            const date = appeal.score_date;
            if (!studentId || !date) return false;

            const student = (data.students || []).find(s => s.id === studentId);
            if (!student) return false;

            const safeStars = Number.isFinite(approvedStars) ? approvedStars : (parseInt(appeal.requested_stars, 10) || 0);
            const safeVetos = Number.isFinite(approvedVetos) ? approvedVetos : (parseInt(appeal.requested_vetos, 10) || 0);
            const month = appeal.score_month || (date ? String(date).substring(0, 7) : getCurrentMonthKey());
            let score = (data.scores || []).find(s => s.studentId === studentId && s.date === date);
            let oldStars = 0;
            let oldVetos = 0;

            if (score) {
                oldStars = parseInt(score.stars, 10) || 0;
                oldVetos = parseInt(score.vetos, 10) || 0;
                score.stars = safeStars;
                score.vetos = safeVetos;
                score.month = score.month || month;
                score.recordedBy = score.recordedBy || 'teacher';
            } else {
                score = {
                    id: Date.now(),
                    studentId,
                    date,
                    month,
                    points: parseInt(appeal.requested_points, 10) || 0,
                    stars: safeStars,
                    vetos: safeVetos,
                    notes: 'Admin-approved star/veto request',
                    recordedBy: 'admin'
                };
                data.scores.push(score);
            }

            normalizeStudentMeta(student);
            student.stars = Math.max(0, (parseInt(student.stars, 10) || 0) + (safeStars - oldStars));
            student.veto_count = Math.max(0, (parseInt(student.veto_count, 10) || 0) + (safeVetos - oldVetos));
            db.saveData(data);
            return true;
        }

        function adminDecisionScoreAdjustment(appealId, decision) {
            const appeal = db.getAppeals().find(item => item.id === appealId);
            if (!appeal || appeal.type !== 'score_adjustment') return;
            if (decision === 'denied') {
                db.updateAppeal(appealId, {
                    status: 'denied',
                    admin_decision_by: currentLoginId || 'Admin',
                    admin_decision_at: new Date().toISOString()
                });
                loadAppealsTab();
                showAlert('Teacher star/veto request denied', 'danger');
                return;
            }

            const starsInput = parseInt(getElementValue(`adjStars_${appealId}`), 10);
            const vetosInput = parseInt(getElementValue(`adjVetos_${appealId}`), 10);
            const approvedStars = Number.isNaN(starsInput) ? (parseInt(appeal.requested_stars, 10) || 0) : starsInput;
            const approvedVetos = Number.isNaN(vetosInput) ? (parseInt(appeal.requested_vetos, 10) || 0) : vetosInput;

            const applied = applyApprovedScoreAdjustment(appeal, approvedStars, approvedVetos);
            if (!applied) {
                showAlert('Unable to apply approved values for this request', 'danger');
                return;
            }

            db.updateAppeal(appealId, {
                status: 'approved',
                approved_stars: approvedStars,
                approved_vetos: approvedVetos,
                admin_decision_by: currentLoginId || 'Admin',
                admin_decision_at: new Date().toISOString()
            });
            loadAppealsTab();
            loadScoreboard();
            loadStudents();
            initScoreForm();
            showAlert('Teacher star/veto request approved and applied', 'success');
        }

        function loadAppealsTab() {
            const targetSelect = document.getElementById('appealTargetRole');
            if (targetSelect) {
                const opts = getAppealTargetOptions();
                targetSelect.innerHTML = opts.map(opt => `<option value="${opt.value}">${opt.label}</option>`).join('');
            }
            const submitCard = document.getElementById('appealSubmitCard');
            const adminNotice = document.getElementById('appealAdminNotice');
            if (submitCard) {
                submitCard.classList.toggle('hidden', currentUserRole === 'admin');
            }
            if (adminNotice) {
                adminNotice.classList.toggle('hidden', currentUserRole !== 'admin');
            }

            const appeals = db.getAppeals();
            const tbody = document.getElementById('appealsBody');
            if (!tbody) return;

            let visible = appeals;
            if (currentUserRole === 'teacher') {
                visible = appeals.filter(a => a.target_role === 'teacher' || a.forwarded_to === 'teacher' || a.created_by === currentLoginId);
            } else if (currentUserRole === 'admin') {
                visible = appeals.filter(a => a.target_role === 'admin' || a.forwarded_to === 'admin' || a.created_by === currentLoginId);
            } else {
                visible = appeals.filter(a => a.created_by === currentLoginId);
            }
            visible = visible.sort((a, b) => Date.parse(b.updated_at || b.created_at || 0) - Date.parse(a.updated_at || a.created_at || 0));

            tbody.innerHTML = visible.map(appeal => {
                const fromLabel = `${appeal.from_role || 'user'}${appeal.created_by ? ` (${appeal.created_by})` : ''}`;
                const recommendation = appeal.recommendation || '-';
                const updated = formatDateLabel((appeal.updated_at || appeal.created_at || '').split('T')[0]) + ' ' + (((appeal.updated_at || appeal.created_at || '').split('T')[1] || '').slice(0, 8));
                return `
                    <tr>
                        <td>#${appeal.id}</td>
                        <td>${escapeHtml(fromLabel)}</td>
                        <td>${escapeHtml((appeal.forwarded_to || appeal.target_role || '').toUpperCase())}</td>
                        <td>${renderAppealMessage(appeal)}</td>
                        <td>${escapeHtml((appeal.status || '').replaceAll('_', ' '))}</td>
                        <td>${escapeHtml(recommendation)}</td>
                        <td>${renderAppealActions(appeal)}</td>
                        <td>${escapeHtml(updated)}</td>
                    </tr>
                `;
            }).join('');

            if (!visible.length) {
                tbody.innerHTML = `<tr><td colspan="8" class="text-center" style="padding: 30px;">No appeals found</td></tr>`;
            }
            updateAppealsTabNotification();
            autoAdjustTableFonts();
        }

        function renderAppealActions(appeal) {
            const buttons = [];
            if (
                currentUserRole === 'admin' &&
                appeal.type === 'score_adjustment' &&
                (appeal.status === 'pending_admin' || appeal.status === 'recommended')
            ) {
                return renderScoreAdjustmentActions(appeal);
            }
            if (currentUserRole === 'teacher' && appeal.target_role === 'teacher' && appeal.status === 'pending_teacher') {
                buttons.push(`<button class="secondary" onclick="teacherRecommendAppeal(${appeal.id}, true)" style="font-size: 12px;">Recommend</button>`);
                buttons.push(`<button class="secondary" onclick="teacherRecommendAppeal(${appeal.id}, false)" style="font-size: 12px;">Not Recommend</button>`);
            }
            if (currentUserRole === 'admin' && (appeal.target_role === 'admin' || appeal.forwarded_to === 'admin') && (appeal.status === 'pending_admin' || appeal.status === 'recommended')) {
                buttons.push(`<button onclick="adminDecisionAppeal(${appeal.id}, 'approved')" style="font-size: 12px;">Approve</button>`);
                buttons.push(`<button class="danger" onclick="adminDecisionAppeal(${appeal.id}, 'denied')" style="font-size: 12px;">Deny</button>`);
            }
            if (buttons.length === 0) return '<span style="color: var(--text-muted);">No action</span>';
            return buttons.join(' ');
        }

        function submitAppeal() {
            if (currentUserRole === 'admin') {
                showAlert('Admins cannot submit appeals', 'warning');
                return;
            }
            const target = getElementValue('appealTargetRole');
            const subject = getElementValue('appealSubject').trim() || 'Appeal Request';
            const message = getElementValue('appealMessage').trim();
            if (!message) {
                showAlert('Please write appeal message', 'danger');
                return;
            }

            const now = new Date().toISOString();
            const record = {
                subject,
                message,
                from_role: currentUserRole,
                created_by: currentLoginId || currentUserRole,
                target_role: target || 'teacher',
                forwarded_to: target || 'teacher',
                status: (target === 'admin' ? 'pending_admin' : 'pending_teacher'),
                recommendation: '',
                created_at: now,
                updated_at: now
            };
            db.addAppeal(record);
            clearAppealForm();
            loadAppealsTab();
            showAlert('Appeal submitted successfully', 'success');
        }

        function clearAppealForm() {
            const subject = document.getElementById('appealSubject');
            const message = document.getElementById('appealMessage');
            if (subject) subject.value = '';
            if (message) message.value = '';
        }

        function teacherRecommendAppeal(appealId, recommend) {
            const status = recommend ? 'recommended' : 'not_recommended';
            const forwardedTo = recommend ? 'admin' : 'teacher';
            db.updateAppeal(appealId, {
                recommendation: recommend ? 'Recommended' : 'Not Recommended',
                status,
                forwarded_to: forwardedTo,
                target_role: forwardedTo,
                teacher_reviewed_by: currentLoginId || 'Teacher',
                teacher_reviewed_at: new Date().toISOString()
            });
            loadAppealsTab();
            showAlert(`Appeal ${recommend ? 'recommended and forwarded' : 'marked not recommended'}`, recommend ? 'success' : 'warning');
        }

        function applyApprovedProfileChange(appeal) {
            if (!appeal || appeal.type !== 'profile_change') return false;
            const data = db.getData();
            const sid = parseInt(appeal.student_id, 10) || 0;
            const rollKey = normalizeRoll(appeal.student_roll || '');
            const student = (data.students || []).find(s => parseInt(s && s.id, 10) === sid) ||
                (rollKey ? (data.students || []).find(s => normalizeRoll(s && s.roll) === rollKey) : null);
            if (!student) return false;

            const requestedName = String(appeal.requested_name || '').trim();
            const requestedProfile = (appeal.requested_profile_data && typeof appeal.requested_profile_data === 'object')
                ? appeal.requested_profile_data
                : null;
            const hasName = !!requestedName;
            const hasProfile = !!requestedProfile;
            if (!hasName && !hasProfile) return false;

            if (hasName) {
                if (!isValidStudentName(requestedName)) return false;
                student.name = requestedName;
                student.base_name = requestedName;
                student.raw_name = requestedName;
            }

            if (hasProfile) {
                const allowedKeys = new Set([
                    'fatherName', 'motherName', 'dateOfBirth', 'bloodGroup', 'aadhar',
                    'phone', 'email', 'parentPhone', 'admissionDate', 'academicYear', 'address'
                ]);
                const existingProfile = (student.profile_data && typeof student.profile_data === 'object') ? student.profile_data : {};
                const nextProfile = { ...existingProfile };
                Object.keys(requestedProfile || {}).forEach(key => {
                    if (!allowedKeys.has(key)) return;
                    nextProfile[key] = requestedProfile[key];
                });
                student.profile_data = nextProfile;
            }

            // Keep month roster profiles display consistent with the approved student name.
            if (hasName && data.month_roster_profiles && typeof data.month_roster_profiles === 'object') {
                const studentRoll = normalizeRoll(student.roll || '');
                Object.keys(data.month_roster_profiles || {}).forEach(monthKey => {
                    const profiles = data.month_roster_profiles[monthKey];
                    if (!Array.isArray(profiles)) return;
                    profiles.forEach(profile => {
                        if (!profile || typeof profile !== 'object') return;
                        if (normalizeRoll(profile.roll || '') !== studentRoll) return;
                        profile.base_name = requestedName;
                        profile.name = requestedName;
                    });
                });
            }

            db.saveData(data);
            return true;
        }

        function adminDecisionAppeal(appealId, decision) {
            const appeal = db.getAppeals().find(item => item.id === appealId) || null;
            const now = new Date().toISOString();
            if (currentUserRole === 'admin' && appeal && decision === 'approved') {
                if (appeal.type === 'profile_change') {
                    const applied = applyApprovedProfileChange(appeal);
                    if (!applied) {
                        showAlert('Unable to apply profile change request (invalid or missing data).', 'danger');
                        return;
                    }
                } else if (appeal.type === 'post_holder_action') {
                    const applied = applyApprovedPostHolderAction(appeal);
                    if (!applied) {
                        showAlert('Unable to apply post holder action (missing/invalid target).', 'danger');
                        return;
                    }
                }
            }

            db.updateAppeal(appealId, {
                status: decision,
                admin_decision_by: currentLoginId || 'Admin',
                admin_decision_at: now,
                applied_at: (appeal && (appeal.type === 'profile_change' || appeal.type === 'post_holder_action') && decision === 'approved')
                    ? now
                    : (appeal && appeal.applied_at ? appeal.applied_at : '')
            });
            loadAppealsTab();
            if (appeal && appeal.type === 'profile_change' && decision === 'approved') {
                loadProfileTab();
                loadStudents();
                loadScoreboard();
            } else if (appeal && appeal.type === 'post_holder_action' && decision === 'approved') {
                loadOfficeHolders();
            }
            showAlert(`Appeal ${decision}`, decision === 'approved' ? 'success' : 'danger');
        }

        function updateAppealsTabNotification() {
            const button = document.getElementById('appealsTabButton');
            if (!button) return;
            const appeals = db.getAppeals();
            let pending = 0;
            if (currentUserRole === 'teacher') {
                pending = appeals.filter(a => a.target_role === 'teacher' && a.status === 'pending_teacher').length;
            } else if (currentUserRole === 'admin') {
                pending = appeals.filter(a => (a.target_role === 'admin' || a.forwarded_to === 'admin') && (a.status === 'pending_admin' || a.status === 'recommended')).length;
            } else {
                pending = appeals.filter(a => a.created_by === currentLoginId && ['approved', 'denied', 'not_recommended'].includes(a.status)).length;
            }
            button.classList.toggle('tab-alert', pending > 0);
            button.innerHTML = `<i class="fas fa-bullhorn"></i> Appeals${pending > 0 ? `<span class="tab-count">${pending}</span>` : ''}`;
            updateNotificationsTabNotification();
        }

        function normalizeAttendanceStatus(value) {
            const status = String(value || '').toLowerCase();
            if (status === 'present' || status === 'absent' || status === 'late' || status === 'leave') {
                return status;
            }
            return 'present';
        }

        function getAttendancePenaltyPointsForStatus(status) {
            const key = normalizeAttendanceStatus(status);
            if (key === 'absent') return -20;
            if (key === 'late') return -5;
            return 0;
        }

        function resetAttendanceDraft(date = '', month = '') {
            attendanceDraftState.date = date || '';
            attendanceDraftState.month = month || '';
            attendanceDraftState.rows = {};
            attendanceDraftState.lastEditAt = 0;
        }

        function ensureAttendanceDraftContext(date, month) {
            const normalizedDate = String(date || '');
            const normalizedMonth = String(month || '');
            if (attendanceDraftState.date !== normalizedDate || attendanceDraftState.month !== normalizedMonth) {
                resetAttendanceDraft(normalizedDate, normalizedMonth);
            }
        }

        function setAttendanceDraft(studentId, status, remarks) {
            if (!studentId) return;
            const key = String(studentId);
            const existing = attendanceDraftState.rows[key] || {};
            attendanceDraftState.rows[key] = {
                status: status == null ? existing.status : normalizeAttendanceStatus(status),
                remarks: remarks == null ? existing.remarks : String(remarks || '')
            };
        }

        function hasActiveAttendanceEdit() {
            const active = document.activeElement;
            const insideTable = !!(active && typeof active.closest === 'function' && active.closest('#attendanceTable'));
            const recentEdit = (Date.now() - (attendanceDraftState.lastEditAt || 0)) < LIVE_EDIT_GUARD_MS;
            return insideTable || recentEdit;
        }

        function getAttendanceDraft(studentId) {
            return attendanceDraftState.rows[String(studentId)] || null;
        }

        function getAttendanceRecord(studentId, date) {
            const records = db.getAttendance();
            const targetDate = String(date || '');
            const targetStudent = String(studentId);
            const student = db.getStudents().find(s => parseInt(s.id, 10) === parseInt(studentId, 10));
            const targetRoll = normalizeAttendanceRoll(student && student.roll ? student.roll : '');
            let latest = null;
            let latestStamp = 0;
            for (const item of records) {
                if (String(item.date || '') !== targetDate) continue;
                if (String(item.studentId) !== targetStudent) continue;
                const stamp = Date.parse(item.updated_at || item.created_at || '') || 0;
                if (!latest || stamp >= latestStamp) {
                    latest = item;
                    latestStamp = stamp;
                }
            }
            if (!latest && targetRoll) {
                for (const item of records) {
                    if (String(item.date || '') !== targetDate) continue;
                    const roll = normalizeAttendanceRoll(item.roll || '');
                    if (!roll || roll !== targetRoll) continue;
                    const stamp = Date.parse(item.updated_at || item.created_at || '') || 0;
                    if (!latest || stamp >= latestStamp) {
                        latest = item;
                        latestStamp = stamp;
                    }
                }
            }
            return latest;
        }

        function getAttendanceRecordsForStudent(student, options = {}) {
            const targetDatePrefix = String(options.month || '').trim();
            const fromDate = String(options.fromDate || '').trim();
            const toDate = String(options.toDate || '').trim();
            const studentId = parseInt(student && student.id, 10);
            const studentRoll = normalizeAttendanceRoll(student && student.roll ? student.roll : '');
            if (!studentId && !studentRoll) return [];
            const latestByDate = new Map();
            (db.getAttendance() || []).forEach(item => {
                if (!item || typeof item !== 'object') return;
                const dateValue = String(item.date || '').trim();
                if (!dateValue) return;
                if (targetDatePrefix && !dateValue.startsWith(targetDatePrefix)) return;
                if (fromDate && dateValue < fromDate) return;
                if (toDate && dateValue > toDate) return;
                const sameId = studentId && String(item.studentId) === String(studentId);
                const sameRoll = studentRoll && normalizeAttendanceRoll(item.roll || '') === studentRoll;
                if (!sameId && !sameRoll) return;
                const prev = latestByDate.get(dateValue);
                if (!prev) {
                    latestByDate.set(dateValue, item);
                    return;
                }
                const prevStamp = Date.parse(prev.updated_at || prev.created_at || '') || 0;
                const nextStamp = Date.parse(item.updated_at || item.created_at || '') || 0;
                if (nextStamp >= prevStamp) {
                    latestByDate.set(dateValue, item);
                }
            });
            return Array.from(latestByDate.values());
        }

        function getAttendanceStatus(studentId, date) {
            return safeProp(getAttendanceRecord(studentId, date), 'status') || 'present';
        }

        function getBulkAttendanceStudents() {
            const monthValue = getElementValue('bulkAttendanceMonth') || getCurrentMonthKey();
            const groupFilter = getElementValue('bulkAttendanceGroupFilter') || 'all';
            const studentStatus = getElementValue('bulkAttendanceStudentStatus') || 'active';
            const profileMap = getMonthRosterProfileMap(monthValue);
            let students = getAttendanceStudentsByStatus(db.getStudents(), studentStatus)
                .map(student => getMonthAwareStudent(student, monthValue, profileMap));
            if (groupFilter !== 'all') {
                students = students.filter(student => getStudentGroup(student) === groupFilter);
            }
            return students.sort(compareStudentsByGroup);
        }

        function getBulkSelectionStatus(slot) {
            return String(getElementValue(`bulkAttendanceMarkStatus${slot}`) || '').trim().toLowerCase();
        }

        function setBulkSelectionSlot(slot) {
            bulkAttendanceActiveSlot = slot;
            [1, 2, 3].forEach(idx => {
                const btn = document.getElementById(`bulkSlot${idx}Btn`);
                if (!btn) return;
                btn.classList.toggle('bulk-slot-active', idx === slot);
            });
            renderBulkAttendanceCalendar();
            renderBulkAttendanceDates();
        }

        function populateBulkAttendanceStudentOptions() {
            const select = document.getElementById('bulkAttendanceStudent');
            if (!select) return;
            const students = getBulkAttendanceStudents();
            const selected = select.value;
            select.innerHTML = '<option value="">Select Student...</option>' + students.map(student => {
                return `<option value="${student.id}">${formatRollDisplay(student.roll)} - ${escapeHtml(student.base_name || student.name || '')}</option>`;
            }).join('');
            if (students.some(student => String(student.id) === String(selected))) {
                select.value = selected;
            }
        }

        function syncBulkDateInputBounds() {
            const monthValue = getElementValue('bulkAttendanceMonth');
            if (!monthValue) return;
            [1, 2, 3].forEach(slot => {
                Array.from(bulkAttendanceSelectionDates[slot]).forEach(dateStr => {
                    if (!dateStr.startsWith(monthValue)) {
                        bulkAttendanceSelectionDates[slot].delete(dateStr);
                    }
                });
            });
            if (bulkAttendanceActiveSlot < 1 || bulkAttendanceActiveSlot > 3) {
                bulkAttendanceActiveSlot = 1;
            }
            setBulkSelectionSlot(bulkAttendanceActiveSlot);
            renderBulkAttendanceCalendar();
            renderBulkAttendanceDates();
        }

        function toggleBulkAttendanceDate(dateValue) {
            const activeStatus = getBulkSelectionStatus(bulkAttendanceActiveSlot);
            if (!activeStatus) {
                showAlert(`Set status for Selection ${bulkAttendanceActiveSlot} first.`, 'warning');
                return;
            }
            const activeSet = bulkAttendanceSelectionDates[bulkAttendanceActiveSlot];
            if (activeSet.has(dateValue)) {
                activeSet.delete(dateValue);
            } else {
                [1, 2, 3].forEach(slot => {
                    bulkAttendanceSelectionDates[slot].delete(dateValue);
                });
                activeSet.add(dateValue);
            }
            renderBulkAttendanceCalendar();
            renderBulkAttendanceDates();
        }

        function renderBulkAttendanceCalendar() {
            const monthValue = getElementValue('bulkAttendanceMonth');
            const container = document.getElementById('bulkAttendanceCalendar');
            if (!container) return;
            if (!monthValue) {
                container.innerHTML = '<span class="section-subtitle">Select month to load calendar.</span>';
                return;
            }
            const [year, month] = monthValue.split('-').map(Number);
            const firstWeekday = new Date(year, month - 1, 1).getDay();
            const days = new Date(year, month, 0).getDate();
            const weekdayHeaders = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat']
                .map(label => `<div class="bulk-calendar-weekday">${label}</div>`).join('');
            const dayCells = [];
            for (let idx = 0; idx < firstWeekday; idx += 1) {
                dayCells.push('<div></div>');
            }
            for (let day = 1; day <= days; day += 1) {
                const date = `${monthValue}-${String(day).padStart(2, '0')}`;
                const weekday = new Date(year, month - 1, day).getDay();
                const weekendClass = (weekday === 0 || weekday === 6) ? 'weekend' : '';
                let statusClass = '';
                let selectedClass = '';
                [1, 2, 3].forEach(slot => {
                    if (!bulkAttendanceSelectionDates[slot].has(date)) return;
                    const slotStatus = getBulkSelectionStatus(slot);
                    if (slotStatus) {
                        statusClass = `state-${slotStatus}`;
                    }
                    selectedClass = 'selected';
                });
                dayCells.push(`<button type="button" class="bulk-day-btn ${weekendClass} ${selectedClass} ${statusClass}" onclick="toggleBulkAttendanceDate('${date}')">${day}</button>`);
            }
            container.innerHTML = `
                <div class="bulk-calendar-grid">${weekdayHeaders}</div>
                <div class="bulk-calendar-grid" style="margin-top: 8px;">${dayCells.join('')}</div>
            `;
        }

        function renderBulkAttendanceDates() {
            const list = document.getElementById('bulkDateList');
            if (!list) return;
            const rows = [];
            [1, 2, 3].forEach(slot => {
                const status = getBulkSelectionStatus(slot);
                if (!status) return;
                Array.from(bulkAttendanceSelectionDates[slot]).sort().forEach(dateStr => {
                    rows.push({ slot, status, dateStr });
                });
            });
            list.innerHTML = rows.map(item => `
                <span class="bulk-date-chip state-${item.status}">
                    S${item.slot}: ${formatDateLabel(item.dateStr)} - ${item.status.replace('_', ' ')}
                    <button type="button" onclick="toggleBulkAttendanceDate('${item.dateStr}')"><i class="fas fa-times"></i></button>
                </span>
            `).join('');
            if (!rows.length) {
                list.innerHTML = '<span class="section-subtitle">No dates selected yet.</span>';
            }
        }

        function clearBulkAttendanceDates() {
            [1, 2, 3].forEach(slot => bulkAttendanceSelectionDates[slot].clear());
            renderBulkAttendanceCalendar();
            renderBulkAttendanceDates();
        }

        function getDaysInMonth(monthValue) {
            const [year, month] = String(monthValue || '').split('-').map(Number);
            if (!year || !month) return 0;
            return new Date(year, month, 0).getDate();
        }

        async function applyBulkPastAttendance() {
            if (currentUserRole === 'teacher') {
                showAlert('Bulk past attendance is Admin-only. Teachers can mark attendance day-wise for the current month.', 'warning');
                return;
            }
            if (currentUserRole !== 'admin') {
                showAlert('Only Admin can save bulk past attendance.', 'warning');
                return;
            }
            const monthValue = getElementValue('bulkAttendanceMonth');
            const defaultStatus = getElementValue('bulkAttendanceDefaultStatus') || 'present';
            const selectedStudentId = parseInt(getElementValue('bulkAttendanceStudent'), 10);
            const bulkRemarks = String(getElementValue('bulkAttendanceRemarks') || '').trim();
            if (!monthValue) {
                showAlert('Select target month.', 'warning');
                return;
            }
            if (!selectedStudentId) {
                showAlert('Select a student for bulk attendance.', 'warning');
                return;
            }
            const slot1Status = getBulkSelectionStatus(1);
            const slot1Count = bulkAttendanceSelectionDates[1].size;
            if (!slot1Status || slot1Count === 0) {
                showAlert('Selection 1 status and at least one date are mandatory.', 'warning');
                return;
            }
            const totalSelections = [1, 2, 3].reduce((sum, slot) => sum + bulkAttendanceSelectionDates[slot].size, 0);
            if (!totalSelections) {
                showAlert('Select at least one date on the calendar.', 'warning');
                return;
            }
            const days = getDaysInMonth(monthValue);
            if (!days) {
                showAlert('Invalid month selected.', 'danger');
                return;
            }

            const students = getBulkAttendanceStudents();
            const student = students.find(item => item.id === selectedStudentId);
            if (!student) {
                showAlert('Selected student is not available under current filters.', 'warning');
                return;
            }
            let writes = 0;
            const selectionMap = new Map();
            [1, 2, 3].forEach(slot => {
                const slotStatus = getBulkSelectionStatus(slot);
                if (!slotStatus) return;
                bulkAttendanceSelectionDates[slot].forEach(date => {
                    selectionMap.set(date, slotStatus);
                });
            });
            const changedRows = [];
            for (let day = 1; day <= days; day += 1) {
                const date = `${monthValue}-${String(day).padStart(2, '0')}`;
                const slotStatus = selectionMap.get(date);
                let status = slotStatus || defaultStatus;
                const existing = getAttendanceRecord(student.id, date);
                // Preserve existing records unless user explicitly selected the date.
                // If an existing record has no status, fill it with the remaining status.
                if (existing && !slotStatus && existing.status) {
                    continue;
                }
                db.upsertAttendance({
                    date,
                    studentId: student.id,
                    status,
                    remarks: bulkRemarks,
                    marked_by: currentLoginId || currentUserRole
                }, { skipSync: true });
                const savedRecord = getAttendanceRecord(student.id, date);
                if (savedRecord) changedRows.push(savedRecord);
                writes += 1;
            }
            if (!changedRows.length) {
                showAlert('No bulk attendance changes to save', 'info');
                return;
            }

            if (SERVER_SYNC.enabled && (currentUserRole === 'admin' || currentUserRole === 'teacher')) {
                const studentsPatch = [{
                    id: student.id,
                    roll: normalizeAttendanceRoll(student.roll || '')
                }].filter(item => item.roll);
                const attendancePatch = {
                    attendance: changedRows,
                    students: studentsPatch
                };
                const pushed = await pushAttendancePatchReliable(attendancePatch, changedRows);
                if (!pushed) {
                    showAlert('Bulk attendance saved locally, but server sync is pending. It will retry automatically.', 'warning');
                }
            }
            loadAttendanceTab();
            showAlert(`Bulk attendance saved for ${student.base_name || student.name} (${writes} entries).`, 'success');
        }

        function getStudentActiveMonths(roll) {
            const rollKey = normalizeRoll(roll || '');
            if (!rollKey) return [];
            const data = db.getData();
            const monthStudents = (data && data.month_students && typeof data.month_students === 'object') ? data.month_students : {};
            const activeMonths = [];
            Object.keys(monthStudents || {}).forEach(monthKey => {
                const roster = monthStudents[monthKey];
                if (!Array.isArray(roster)) return;
                if (roster.some(entry => normalizeRoll(entry) === rollKey)) {
                    activeMonths.push(String(monthKey));
                }
            });
            return activeMonths.sort().reverse();
        }

        function populateAttendanceStudentReportFilters(defaultMonth = '') {
            const monthSelect = document.getElementById('attendanceStudentReportMonth');
            const groupSelect = document.getElementById('attendanceStudentReportGroup');
            const classSelect = document.getElementById('attendanceStudentReportClass');
            const fromInput = document.getElementById('attendanceStudentReportFrom');
            const toInput = document.getElementById('attendanceStudentReportTo');
            if (!monthSelect || !groupSelect || !classSelect) return;

            const isStudent = currentUserRole === 'student';
            let months = isStudent ? getStudentActiveMonths(currentLoginId) : db.getMonths();
            const fallbackMonth = defaultMonth || getCurrentMonthKey();
            const previousMonth = monthSelect.value || fallbackMonth;
            if (isStudent) {
                if (!months.length) months = [fallbackMonth];
            } else {
                if (!months.includes(fallbackMonth)) months.unshift(fallbackMonth);
                if (!months.length) months = [fallbackMonth];
            }
            monthSelect.innerHTML = `<option value="">${isStudent ? 'All Active Months' : 'All Months'}</option>` + months.map(m => {
                const label = new Date(m + '-01').toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                return `<option value="${m}">${label}</option>`;
            }).join('');
            monthSelect.value = months.includes(previousMonth) ? previousMonth : (months.includes(fallbackMonth) ? fallbackMonth : months[0]);

            if (isStudent) {
                groupSelect.innerHTML = '<option value="all">My Attendance</option>';
                groupSelect.value = 'all';
                groupSelect.disabled = true;
                classSelect.innerHTML = '<option value="">My Attendance</option>';
                classSelect.value = '';
                classSelect.disabled = true;
            } else {
                const groups = Array.from(new Set(db.getStudents()
                    .map(student => getStudentGroup(student))
                    .filter(Boolean)))
                    .sort((a, b) => String(a).localeCompare(String(b)));
                const previousGroup = groupSelect.value || 'all';
                groupSelect.innerHTML = '<option value="all">All Groups</option>' +
                    groups.map(group => `<option value="${group}">Group ${group}</option>`).join('');
                groupSelect.value = (previousGroup === 'all' || groups.includes(previousGroup)) ? previousGroup : 'all';
                groupSelect.disabled = false;

                const classes = Array.from(new Set(db.getStudents()
                    .map(student => String(coalesce(student.class, '')).trim())
                    .filter(Boolean)))
                    .sort((a, b) => {
                        const aNum = parseInt(a, 10);
                        const bNum = parseInt(b, 10);
                        if (!Number.isNaN(aNum) && !Number.isNaN(bNum)) return aNum - bNum;
                        return a.localeCompare(b);
                    });
                const previousClass = classSelect.value || '';
                classSelect.innerHTML = '<option value="">All Classes</option>' +
                    classes.map(cls => `<option value="${cls}">Class ${cls}</option>`).join('');
                classSelect.value = classes.includes(previousClass) ? previousClass : '';
                classSelect.disabled = false;
            }

            if (fromInput && toInput && fromInput.value && toInput.value && fromInput.value > toInput.value) {
                toInput.value = fromInput.value;
            }
        }

        function loadAttendanceTab() {
            if (currentUserRole === 'student') {
                populateAttendanceStudentReportFilters(getCurrentMonthKey());
                loadAttendanceReport();
                autoAdjustTableFonts();
                return;
            }
            const dateInput = document.getElementById('attendanceDate');
            const monthSelect = document.getElementById('attendanceMonth');
            if (!dateInput || !monthSelect) return;

            if (!dateInput.value) {
                dateInput.value = formatDateKey(new Date());
            }
            const currentMonth = dateInput.value.substring(0, 7);
            const months = db.getMonths();
            if (!months.includes(currentMonth)) months.unshift(currentMonth);
            monthSelect.innerHTML = months.map(m => {
                const label = new Date(m + '-01').toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                return `<option value="${m}">${label}</option>`;
            }).join('');
            if (!monthSelect.value) monthSelect.value = currentMonth;
            if (!months.includes(monthSelect.value)) monthSelect.value = currentMonth;
            const monthValue = monthSelect.value || currentMonth;
            ensureAttendanceDraftContext(dateInput.value, monthValue);

            const bulkMonthInput = document.getElementById('bulkAttendanceMonth');
            if (bulkMonthInput && !bulkMonthInput.value) {
                bulkMonthInput.value = monthValue;
            }
            syncBulkDateInputBounds();
            populateBulkAttendanceStudentOptions();
            renderBulkAttendanceDates();

            const groupFilter = getElementValue('attendanceGroupFilter') || 'all';
            const statusFilter = getElementValue('attendanceStatusFilter') || 'active';
            const profileMap = getMonthRosterProfileMap(monthValue);
            const students = getAttendanceStudentsByStatus(db.getStudents(), statusFilter)
                .map(student => getMonthAwareStudent(student, monthValue, profileMap))
                .filter(student => groupFilter === 'all' || getStudentGroup(student) === groupFilter)
                .sort(compareRecordStudentsByRollSuffix);

            const tbody = document.getElementById('attendanceBody');
            tbody.innerHTML = students.map(student => {
                const record = getAttendanceRecord(student.id, dateInput.value);
                const draft = getAttendanceDraft(student.id);
                const status = normalizeAttendanceStatus(safeProp(draft, 'status') || safeProp(record, 'status') || 'present');
                const remarks = escapeHtml(String(safeProp(draft, 'remarks') || safeProp(record, 'remarks') || ''));
                const markedClass = record ? 'attendance-marked-row' : '';
                const controlClass = record ? 'attendance-marked' : '';
                return `
                    <tr class="${student.active === false ? 'inactive-row' : ''} ${markedClass}">
                        <td>${formatRollDisplay(student.roll)}</td>
                        <td>${renderStudentName(student, monthValue)}</td>
                        <td>${student.class || '-'}</td>
                        <td>${getStudentGroup(student) || '-'}</td>
                        <td>
                            <select class="${controlClass}" data-attendance-student="${student.id}" data-attendance-roll="${normalizeAttendanceRoll(student.roll || '')}" onchange="handleAttendanceStatusChange(this)" ${currentUserRole === 'student' ? 'disabled' : ''}>
                                <option value="present" ${status === 'present' ? 'selected' : ''}>Present</option>
                                <option value="absent" ${status === 'absent' ? 'selected' : ''}>Absent</option>
                                <option value="late" ${status === 'late' ? 'selected' : ''}>Late</option>
                                <option value="leave" ${status === 'leave' ? 'selected' : ''}>Leave</option>
                            </select>
                        </td>
                        <td>
                            <input class="${controlClass}" type="text" data-attendance-remarks="${student.id}" data-attendance-roll="${normalizeAttendanceRoll(student.roll || '')}" value="${remarks}" placeholder="Remarks" ${currentUserRole === 'student' ? 'disabled' : ''}>
                        </td>
                    </tr>
                `;
            }).join('');
            if (!students.length) {
                tbody.innerHTML = `<tr><td colspan="6" class="text-center" style="padding: 30px;">No students for selected filters</td></tr>`;
            }
            document.querySelectorAll('[data-attendance-student]').forEach(select => applyAttendanceStatusClass(select));
            document.querySelectorAll('[data-attendance-remarks]').forEach(input => {
                input.addEventListener('input', () => handleAttendanceRemarkChange(input));
            });

            populateAttendanceStudentReportFilters(monthValue);
            loadAttendanceReport();
            autoAdjustTableFonts();
        }

        function markAllAttendance(status) {
            if (currentUserRole === 'student') return;
            document.querySelectorAll('[data-attendance-student]').forEach(select => {
                select.value = status;
                handleAttendanceStatusChange(select);
            });
        }

        function getAttendanceStatusClass(status) {
            const value = String(status || '').toLowerCase();
            if (value === 'present') return 'attendance-status-present';
            if (value === 'absent') return 'attendance-status-absent';
            if (value === 'leave') return 'attendance-status-leave';
            if (value === 'late') return 'attendance-status-late';
            return '';
        }

        function applyAttendanceStatusClass(selectEl) {
            if (!selectEl) return;
            const row = selectEl.closest('tr');
            if (!row) return;
            row.classList.remove('attendance-status-present', 'attendance-status-absent', 'attendance-status-leave', 'attendance-status-late');
            const statusClass = getAttendanceStatusClass(selectEl.value);
            if (statusClass) row.classList.add(statusClass);
        }

        function handleAttendanceStatusChange(selectEl) {
            if (!selectEl) return;
            applyAttendanceStatusClass(selectEl);
            const studentId = parseInt(selectEl.getAttribute('data-attendance-student'), 10);
            if (studentId) {
                attendanceDraftState.lastEditAt = Date.now();
                const remarksInput = document.querySelector(`[data-attendance-remarks="${studentId}"]`);
                setAttendanceDraft(studentId, selectEl.value, remarksInput ? String(remarksInput.value || '') : '');
            }
        }

        function handleAttendanceRemarkChange(inputEl) {
            if (!inputEl) return;
            const studentId = parseInt(inputEl.getAttribute('data-attendance-remarks'), 10);
            if (!studentId) return;
            attendanceDraftState.lastEditAt = Date.now();
            const statusSelect = document.querySelector(`[data-attendance-student="${studentId}"]`);
            const status = statusSelect ? statusSelect.value : 'present';
            setAttendanceDraft(studentId, status, String(inputEl.value || ''));
        }

        function attendanceRowsMatch(rows) {
            const list = Array.isArray(rows) ? rows : [];
            for (const row of list) {
                if (!row || typeof row !== 'object') continue;
                const sid = parseInt(row.studentId, 10);
                const dateKey = String(row.date || '').trim();
                if (!sid || !dateKey) continue;
                const expectedStatus = normalizeAttendanceStatus(row.status);
                const expectedRemarks = String(row.remarks || '').trim();
                const saved = getAttendanceRecord(sid, dateKey);
                if (!saved) return false;
                const actualStatus = normalizeAttendanceStatus(saved.status);
                const actualRemarks = String(saved.remarks || '').trim();
                if (actualStatus !== expectedStatus) return false;
                if (actualRemarks !== expectedRemarks) return false;
            }
            return true;
        }

        function attendanceRowKey(row) {
            if (!row || typeof row !== 'object') return '';
            const dateKey = String(row.date || '').trim();
            const sid = parseInt(row.studentId, 10);
            const roll = normalizeAttendanceRoll(row.roll || '');
            if (!dateKey) return '';
            if (sid) return `${dateKey}::sid:${sid}`;
            if (roll) return `${dateKey}::roll:${roll}`;
            return '';
        }

        function attendanceRowsMatchSnapshot(expectedRows, snapshotRows) {
            const expected = Array.isArray(expectedRows) ? expectedRows : [];
            const actual = Array.isArray(snapshotRows) ? snapshotRows : [];
            const byKey = new Map();
            actual.forEach(item => {
                const key = attendanceRowKey(item);
                if (!key) return;
                const prev = byKey.get(key);
                if (!prev) {
                    byKey.set(key, item);
                    return;
                }
                const prevStamp = parseSyncStamp(prev.updated_at || prev.created_at || '');
                const nextStamp = parseSyncStamp(item.updated_at || item.created_at || '');
                if (nextStamp >= prevStamp) byKey.set(key, item);
            });
            for (const row of expected) {
                const key = attendanceRowKey(row);
                if (!key) continue;
                const matched = byKey.get(key);
                if (!matched) return false;
                const expectedStatus = normalizeAttendanceStatus(row.status);
                const expectedRemarks = String(row.remarks || '').trim();
                const actualStatus = normalizeAttendanceStatus(matched.status);
                const actualRemarks = String(matched.remarks || '').trim();
                if (actualStatus !== expectedStatus) return false;
                if (actualRemarks !== expectedRemarks) return false;
            }
            return true;
        }

        async function verifyAttendancePatchOnServer(expectedRows) {
            if (!SERVER_SYNC.enabled) return true;
            try {
                const resp = await fetchWithTimeout(SERVER_SYNC.dataUrl, { cache: 'no-store', credentials: 'include' }, 9000);
                if (!resp.ok) return false;
                const payload = await resp.json();
                const serverData = payload && payload.data ? payload.data : null;
                if (!serverData || typeof serverData !== 'object') return false;
                return attendanceRowsMatchSnapshot(expectedRows, serverData.attendance || []);
            } catch (err) {
                return false;
            }
        }

        async function pushAttendancePatchReliable(attendancePatch, expectedRows) {
            const maxAttempts = 3;
            for (let attempt = 1; attempt <= maxAttempts; attempt += 1) {
                const pushed = await pushToServer(attendancePatch, { silent: attempt < maxAttempts, allowPatch: true });
                await pullFromServer(false, true);
                const localOk = attendanceRowsMatch(expectedRows);
                const serverOk = pushed ? await verifyAttendancePatchOnServer(expectedRows) : false;
                if (localOk && serverOk) {
                    return true;
                }
                await new Promise(resolve => setTimeout(resolve, 250 * attempt));
            }
            return false;
        }

        async function saveAttendance() {
            if (currentUserRole === 'student') {
                showAlert('Students can only view attendance reports', 'warning');
                return;
            }
            const date = getElementValue('attendanceDate');
            if (!date) {
                showAlert('Select date first', 'danger');
                return;
            }
            let month = getElementValue('attendanceMonth') || date.substring(0, 7);
            if (currentUserRole === 'teacher' && date) {
                month = String(date).substring(0, 7);
                const monthEl = document.getElementById('attendanceMonth');
                if (monthEl) monthEl.value = month;
            }
            if (!teacherValidateCurrentMonth(date, month, 'Attendance marking')) {
                return;
            }
            const selects = document.querySelectorAll('[data-attendance-student]');
            let saved = 0;
            const changedRows = [];
            selects.forEach(select => {
                const studentId = parseInt(select.getAttribute('data-attendance-student'), 10);
                if (!studentId) return;
                const remarksInput = document.querySelector(`[data-attendance-remarks="${studentId}"]`);
                const rollAttr = select.getAttribute('data-attendance-roll') || (remarksInput ? remarksInput.getAttribute('data-attendance-roll') : '');
                const nextStatus = normalizeAttendanceStatus(select.value);
                const nextRemarks = remarksInput ? String(remarksInput.value || '').trim() : '';
                const existingRecord = getAttendanceRecord(studentId, date);
                const currentStatus = normalizeAttendanceStatus(existingRecord && existingRecord.status ? existingRecord.status : 'present');
                const currentRemarks = String(existingRecord && existingRecord.remarks ? existingRecord.remarks : '').trim();
                if (currentStatus === nextStatus && currentRemarks === nextRemarks) {
                    return;
                }
                db.upsertAttendance({
                    date,
                    studentId,
                    roll: rollAttr,
                    status: nextStatus,
                    remarks: nextRemarks,
                    marked_by: currentLoginId || currentUserRole
                }, { skipSync: true });
                const savedRecord = getAttendanceRecord(studentId, date);
                if (savedRecord) changedRows.push(savedRecord);
                saved += 1;
            });
            if (!changedRows.length) {
                showAlert('No attendance changes to save', 'info');
                return;
            }
            if (SERVER_SYNC.enabled && (currentUserRole === 'admin' || currentUserRole === 'teacher')) {
                const studentIdSet = new Set(changedRows.map(row => String(row && row.studentId || '')).filter(Boolean));
                const studentsPatch = (db.getStudents() || [])
                    .filter(student => studentIdSet.has(String(student && student.id || '')))
                    .map(student => ({ id: student.id, roll: normalizeAttendanceRoll(student.roll || '') }))
                    .filter(student => !!student.roll);
                const attendancePatch = {
                    attendance: changedRows,
                    students: studentsPatch
                };
                const pushed = await pushAttendancePatchReliable(attendancePatch, changedRows);
                if (!pushed) {
                    showAlert('Attendance saved locally, but server sync is pending. It will retry automatically.', 'warning');
                }
            }
            resetAttendanceDraft(date, getElementValue('attendanceMonth') || date.substring(0, 7));
            loadAttendanceReport();
            // Immediately refresh scoreboard so penalty is visible when switching tabs.
            loadScoreboard();
            showAlert(`Attendance saved for ${saved} students`, 'success');
        }

        function loadStudentAttendanceReport() {
            const ownRoll = normalizeRoll(currentLoginId || '');
            const studentBody = document.getElementById('attendanceStudentReportBody');
            if (!studentBody) return;

            const groupBody = document.getElementById('attendanceReportBody');
            if (groupBody) {
                groupBody.innerHTML = `<tr><td colspan="7" class="text-center" style="padding: 22px;">Student view</td></tr>`;
            }

            const student = (db.getStudents() || []).find(s => normalizeRoll(s && s.roll) === ownRoll) || null;
            if (!student) {
                studentBody.innerHTML = `<tr><td colspan="9" class="text-center" style="padding: 30px;">Profile not found. Contact Admin.</td></tr>`;
                return;
            }

            const activeMonths = getStudentActiveMonths(ownRoll);
            const reportMonthFilter = String(getElementValue('attendanceStudentReportMonth') || '').trim();
            const reportDateFrom = getElementValue('attendanceStudentReportFrom') || '';
            const reportDateTo = getElementValue('attendanceStudentReportTo') || '';

            let months = [];
            if (reportMonthFilter) {
                months = activeMonths.includes(reportMonthFilter) ? [reportMonthFilter] : [];
            } else {
                months = activeMonths.slice();
            }
            if (!months.length) {
                months = [getCurrentMonthKey()];
            }
            const monthSet = new Set(months);

            const stat = { present: 0, absent: 0, late: 0, leave: 0, totalMarked: 0 };
            const studentAttendance = getAttendanceRecordsForStudent(student, {
                month: reportMonthFilter,
                fromDate: reportDateFrom,
                toDate: reportDateTo
            });
            studentAttendance.forEach(record => {
                const dateValue = String(record.date || '');
                if (!dateValue || !monthSet.has(dateValue.substring(0, 7))) return;
                stat.totalMarked += 1;
                if (record.status === 'present') stat.present += 1;
                else if (record.status === 'absent') stat.absent += 1;
                else if (record.status === 'late') stat.late += 1;
                else if (record.status === 'leave') stat.leave += 1;
            });

            const denominator = stat.totalMarked || 1;
            const presentLike = stat.present + stat.late;
            const pct = Math.round((presentLike / denominator) * 100);
            const pctClass = pct >= 85 ? 'att-pct-high' : (pct >= 60 ? 'att-pct-mid' : 'att-pct-low');

            studentBody.innerHTML = `
                <tr>
                    <td>${escapeHtml(student.roll || '')}</td>
                    <td>${escapeHtml(student.base_name || student.name || '')}</td>
                    <td>${escapeHtml(student.class || '')}</td>
                    <td>${escapeHtml(getStudentGroup(student) || '')}</td>
                    <td>${stat.present}</td>
                    <td>${stat.absent}</td>
                    <td>${stat.late}</td>
                    <td>${stat.leave}</td>
                    <td class="${pctClass}">${pct}%</td>
                </tr>
            `;
        }

        function loadAttendanceReport() {
            if (currentUserRole === 'student') {
                loadStudentAttendanceReport();
                return;
            }
            const month = getElementValue('attendanceMonth') || getCurrentMonthKey();
            const groupFilter = getElementValue('attendanceGroupFilter') || 'all';
            const statusFilter = getElementValue('attendanceStatusFilter') || 'active';
            const profileMap = getMonthRosterProfileMap(month);
            const students = getAttendanceStudentsByStatus(db.getStudents(), statusFilter)
                .map(student => getMonthAwareStudent(student, month, profileMap))
                .filter(student => groupFilter === 'all' || getStudentGroup(student) === groupFilter)
                .sort(compareRecordStudentsByRollSuffix);
            const studentMap = new Map(students.map(s => [s.id, s]));
            const records = db.getAttendance().filter(record => String(record.date || '').startsWith(month));

            const groups = {};
            students.forEach(student => {
                const key = getStudentGroup(student) || 'UNGROUPED';
                if (!groups[key]) {
                    groups[key] = { group: key, students: 0, present: 0, absent: 0, late: 0, leave: 0, totalMarked: 0 };
                }
                groups[key].students += 1;
            });

            records.forEach(record => {
                const roll = normalizeRoll(record && record.roll ? record.roll : '');
                const student = studentMap.get(record.studentId) ||
                    (roll ? students.find(item => normalizeRoll(item.roll || '') === roll) : null);
                if (!student) return;
                const key = getStudentGroup(student) || 'UNGROUPED';
                if (!groups[key]) return;
                groups[key].totalMarked += 1;
                if (record.status === 'present') groups[key].present += 1;
                else if (record.status === 'absent') groups[key].absent += 1;
                else if (record.status === 'late') groups[key].late += 1;
                else if (record.status === 'leave') groups[key].leave += 1;
            });

            const tbody = document.getElementById('attendanceReportBody');
            const rows = Object.values(groups).sort((a, b) => String(a.group).localeCompare(String(b.group)));
            tbody.innerHTML = rows.map(row => {
                const denominator = row.totalMarked || 1;
                const presentLike = row.present + row.late;
                const pct = Math.round((presentLike / denominator) * 100);
                return `
                    <tr class="${getGroupRowClass(row.group)}">
                        <td><strong>${row.group}</strong></td>
                        <td>${row.students}</td>
                        <td>${pct}%</td>
                        <td>${row.present}</td>
                        <td>${row.absent}</td>
                        <td>${row.late}</td>
                        <td>${row.leave}</td>
                    </tr>
                `;
            }).join('');
            if (!rows.length) {
                tbody.innerHTML = `<tr><td colspan="7" class="text-center" style="padding: 30px;">No attendance data for selected filters</td></tr>`;
            }

            const studentBody = document.getElementById('attendanceStudentReportBody');
            if (!studentBody) return;
            const reportMonthFilter = getElementValue('attendanceStudentReportMonth') || month;
            const reportGroupFilter = getElementValue('attendanceStudentReportGroup') || 'all';
            const reportClassFilter = getElementValue('attendanceStudentReportClass') || '';
            const reportDateFrom = getElementValue('attendanceStudentReportFrom') || '';
            const reportDateTo = getElementValue('attendanceStudentReportTo') || '';

            const reportProfileMap = getMonthRosterProfileMap(reportMonthFilter || month);
            let studentReportList = getAttendanceStudentsByStatus(db.getStudents(), statusFilter)
                .map(student => getMonthAwareStudent(student, reportMonthFilter || month, reportProfileMap));
            if (groupFilter !== 'all') {
                studentReportList = studentReportList.filter(student => getStudentGroup(student) === groupFilter);
            }
            if (reportGroupFilter !== 'all') {
                studentReportList = studentReportList.filter(student => getStudentGroup(student) === reportGroupFilter);
            }
            if (reportClassFilter) {
                studentReportList = studentReportList.filter(student => String(student.class || '') === String(reportClassFilter));
            }
            studentReportList = studentReportList.sort(compareRecordStudentsByRollSuffix);

            const studentStats = studentReportList.map(student => {
                const stat = { present: 0, absent: 0, late: 0, leave: 0, totalMarked: 0 };
                const studentRecords = getAttendanceRecordsForStudent(student, {
                    month: reportMonthFilter,
                    fromDate: reportDateFrom,
                    toDate: reportDateTo
                });
                studentRecords.forEach(record => {
                    stat.totalMarked += 1;
                    if (record.status === 'present') stat.present += 1;
                    else if (record.status === 'absent') stat.absent += 1;
                    else if (record.status === 'late') stat.late += 1;
                    else if (record.status === 'leave') stat.leave += 1;
                });
                const denominator = stat.totalMarked || 1;
                const presentLike = stat.present + stat.late;
                const pct = Math.round((presentLike / denominator) * 100);
                return { student, stat, pct };
            });
            studentBody.innerHTML = studentStats.map(item => {
                const pctClass = item.pct >= 85 ? 'att-pct-high' : (item.pct >= 60 ? 'att-pct-mid' : 'att-pct-low');
                return `
                <tr class="${item.student.active === false ? 'inactive-row' : ''}">
                    <td>${escapeHtml(item.student.roll || '')}</td>
                    <td>${escapeHtml(item.student.name || '')}</td>
                    <td>${escapeHtml(item.student.class || '')}</td>
                    <td>${escapeHtml(getStudentGroup(item.student) || '')}</td>
                    <td>${item.stat.present}</td>
                    <td>${item.stat.absent}</td>
                    <td>${item.stat.late}</td>
                    <td>${item.stat.leave}</td>
                    <td class="${pctClass}">${item.pct}%</td>
                </tr>
            `;
            }).join('');
            if (!studentStats.length) {
                studentBody.innerHTML = `<tr><td colspan="9" class="text-center" style="padding: 30px;">No attendance data for selected filters</td></tr>`;
            }
        }

        function ensureProfileMonths() {
            const currentMonth = getCurrentMonthKey();
            const months = db.getMonths();
            if (!months.includes(currentMonth)) months.unshift(currentMonth);
            const profileMonth = document.getElementById('profileMonth');
            const homeworkMonth = document.getElementById('homeworkMonth');
            if (profileMonth) {
                const selected = profileMonth.value || currentMonth;
                profileMonth.innerHTML = months.map(m => {
                    const label = new Date(m + '-01').toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    return `<option value="${m}">${label}</option>`;
                }).join('');
                profileMonth.value = months.includes(selected) ? selected : currentMonth;
            }
            if (homeworkMonth) {
                const selected = homeworkMonth.value || currentMonth;
                homeworkMonth.innerHTML = months.map(m => {
                    const label = new Date(m + '-01').toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                    return `<option value="${m}">${label}</option>`;
                }).join('');
                homeworkMonth.value = months.includes(selected) ? selected : currentMonth;
            }
        }

        function getProfileStudents(monthValue, groupFilter = 'all') {
            const profileMap = getMonthRosterProfileMap(monthValue || getCurrentMonthKey());
            let students = filterStudentsByStatus(db.getStudents(), 'all', monthValue)
                .map(student => getMonthAwareStudent(student, monthValue, profileMap));
            if (groupFilter !== 'all') {
                students = students.filter(student => getStudentGroup(student) === groupFilter);
            }
            return students.sort(compareStudentsByGroup);
        }

        function populateProfileStudents() {
            const monthValue = getElementValue('profileMonth') || getCurrentMonthKey();
            const ownRoll = normalizeRoll(currentLoginId);
            let groupFilter = getElementValue('profileGroupFilter') || 'all';
            if (currentUserRole === 'student') {
                groupFilter = 'all';
            }
            const select = document.getElementById('profileStudent');
            if (!select) return;
            const selected = select.value;
            const groupFilterSelect = document.getElementById('profileGroupFilter');
            if (groupFilterSelect) {
                groupFilterSelect.disabled = currentUserRole === 'student';
            }
            let students = getProfileStudents(monthValue, groupFilter);
            if (currentUserRole === 'student') {
                students = students.filter(student => normalizeRoll(student.roll) === ownRoll);
            }
            select.innerHTML = '<option value="">Select Student...</option>' + students.map(student => {
                return `<option value="${student.id}">${formatRollDisplay(student.roll)} - ${escapeHtml(student.base_name || student.name || '')}</option>`;
            }).join('');
            if (students.some(student => String(student.id) === String(selected))) {
                select.value = selected;
            } else if (students.length === 1 && currentUserRole === 'student') {
                select.value = String(students[0].id);
            }
            select.disabled = currentUserRole === 'student';
            populateHomeworkStudents();
        }

        function saveProfileRemark() {
            if (!(currentUserRole === 'admin' || currentUserRole === 'teacher')) {
                showAlert('Only Admin/Teacher can update profile remarks.', 'warning');
                return;
            }
            const studentId = parseInt(getElementValue('profileStudent'), 10);
            if (!studentId) {
                showAlert('Select a student first.', 'warning');
                return;
            }
            const remark = String(getElementValue('profileRemark') || '').trim();
            const data = db.getData();
            const student = (data.students || []).find(item => item.id === studentId);
            if (!student) {
                showAlert('Student not found.', 'warning');
                return;
            }
            student.profile_remark = remark;
            db.saveData(data, { allowTeacher: true });
            if (SERVER_SYNC.enabled && (currentUserRole === 'admin' || currentUserRole === 'teacher')) {
                pushToServer(db.getData(), { silent: true });
            }
            loadProfileTab();
            showAlert('Profile remark saved.', 'success');
        }

        function toggleHomeworkScope() {
            const scope = getElementValue('homeworkScope') || 'single';
            const singleWrap = document.getElementById('homeworkSingleWrap');
            const multiWrap = document.getElementById('homeworkMultiWrap');
            const groupWrap = document.getElementById('homeworkGroupNoteWrap');
            if (singleWrap) singleWrap.classList.toggle('hidden', scope !== 'single');
            if (multiWrap) multiWrap.classList.toggle('hidden', scope !== 'selected');
            if (groupWrap) groupWrap.classList.toggle('hidden', scope !== 'group');
        }

        function populateHomeworkStudents() {
            const monthValue = getElementValue('homeworkMonth') || getCurrentMonthKey();
            const groupFilter = getElementValue('homeworkGroupFilter') || 'all';
            const students = getProfileStudents(monthValue, groupFilter);

            const singleSelect = document.getElementById('homeworkStudentSingle');
            if (singleSelect) {
                const selected = singleSelect.value;
                singleSelect.innerHTML = '<option value="">Select Student...</option>' + students.map(student => {
                    return `<option value="${student.id}">${formatRollDisplay(student.roll)} - ${escapeHtml(student.base_name || student.name || '')}</option>`;
                }).join('');
                if (students.some(student => String(student.id) === String(selected))) {
                    singleSelect.value = selected;
                }
            }

            const multiSelect = document.getElementById('homeworkStudentMulti');
            if (multiSelect) {
                const selectedValues = new Set(Array.from(multiSelect.selectedOptions || []).map(option => option.value));
                multiSelect.innerHTML = students.map(student => {
                    const selected = selectedValues.has(String(student.id)) ? 'selected' : '';
                    return `<option value="${student.id}" ${selected}>${formatRollDisplay(student.roll)} - ${escapeHtml(student.base_name || student.name || '')}</option>`;
                }).join('');
            }

            toggleHomeworkScope();
        }

        function getHomeworkTargetsByScope(monthValue) {
            const groupFilter = getElementValue('homeworkGroupFilter') || 'all';
            const scope = getElementValue('homeworkScope') || 'single';
            const students = getProfileStudents(monthValue, groupFilter);
            if (scope === 'group') {
                return students;
            }
            if (scope === 'selected') {
                const multiSelect = document.getElementById('homeworkStudentMulti');
                const selectedIds = new Set(Array.from(multiSelect ? multiSelect.selectedOptions : []).map(option => String(option.value)));
                return students.filter(student => selectedIds.has(String(student.id)));
            }
            const singleId = String(getElementValue('homeworkStudentSingle') || '');
            return students.filter(student => String(student.id) === singleId);
        }

        function saveHomeworkEndorsement(forcedStatus = '') {
            if (!(currentUserRole === 'admin' || currentUserRole === 'teacher')) {
                showAlert('Only Admin/Teacher can save homework endorsement.', 'warning');
                return;
            }
            const date = getElementValue('homeworkDate') || new Date().toISOString().split('T')[0];
            const monthValue = date.substring(0, 7);
            const status = forcedStatus || getElementValue('homeworkStatus') || 'completed';
            const remarks = String(getElementValue('homeworkRemarks') || '').trim();
            const targets = getHomeworkTargetsByScope(monthValue);
            if (!targets.length) {
                showAlert('No students selected for homework endorsement.', 'warning');
                return;
            }

            const perusalStatus = currentUserRole === 'teacher' ? 'draft' : 'reviewed';
            targets.forEach(student => {
                db.upsertHomework({
                    date,
                    month: monthValue,
                    studentId: student.id,
                    status,
                    remarks,
                    perusal_status: perusalStatus,
                    marked_by: currentLoginId || currentUserRole
                });
            });

            const homeworkMonth = document.getElementById('homeworkMonth');
            if (homeworkMonth) homeworkMonth.value = monthValue;
            if (SERVER_SYNC.enabled && (currentUserRole === 'admin' || currentUserRole === 'teacher')) {
                pushToServer(db.getData(), { silent: true });
            }
            loadHomeworkTable();
            const profileTab = document.getElementById('profile-tab');
            if (profileTab && !profileTab.classList.contains('hidden')) {
                loadProfileTab();
            }
            showAlert(`Homework ${status === 'completed' ? 'completed' : 'not completed'} saved for ${targets.length} student(s).`, 'success');
        }

        function submitHomeworkForPerusal() {
            if (currentUserRole !== 'teacher') {
                showAlert('Only Teacher can submit perusal requests.', 'warning');
                return;
            }
            const date = getElementValue('homeworkDate') || new Date().toISOString().split('T')[0];
            const monthValue = date.substring(0, 7);
            const status = getElementValue('homeworkStatus') || 'completed';
            const remarks = String(getElementValue('homeworkRemarks') || '').trim();
            const targets = getHomeworkTargetsByScope(monthValue);
            if (!targets.length) {
                showAlert('No students selected to submit for perusal.', 'warning');
                return;
            }
            const nowIso = new Date().toISOString();
            targets.forEach(student => {
                db.upsertHomework({
                    date,
                    month: monthValue,
                    studentId: student.id,
                    status,
                    remarks,
                    perusal_status: 'pending_admin',
                    submitted_by: currentLoginId || 'Teacher',
                    submitted_at: nowIso,
                    marked_by: currentLoginId || currentUserRole
                });
            });
            if (SERVER_SYNC.enabled) {
                pushToServer(db.getData(), { silent: true });
            }
            updateHomeworkTabNotification();
            loadHomeworkTable();
            showAlert(`Submitted ${targets.length} homework records for Admin perusal.`, 'success');
        }

        function markHomeworkReviewed(homeworkId) {
            if (currentUserRole !== 'admin') return;
            const data = db.getData();
            const record = (data.homework || []).find(item => item.id === homeworkId);
            if (!record) return;
            record.perusal_status = 'reviewed';
            record.reviewed_by = currentLoginId || 'Admin';
            record.reviewed_at = new Date().toISOString();
            db.saveData(data);
            if (SERVER_SYNC.enabled) {
                pushToServer(db.getData(), { silent: true });
            }
            updateHomeworkTabNotification();
            loadHomeworkTable();
            showAlert('Homework entry marked as reviewed.', 'success');
        }

        function updateHomeworkTabNotification() {
            const button = document.getElementById('homeworkTabButton');
            if (!button) return;
            const pendingCount = db.getHomework().filter(item => item.perusal_status === 'pending_admin').length;
            const showCount = currentUserRole === 'admin' && pendingCount > 0;
            button.classList.toggle('tab-alert', showCount);
            button.innerHTML = `<i class="fas fa-book-reader"></i> Homework${showCount ? `<span class="tab-count">${pendingCount}</span>` : ''}`;
            updateNotificationsTabNotification();
        }

        function loadHomeworkTable() {
            const monthValue = getElementValue('homeworkMonth') || getCurrentMonthKey();
            const groupFilter = getElementValue('homeworkGroupFilter') || 'all';
            const studentMap = new Map(db.getStudents().map(student => [student.id, student]));
            const rows = db.getHomework()
                .filter(item => String(item.date || '').startsWith(monthValue))
                .filter(item => {
                    const student = studentMap.get(item.studentId);
                    if (!student) return false;
                    return groupFilter === 'all' || getStudentGroup(student) === groupFilter;
                })
                .sort((a, b) => String(b.date).localeCompare(String(a.date)));

            const pendingCount = rows.filter(item => item.perusal_status === 'pending_admin').length;
            const notice = document.getElementById('homeworkPendingNotice');
            if (notice) {
                if (currentUserRole === 'admin') {
                    notice.textContent = pendingCount > 0 ? `${pendingCount} homework entries are waiting for perusal.` : 'No pending homework perusal requests.';
                    notice.style.color = pendingCount > 0 ? '#fbbf24' : 'var(--text-muted)';
                } else {
                    notice.textContent = 'Use "Submit for Perusal" to forward teacher entries to Admin.';
                    notice.style.color = 'var(--text-muted)';
                }
            }

            const tbody = document.getElementById('homeworkBody');
            if (!tbody) return;
            tbody.innerHTML = rows.map(item => {
                const student = studentMap.get(item.studentId);
                if (!student) return '';
                const perusalLabel = item.perusal_status === 'pending_admin'
                    ? '<span class="fee-status fee-overdue">Pending Admin</span>'
                    : (item.perusal_status === 'reviewed'
                        ? '<span class="fee-status fee-paid">Reviewed</span>'
                        : '<span class="fee-status fee-due">Draft</span>');
                const perusalAction = (currentUserRole === 'admin' && item.perusal_status === 'pending_admin')
                    ? `<button class="secondary" onclick="markHomeworkReviewed(${item.id})">Mark Reviewed</button>`
                    : '-';
                return `
                    <tr class="${student.active === false ? 'inactive-row' : ''}">
                        <td>${formatDateLabel(item.date)}</td>
                        <td>${formatRollDisplay(student.roll)}</td>
                        <td>${renderStudentName(student)}</td>
                        <td>${getStudentGroup(student) || '-'}</td>
                        <td>${item.status === 'completed' ? 'Completed' : 'Not Completed'}</td>
                        <td>${escapeHtml(item.remarks || '')}</td>
                        <td>${escapeHtml(item.marked_by || '')}</td>
                        <td>${perusalLabel}<div style="margin-top:6px;">${perusalAction}</div></td>
                    </tr>
                `;
            }).join('');
            if (!rows.length) {
                tbody.innerHTML = '<tr><td colspan="8" class="text-center" style="padding: 30px;">No homework entries for selected month.</td></tr>';
            }
            updateHomeworkTabNotification();
            autoAdjustTableFonts();
        }

        function loadProfileTab() {
            ensureProfileMonths();
            populateProfileStudents();
            const monthValue = getElementValue('profileMonth') || getCurrentMonthKey();
            const studentId = parseInt(getElementValue('profileStudent'), 10);
            const student = db.getStudents().find(item => item.id === studentId);
            const metrics = document.getElementById('profileMetrics');
            const editOwnBtn = document.getElementById('editOwnProfileBtn');
            if (editOwnBtn) {
                editOwnBtn.classList.toggle('hidden', currentUserRole !== 'student');
            }
            if (!metrics) return;
            if (!student) {
                metrics.innerHTML = '<div class="profile-metric"><div class="label">Select Student</div><div class="value">-</div></div>';
                loadProfilePostHistory(null);
                return;
            }

            const scoreTotal = getStudentMonthTotal(student.id, monthValue);
            const attendance = getAttendanceRecordsForStudent(student, { month: monthValue });
            const homework = db.getHomework().filter(item => item.studentId === student.id && String(item.date || '').startsWith(monthValue));
            const present = attendance.filter(item => item.status === 'present').length;
            const absent = attendance.filter(item => item.status === 'absent').length;
            const late = attendance.filter(item => item.status === 'late').length;
            const leave = attendance.filter(item => item.status === 'leave').length;
            const attMarked = attendance.length;
            const completedHw = homework.filter(item => item.status === 'completed').length;
            const notCompletedHw = homework.filter(item => item.status === 'not_completed').length;
            const attPct = attMarked ? Math.round(((present + late) / attMarked) * 100) : 0;

            const latestAttendanceRemark = attendance
                .filter(item => item.remarks)
                .sort((a, b) => String(b.date).localeCompare(String(a.date)))[0];
            const latestHomeworkRemark = homework
                .filter(item => item.remarks)
                .sort((a, b) => String(b.date).localeCompare(String(a.date)))[0];

            const profileRemarkInput = document.getElementById('profileRemark');
            if (profileRemarkInput) {
                profileRemarkInput.value = student.profile_remark || '';
                profileRemarkInput.disabled = !(currentUserRole === 'admin' || currentUserRole === 'teacher');
            }
            const saveRemarkBtn = document.querySelector('#profile-tab button[onclick="saveProfileRemark()"]');
            if (saveRemarkBtn) {
                saveRemarkBtn.disabled = currentUserRole === 'student';
            }
            metrics.innerHTML = `
                <div class="profile-metric"><div class="label">Student</div><div class="value">${escapeHtml(student.base_name || student.name || '-')}</div></div>
                <div class="profile-metric"><div class="label">Total Score (${monthValue})</div><div class="value">${scoreTotal}</div></div>
                <div class="profile-metric"><div class="label">Attendance %</div><div class="value">${attPct}%</div></div>
                <div class="profile-metric"><div class="label">Present / Absent</div><div class="value">${present} / ${absent}</div></div>
                <div class="profile-metric"><div class="label">Late / Leave</div><div class="value">${late} / ${leave}</div></div>
                <div class="profile-metric"><div class="label">Homework Completed</div><div class="value">${completedHw}</div></div>
                <div class="profile-metric"><div class="label">Homework Not Completed</div><div class="value">${notCompletedHw}</div></div>
                <div class="profile-metric"><div class="label">Latest Attendance Remark</div><div class="value">${escapeHtml(safeProp(latestAttendanceRemark, 'remarks') || '-')}</div></div>
                <div class="profile-metric"><div class="label">Latest Homework Remark</div><div class="value">${escapeHtml(safeProp(latestHomeworkRemark, 'remarks') || '-')}</div></div>
            `;
            loadProfilePostHistory(student.id);
        }

        function loadHomeworkTab() {
            ensureProfileMonths();
            populateHomeworkStudents();
            const homeworkDate = document.getElementById('homeworkDate');
            if (homeworkDate && !homeworkDate.value) {
                homeworkDate.value = new Date().toISOString().split('T')[0];
            }
            const homeworkMonth = document.getElementById('homeworkMonth');
            if (homeworkMonth && !homeworkMonth.value) {
                homeworkMonth.value = getCurrentMonthKey();
            }
            toggleHomeworkScope();
            loadHomeworkTable();
        }

        function normalizeFeeRecord(record) {
            if (!record) {
                return {
                    studentId: null,
                    amount: null,
                    pending_amount: null,
                    start_date: '',
                    period_months: 1,
                    last_paid_date: '',
                    remarks: '',
                    payment_history: [],
                    created_at: '',
                    updated_at: ''
                };
            }
            const amount = Number(record.amount);
            return {
                studentId: record.studentId,
                amount: Number.isFinite(amount) ? amount : null,
                pending_amount: Number.isFinite(Number(record.pending_amount)) ? Number(record.pending_amount) : null,
                start_date: record.start_date ? String(record.start_date) : '',
                period_months: Math.max(1, parseInt(record.period_months, 10) || 1),
                last_paid_date: record.last_paid_date ? String(record.last_paid_date) : '',
                remarks: record.remarks ? String(record.remarks) : '',
                payment_history: Array.isArray(record.payment_history) ? record.payment_history.slice() : [],
                created_at: record.created_at ? String(record.created_at) : '',
                updated_at: record.updated_at ? String(record.updated_at) : ''
            };
        }

        const DEFAULT_FEE_START_DATE = '2026-01-01';

        function getEffectiveFeeStartDate(record) {
            if (record && record.start_date) return record.start_date;
            return DEFAULT_FEE_START_DATE;
        }

        function getFeeRecordMap() {
            const map = new Map();
            db.getFeeRecords().forEach(record => {
                if (!record || record.studentId === null || record.studentId === undefined) return;
                const key = String(record.studentId);
                if (!key) return;
                map.set(key, normalizeFeeRecord(record));
            });
            return map;
        }

        function getFeeRecordForStudent(studentId, feeMap) {
            const map = feeMap || getFeeRecordMap();
            const key = String(studentId);
            if (map.has(key)) return map.get(key);
            return {
                studentId,
                amount: null,
                pending_amount: null,
                start_date: '',
                period_months: 1,
                last_paid_date: '',
                remarks: '',
                payment_history: []
            };
        }

        function computeFeeDueDate(record) {
            if (!record || !record.start_date) return '';
            const months = Math.max(1, parseInt(record.period_months, 10) || 1);
            return addMonths(record.start_date, months) || '';
        }

        function isFeeOverdue(record) {
            const due = computeFeeDueDate(record);
            if (!due) return false;
            const today = new Date().toISOString().split('T')[0];
            if (today <= due) return false;
            if (!record.last_paid_date) return true;
            return record.last_paid_date < due;
        }

        function saveFeeRecord(studentId, updates) {
            if (currentUserRole !== 'admin') return;
            const studentKey = String(studentId);
            const existing = normalizeFeeRecord(db.getFeeRecords().find(r => String(r.studentId) === studentKey));
            const parsedStudentId = parseInt(studentId, 10);
            const normalizedStudentId = Number.isFinite(parsedStudentId) ? parsedStudentId : studentId;
            const next = { ...existing, ...updates, studentId: normalizedStudentId };
            if (next.amount !== null && !Number.isFinite(Number(next.amount))) {
                next.amount = null;
            }
            if (next.pending_amount !== null && !Number.isFinite(Number(next.pending_amount))) {
                next.pending_amount = null;
            }
            next.period_months = Math.max(1, parseInt(next.period_months, 10) || 1);
            return db.upsertFeeRecord(next);
        }

        async function syncFeeChangeNow() {
            if (!SERVER_SYNC.enabled) return;
            if (!(currentUserRole === 'admin' || currentUserRole === 'teacher')) return;
            await pushToServer(db.getData(), { silent: true });
            await pullFromServer(false);
        }

        async function handleFeeInputChange(input) {
            if (currentUserRole !== 'admin') return;
            const studentId = parseInt(input.dataset.studentId, 10);
            if (!studentId) return;
            const field = input.dataset.field;
            if (!field) return;
            const updates = {};
            if (field === 'amount') {
                const value = parseFloat(input.value);
                updates.amount = Number.isFinite(value) ? value : null;
                updates.pending_amount = updates.amount;
            } else if (field === 'start_date') {
                updates.start_date = input.value || '';
                // Manual cycle reset: start date is the new anchor.
                updates.last_paid_date = '';
            } else if (field === 'period_months') {
                updates.period_months = Math.max(1, parseInt(input.value, 10) || 1);
            } else if (field === 'remarks') {
                updates.remarks = String(input.value || '').trim();
            }
            const saved = saveFeeRecord(studentId, updates);
            if (!saved) {
                showAlert('Unable to save fee update locally. Please run Master Update and retry.', 'warning');
                return;
            }
            await syncFeeChangeNow();
            loadFeesTab();
        }

        function openFeeDatePicker(studentId) {
            const input = document.querySelector(`input[data-student-id="${studentId}"][data-field="start_date"]`);
            if (!input) return;
            if (typeof input.showPicker === 'function') {
                input.showPicker();
            } else {
                input.focus();
                input.click();
            }
        }

        async function markFeePaid(studentId) {
            if (currentUserRole !== 'admin') return;
            if (!confirm('Confirm Fees Paid for this student?')) return;
            const studentKey = String(studentId);
            const record = normalizeFeeRecord(db.getFeeRecords().find(r => String(r.studentId) === studentKey));
            const today = new Date().toISOString().split('T')[0];
            const student = db.getStudents().find(s => s.id === studentId);
            const fallbackAmount = Number.isFinite(Number(student && student.fees)) ? Number(student.fees) : 0;
            const amount = Number.isFinite(Number(record.amount)) ? Number(record.amount) : fallbackAmount;
            const effectiveStart = getEffectiveFeeStartDate(record);
            const dueDate = computeFeeDueDate({ ...record, start_date: effectiveStart });
            const history = Array.isArray(record.payment_history) ? record.payment_history : [];
            history.push({ date: today, amount });
            const saved = saveFeeRecord(studentId, {
                amount: amount || null,
                last_paid_date: today,
                payment_history: history,
                pending_amount: amount || null,
                start_date: dueDate || effectiveStart
            });
            if (!saved) {
                showAlert('Unable to save fee update locally. Please run Master Update and retry.', 'warning');
                return;
            }
            await syncFeeChangeNow();
            loadFeesTab();
            showAlert('Fees marked as paid', 'success');
        }

        async function markFeePartialPaid(studentId) {
            if (currentUserRole !== 'admin') return;
            const studentKey = String(studentId);
            const record = normalizeFeeRecord(db.getFeeRecords().find(r => String(r.studentId) === studentKey));
            const student = db.getStudents().find(s => s.id === studentId);
            const fallbackAmount = Number.isFinite(Number(student && student.fees)) ? Number(student.fees) : 0;
            const baseAmount = Number.isFinite(Number(record.amount)) ? Number(record.amount) : fallbackAmount;
            const dueAmount = Number.isFinite(Number(record.pending_amount)) ? Number(record.pending_amount) : baseAmount;
            const input = prompt('Enter partial amount paid:', dueAmount ? String(dueAmount) : '');
            if (input === null) return;
            const paid = parseFloat(String(input).trim());
            if (!Number.isFinite(paid) || paid <= 0) {
                showAlert('Enter a valid amount', 'warning');
                return;
            }
            const remaining = Math.max(0, dueAmount - paid);
            const history = Array.isArray(record.payment_history) ? record.payment_history : [];
            history.push({ date: new Date().toISOString().split('T')[0], amount: paid });
            let saved = false;
            if (remaining <= 0) {
                const effectiveStart = getEffectiveFeeStartDate(record);
                saved = saveFeeRecord(studentId, {
                    amount: baseAmount || null,
                    last_paid_date: new Date().toISOString().split('T')[0],
                    payment_history: history,
                    pending_amount: baseAmount || null,
                    start_date: computeFeeDueDate({ ...record, start_date: effectiveStart }) || effectiveStart
                });
                if (saved) showAlert('Full payment recorded', 'success');
            } else {
                saved = saveFeeRecord(studentId, {
                    amount: baseAmount || null,
                    payment_history: history,
                    pending_amount: remaining
                });
                if (saved) showAlert(`Partial payment recorded. Pending: ${remaining}`, 'info');
            }
            if (!saved) {
                showAlert('Unable to save fee update locally. Please run Master Update and retry.', 'warning');
                return;
            }
            await syncFeeChangeNow();
            loadFeesTab();
        }

        function loadFeesTab() {
            const statusFilter = getElementValue('feesStatusFilter') || 'active';
            const dueFilter = getElementValue('feesDueFilter') || 'all';
            const search = (getElementValue('feesSearch') || '').trim().toLowerCase();
            const monthKey = getCurrentMonthKey();
            let students = filterStudentsByStatus(db.getStudents(), statusFilter, monthKey);
            const groupFilter = getElementValue('feesGroupFilter') || 'all';
            if (groupFilter !== 'all') {
                students = students.filter(student => getStudentGroup(student) === groupFilter);
            }
            if (search) {
                students = students.filter(student => {
                    const name = (student.base_name || student.name || '').toLowerCase();
                    const roll = (student.roll || '').toLowerCase();
                    return name.includes(search) || roll.includes(search);
                });
            }

            const feeMap = getFeeRecordMap();
            let overdueCount = 0;
            let totalCollection = 0;

            const availableGroups = Array.from(new Set(
                filterStudentsByStatus(db.getStudents(), statusFilter, monthKey)
                    .map(student => getStudentGroup(student))
                    .filter(Boolean)
            )).sort((a, b) => String(a).localeCompare(String(b)));
            const groupSelect = document.getElementById('feesGroupFilter');
            if (groupSelect) {
                const selected = groupSelect.value || 'all';
                groupSelect.innerHTML = '<option value="all">All Groups</option>' +
                    availableGroups.map(group => `<option value="${group}">Group ${group}</option>`).join('');
                groupSelect.value = availableGroups.includes(selected) || selected === 'all' ? selected : 'all';
            }

            const tbody = document.getElementById('feesBody');
            if (!tbody) return;

            const rowsHtml = students.map(student => {
                const record = getFeeRecordForStudent(student.id, feeMap);
                const baseAmount = record.amount !== null && record.amount !== undefined
                    ? record.amount
                    : (Number.isFinite(Number(student.fees)) ? Number(student.fees) : '');
                const pendingAmount = Number.isFinite(Number(record.pending_amount))
                    ? Number(record.pending_amount)
                    : baseAmount;
                const startValue = getEffectiveFeeStartDate(record);
                const periodValue = record.period_months || 1;
                const dueDate = computeFeeDueDate({ ...record, start_date: startValue, period_months: periodValue });
                const overdue = isFeeOverdue({ ...record, start_date: startValue, period_months: periodValue });
                const lastPaid = record.last_paid_date ? formatDateLabel(record.last_paid_date) : '-';
                const paymentState = overdue ? 'past_due' : (record.last_paid_date ? 'paid' : 'due');
                if (dueFilter !== 'all' && dueFilter !== paymentState) {
                    return '';
                }
                const statusLabel = overdue
                    ? `<span class="fee-status fee-overdue">Past Due</span>`
                    : (record.last_paid_date ? `<span class="fee-status fee-paid">Paid</span>` : `<span class="fee-status fee-due">Due</span>`);
                const remarksValue = record.remarks ? escapeHtml(record.remarks) : '';

                if (overdue) overdueCount += 1;
                if (Array.isArray(record.payment_history) && record.payment_history.length) {
                    totalCollection += record.payment_history.reduce((sum, entry) => sum + (Number(entry.amount) || 0), 0);
                } else if (record.last_paid_date && Number.isFinite(Number(record.amount))) {
                    totalCollection += Number(record.amount);
                }

                return `
                    <tr class="${student.active === false ? 'inactive-row' : ''}">
                        <td>${formatRollDisplay(student.roll)}</td>
                        <td class="fee-name-cell">${renderStudentName(student)}</td>
                        <td>${student.class || '-'}</td>
                        <td>${getStudentGroup(student) || '-'}</td>
                        <td>
                            <input class="fee-input" type="number" min="0" step="1" data-student-id="${student.id}" data-field="amount" value="${pendingAmount}" ${currentUserRole === 'admin' ? '' : 'disabled'} onchange="handleFeeInputChange(this)">
                        </td>
                        <td>
                            <div class="fee-date-cell">
                            <input class="fee-input fee-date-input" type="date" data-student-id="${student.id}" data-field="start_date" value="${startValue}" ${currentUserRole === 'admin' ? '' : 'disabled'} onchange="handleFeeInputChange(this)">
                            <button type="button" title="Pick date" class="fee-date-picker-btn" ${currentUserRole === 'admin' ? '' : 'disabled'} onclick="openFeeDatePicker(${student.id})"><i class="fas fa-calendar-alt"></i></button>
                            <span class="fee-date-note" style="grid-column: 1 / span 2;">${startValue ? formatDateLabel(startValue) : '-'}</span>
                            </div>
                        </td>
                        <td>
                            <input class="fee-input" type="number" min="1" step="1" data-student-id="${student.id}" data-field="period_months" value="${periodValue}" ${currentUserRole === 'admin' ? '' : 'disabled'} onchange="handleFeeInputChange(this)">
                        </td>
                        <td>${dueDate ? formatDateLabel(dueDate) : '-'}</td>
                        <td>${lastPaid}</td>
                        <td>${statusLabel}</td>
                        <td>
                            <button ${currentUserRole === 'admin' ? '' : 'disabled'} onclick="markFeePaid(${student.id})">Fees Paid</button>
                            <button class="secondary" ${currentUserRole === 'admin' ? '' : 'disabled'} onclick="markFeePartialPaid(${student.id})">Fees Paid Partially</button>
                        </td>
                        <td>
                            <input type="text" data-student-id="${student.id}" data-field="remarks" value="${remarksValue}" ${currentUserRole === 'admin' ? '' : 'disabled'} onchange="handleFeeInputChange(this)">
                        </td>
                    </tr>
                `;
            }).filter(Boolean).join('');
            tbody.innerHTML = rowsHtml;
            if (rowsHtml) _animateTableRows('feesTable');

            if (!rowsHtml) {
                tbody.innerHTML = `<tr><td colspan="12" class="text-center" style="padding: 30px;">No students for selected filters</td></tr>`;
            }

            const totalEl = document.getElementById('feesTotalStudents');
            if (totalEl) totalEl.textContent = students.length;
            const overdueEl = document.getElementById('feesOverdueCount');
            if (overdueEl) overdueEl.textContent = overdueCount;
            const collectionEl = document.getElementById('feesTotalCollection');
            if (collectionEl) collectionEl.textContent = Math.round(totalCollection);

            autoAdjustTableFonts();
        }

        // ============================================
        // RESOURCES (Excel Resource Management)
        // ============================================

        function getResourceCabinet() {
            const data = db.getData() || {};
            return Array.isArray(data.resource_cabinet) ? data.resource_cabinet : [];
        }

        function getResourceRequests() {
            const data = db.getData() || {};
            return Array.isArray(data.resource_requests) ? data.resource_requests : [];
        }

        function getResourceTransactions() {
            const data = db.getData() || {};
            return Array.isArray(data.resource_transactions) ? data.resource_transactions : [];
        }

        function formatMoneyValue(value) {
            const num = Number(value);
            if (!Number.isFinite(num)) return '0';
            let out = num.toFixed(2);
            out = out.replace(/\.00$/, '').replace(/(\.\d)0$/, '$1');
            return out;
        }

        /**
         * Save resource changes to LOCAL data first, then push full data to server.
         * This prevents the bug where pushToServer(partial) + pullFromServer results in
         * a 204 (not modified) because timestamps match, leaving local data stale.
         *
         * @param {Object} patch - Object with arrays to merge, e.g.:
         *   { resource_transactions: [txnRow], resource_cabinet: [item], resource_requests: [req] }
         *   Each array item must have an `id` field.
         */
        function applyResourcePatchLocally(patch) {
            const data = db.getData();
            const tables = ['resource_transactions', 'resource_cabinet', 'resource_requests', 'resource_advantage_deductions'];
            tables.forEach(table => {
                const incoming = patch[table];
                if (!Array.isArray(incoming) || !incoming.length) return;
                if (!Array.isArray(data[table])) data[table] = [];
                incoming.forEach(row => {
                    const rowId = parseInt(row && row.id, 10) || 0;
                    if (!rowId) { data[table].push(row); return; }
                    const idx = data[table].findIndex(r => parseInt(r && r.id, 10) === rowId);
                    if (idx >= 0) {
                        data[table][idx] = { ...data[table][idx], ...row };
                    } else {
                        data[table].push(row);
                    }
                });
            });
            data.updated_at = new Date().toISOString();
            db.saveData(data, currentUserRole === 'teacher' ? { allowTeacher: true } : {});
            // Push full data to server in background
            if (SERVER_SYNC.enabled) {
                pushToServer(db.getData(), { silent: true }).catch(() => {});
            }
        }

        function findStudentByRollLocal(roll) {
            const target = normalizeRoll(roll || '');
            if (!target) return null;
            return (db.getStudents() || []).find(s => normalizeRoll(s && s.roll) === target) || null;
        }

        function getStudentAdvantageDeductions(studentId, monthKey) {
            const sid = parseInt(studentId, 10);
            const month = String(monthKey || '').trim();
            if (!sid || !month) return [];
            const data = db.getData() || {};
            const all = Array.isArray(data.resource_advantage_deductions) ? data.resource_advantage_deductions : [];
            return all.filter(d => parseInt(d.studentId, 10) === sid && String(d.month || '').trim() === month && !d.reversed);
        }

        function getStudentMonthAdvantageDeductionTotal(studentId, monthKey) {
            return getStudentAdvantageDeductions(studentId, monthKey)
                .reduce((sum, d) => sum + (parseInt(d.points_deducted, 10) || 0), 0);
        }

        function getStudentMonthTotalPoints(studentId, monthKey) {
            const sid = parseInt(studentId, 10);
            const month = String(monthKey || '').trim();
            if (!sid || !month) return 0;
            const scores = (db.getData() || {}).scores || [];
            let total = 0;
            (Array.isArray(scores) ? scores : []).forEach(row => {
                if (!row || typeof row !== 'object') return;
                if (parseInt(row.studentId, 10) !== sid) return;
                const m = String(row.month || (row.date ? String(row.date).slice(0, 7) : '') || '').trim();
                if (m !== month) return;
                total += parseInt(row.points, 10) || 0;
            });
            // Subtract protected advantage deductions (stored separately — cannot be deleted by teachers)
            total -= getStudentMonthAdvantageDeductionTotal(sid, month);
            return total;
        }

        function getStudentMonthPointsSpent(studentId, monthKey) {
            const sid = parseInt(studentId, 10);
            const month = String(monthKey || '').trim();
            if (!sid || !month) return 0;
            let spent = 0;
            getResourceTransactions().forEach(txn => {
                if (!txn || typeof txn !== 'object') return;
                if (parseInt(txn.studentId, 10) !== sid) return;
                if (String(txn.month || '').trim() !== month) return;
                if (String(txn.type || '').trim().toLowerCase() !== 'redeem_points') return;
                spent += Math.max(0, parseInt(txn.points_used, 10) || 0);
            });
            return spent;
        }

        function getStudentAvailableExcessPoints(studentId, monthKey) {
            const total = getStudentMonthTotalPoints(studentId, monthKey);
            const excess = Math.max(0, total - 500);
            const spent = getStudentMonthPointsSpent(studentId, monthKey);
            return Math.max(0, excess - spent);
        }

        function calculatePointsCostWithGst(baseAmount) {
            const amount = Number(baseAmount) || 0;
            // Points purchases attract +50% GST on the item price (points-only rule).
            return Math.max(0, Math.ceil(amount * 1.5));
        }

        function getAdminResourceRequestDate() {
            if (currentUserRole !== 'admin') return '';
            const el = document.getElementById('resourceRequestDate');
            const raw = String(el && el.value || '').trim();
            if (!/^\d{4}-\d{2}-\d{2}$/.test(raw)) return '';
            return raw;
        }

        function getAdminResourceRequestIsoOrNow() {
            const dateStr = getAdminResourceRequestDate();
            if (!dateStr) return new Date().toISOString();
            // Use ISO date prefix for stable display and consistent sorting.
            return `${dateStr}T00:00:00.000Z`;
        }

        function getResourceContextMonthKey() {
            if (currentUserRole !== 'admin') {
                return getCurrentMonthKey();
            }
            const dateStr = getAdminResourceRequestDate();
            if (dateStr) {
                const minMonth = '2025-08';
                const monthKey = dateStr.substring(0, 7);
                return monthKey < minMonth ? minMonth : monthKey;
            }
            const el = document.getElementById('resourceContextMonth');
            const raw = String(el && el.value || '').trim();
            if (/^\d{4}-\d{2}$/.test(raw)) {
                const minMonth = '2025-08';
                return raw < minMonth ? minMonth : raw;
            }
            return getCurrentMonthKey();
        }

        function getResourceContextStudent() {
            if (currentUserRole === 'student') {
                return findStudentByRollLocal(currentLoginId);
            }
            if (currentUserRole === 'admin' || currentUserRole === 'teacher') {
                const select = document.getElementById('resourceContextStudent');
                const sid = parseInt(select && select.value, 10) || 0;
                if (!sid) return null;
                return (db.getStudents() || []).find(s => parseInt(s && s.id, 10) === sid) || null;
            }
            return null;
        }

        function populateResourceContextClassOptions() {
            if (currentUserRole !== 'admin' && currentUserRole !== 'teacher') return;
            const select = document.getElementById('resourceStudentClassFilter');
            if (!select) return;
            // Hardcoded list (2–10) matching every other class filter in the app,
            // so Class 10 always appears regardless of current DB contents.
            const classes = ['2','3','4','5','6','7','8','9','10'];
            const current = String(select.value || 'all').trim();
            select.innerHTML = '<option value="all">All Classes</option>' +
                classes.map(c => `<option value="${c}">Class ${c}</option>`).join('');
            select.value = classes.includes(current) ? current : 'all';
        }

        function populateResourceContextStudents() {
            if (currentUserRole !== 'admin' && currentUserRole !== 'teacher') return;
            const select = document.getElementById('resourceContextStudent');
            if (!select) return;
            const statusFilter = String(getElementValue('resourceStudentStatusFilter') || 'active').trim().toLowerCase();
            const classFilter = String(getElementValue('resourceStudentClassFilter') || 'all').trim();
            let students = (db.getStudents() || []).slice();
            if (statusFilter === 'active') {
                students = students.filter(s => s && s.active !== false);
            } else if (statusFilter === 'inactive') {
                students = students.filter(s => s && s.active === false);
            }
            if (classFilter && classFilter !== 'all') {
                students = students.filter(s => String(s && s.class || '').trim() === classFilter);
            }
            students.sort((a, b) => {
                return String(a && a.roll || '').localeCompare(String(b && b.roll || ''));
            });
            const current = String(select.value || '').trim();
            select.innerHTML = students.map(s => {
                const sid = parseInt(s && s.id, 10) || 0;
                const roll = formatRollDisplay(s && s.roll);
                const name = String(s && (s.base_name || s.name) || '').trim();
                const label = `${name} - ${roll}`.trim();
                return `<option value="${sid}">${escapeHtml(label)}</option>`;
            }).join('');
            if (current && students.some(s => String(parseInt(s && s.id, 10) || 0) === current)) {
                select.value = current;
            }
        }

        function updateResourceContext() {
            const monthKey = getResourceContextMonthKey();
            const student = getResourceContextStudent();
            const actorLabel = document.getElementById('resourceRequestActorLabel');
            const nameBox = document.getElementById('resourceContextStudentName');
            const eligibilitySummary = document.getElementById('resourceEligibilitySummary');
            const urgentSelect = document.getElementById('resourceRequestUrgent');
            const urgent = currentUserRole === 'admin' && String(urgentSelect && urgentSelect.value || 'no').trim().toLowerCase() === 'yes';
            const currentMonth = getCurrentMonthKey();
            const requestDateEl = document.getElementById('resourceRequestDate');
            if (currentUserRole === 'admin' && requestDateEl && !requestDateEl.value) {
                requestDateEl.value = new Date().toISOString().split('T')[0];
            }
            if (currentUserRole === 'admin' && urgentSelect) {
                if (monthKey !== currentMonth) {
                    urgentSelect.value = 'no';
                    urgentSelect.disabled = true;
                } else {
                    urgentSelect.disabled = false;
                }
            }

            if (currentUserRole === 'admin') {
                const monthEl = document.getElementById('resourceContextMonth');
                if (monthEl) monthEl.value = monthKey;
            }

            if (student) {
                const roll = formatRollDisplay(student.roll);
                const name = String(student.base_name || student.name || '').trim();
                const label = `${name} (${roll})`.trim();
                if (actorLabel) {
                    actorLabel.textContent = urgent
                        ? `Urgent processing for: ${label} | Month: ${monthKey}`
                        : `Processing for: ${label} | Month: ${monthKey}`;
                }
                if (nameBox) {
                    nameBox.value = name || '-';
                }

                const total = getStudentMonthTotalPoints(student.id, monthKey);
                const excessEarned = Math.max(0, total - 500);
                const excessUsed = getStudentMonthPointsSpent(student.id, monthKey);
                const excessRemaining = Math.max(0, excessEarned - excessUsed);
                const halfCashEligible = total >= 250;
                if (eligibilitySummary) {
                    eligibilitySummary.textContent =
                        `Month ${monthKey}: total=${total}, excess=${excessEarned}, used=${excessUsed}, remaining=${excessRemaining}. ` +
                        (halfCashEligible ? 'Cash half rule eligible (>=250).' : 'Cash half rule not eligible (<250).');
                }
            } else {
                if (actorLabel) actorLabel.textContent = (currentUserRole === 'admin' || currentUserRole === 'teacher')
                    ? 'Select a student to process a request.'
                    : '';
                if (nameBox) nameBox.value = '-';
                if (eligibilitySummary) eligibilitySummary.textContent = '';
            }

            updateResourceRequestPreview();
            renderResourceEligibility();
        }

        function applyResourcesRoleUi() {
            const isAdmin = currentUserRole === 'admin';
            const isTeacher = currentUserRole === 'teacher';
            const canSelectAnyStudent = isAdmin || isTeacher;

            // Show/hide admin-only controls inside the Resources tab.
            document.querySelectorAll('#resources-tab [data-role-only="admin"]').forEach(el => {
                el.style.display = isAdmin ? '' : 'none';
            });

            // Teacher can initiate requests on behalf of any student.
            ['resourceStudentStatusFilter', 'resourceStudentClassFilter', 'resourceContextStudent', 'resourceContextStudentName'].forEach(id => {
                const input = document.getElementById(id);
                const wrapper = input ? input.closest('.control-group') : null;
                if (wrapper) wrapper.style.display = canSelectAnyStudent ? '' : 'none';
                if (input) input.disabled = !canSelectAnyStudent;
            });

            const cabinetCard = document.getElementById('resourceCabinetCard');
            if (cabinetCard) {
                cabinetCard.querySelectorAll('input, button').forEach(el => {
                    el.disabled = !isAdmin;
                });
            }

            const requestCard = document.getElementById('resourceRequestCard');
            if (requestCard) {
                const allowSubmit = currentUserRole === 'student' || currentUserRole === 'admin' || currentUserRole === 'teacher';
                requestCard.querySelectorAll('input, select, button').forEach(el => {
                    el.disabled = !allowSubmit;
                });
            }

            const transactionsCard = document.getElementById('resourceTransactionsCard');
            if (transactionsCard) {
                transactionsCard.style.display = isTeacher ? 'none' : '';
            }

            const queueFilter = document.getElementById('resourceQueueFilter');
            if (queueFilter) {
                if (currentUserRole === 'student') {
                    queueFilter.innerHTML = '<option value="mine">My Requests</option>';
                    queueFilter.value = 'mine';
                    queueFilter.disabled = true;
                } else {
                    if (queueFilter.options.length < 4) {
                        queueFilter.innerHTML = [
                            '<option value="mine">My Requests</option>',
                            '<option value="pending_teacher">Pending Teacher</option>',
                            '<option value="pending_admin">Pending Admin</option>',
                            '<option value="all">All</option>'
                        ].join('');
                    }
                    queueFilter.disabled = false;
                    const desired = isTeacher ? 'pending_teacher' : (isAdmin ? 'pending_admin' : 'mine');
                    // Always set the role-appropriate default when loading the tab,
                    // unless the user has already interacted (tracked by data attribute).
                    if (!queueFilter.dataset.userSet) {
                        queueFilter.value = desired;
                    }
                }
            }
        }

        function populateResourceRequestItems() {
            const select = document.getElementById('resourceRequestItem');
            if (!select) return;
            const items = getResourceCabinet().slice().sort((a, b) => String(a.name || '').localeCompare(String(b.name || '')));
            const current = select.value || '';
            select.innerHTML = items.length
                ? items.map(it => `<option value="${it.id}">${escapeHtml(it.name)} (${escapeHtml(it.unit || '')}) | ₹${Math.round(Number(it.price_per_unit) || 0)} | Held: ${parseInt(it.total_held, 10) || 0}</option>`).join('')
                : '<option value="">No items configured</option>';
            if (current && items.some(it => String(it.id) === String(current))) {
                select.value = current;
            }
        }

        function updateResourceRequestPreview() {
            const hintEl = document.getElementById('resourceRequestHint');
            const pointsEl = document.getElementById('resourceAvailablePoints');
            const costEl = document.getElementById('resourceEstimatedCost');
            const monthEl = document.getElementById('resourceMonthLabel');
            const monthTotalEl = document.getElementById('resourceMonthTotalPoints');
            const excessEarnedEl = document.getElementById('resourceExcessEarned');
            const excessUsedEl = document.getElementById('resourceExcessUsed');
            const vetoOn = currentUserRole === 'admin' && String(getElementValue('resourceAdminVeto') || 'off').trim().toLowerCase() === 'on';

            const monthKey = getResourceContextMonthKey();
            if (monthEl) monthEl.textContent = monthKey || '-';

            const mode = String(getElementValue('resourceRequestMode') || 'redeem_points').trim().toLowerCase();
            const itemId = parseInt(getElementValue('resourceRequestItem'), 10) || 0;
            const qty = Math.max(1, parseInt(getElementValue('resourceRequestQty'), 10) || 1);
            const cashPaid = Math.max(0, parseFloat(getElementValue('resourceRequestCashPaid')) || 0);

            const item = getResourceCabinet().find(it => parseInt(it.id, 10) === itemId);
            const price = item ? (Number(item.price_per_unit) || 0) : 0;
            const totalCashCost = Math.max(0, price * qty);
            const totalPointsCost = calculatePointsCostWithGst(totalCashCost);

            const targetStudent = getResourceContextStudent();
            let monthTotal = 0;
            let excessEarned = 0;
            let excessUsed = 0;
            let excessRemaining = 0;
            if (targetStudent) {
                monthTotal = getStudentMonthTotalPoints(targetStudent.id, monthKey);
                excessEarned = Math.max(0, monthTotal - 500);
                excessUsed = getStudentMonthPointsSpent(targetStudent.id, monthKey);
                excessRemaining = Math.max(0, excessEarned - excessUsed);
            }

            if (monthTotalEl) monthTotalEl.textContent = String(Math.round(monthTotal));
            if (excessEarnedEl) excessEarnedEl.textContent = String(Math.round(excessEarned));
            if (excessUsedEl) excessUsedEl.textContent = String(Math.round(excessUsed));
            if (pointsEl) pointsEl.textContent = mode === 'redeem_points' ? String(Math.round(excessRemaining)) : '-';
            if (costEl) {
                costEl.textContent = mode === 'redeem_points'
                    ? String(Math.round(totalPointsCost))
                    : String(Math.round(totalCashCost));
            }

            const lines = [];
            if (!targetStudent) {
                lines.push(currentUserRole === 'admin' ? 'Select a student to process a request.' : 'Student profile not found.');
            }
            if (!itemId) {
                lines.push('Select an item from the cabinet.');
            } else if (item && (parseInt(item.total_held, 10) || 0) < qty) {
                lines.push('Not enough stock held for this quantity.');
            }
            if (mode === 'redeem_points') {
                lines.push('Redeem uses only the selected month excess above 500.');
                lines.push(`Points cost includes +50% GST: ${Math.round(totalPointsCost)} points.`);
                if (targetStudent && totalPointsCost > excessRemaining) {
                    lines.push(`Insufficient excess points (need ${Math.round(totalPointsCost)}, remaining ${Math.round(excessRemaining)}).` + (vetoOn ? ' Admin Veto ON: allowed.' : ''));
                }
            } else {
                const pricing = computeResourceCashPricing(totalCashCost, monthTotal);
                const charged = pricing.charged;
                const due = Math.max(0, charged - cashPaid);
                if (costEl) costEl.textContent = String(Math.round(charged));
                const bal = computeResourceCashBalance(charged, cashPaid);
                const pendOrRet = bal.pending > 0 ? `Pending ₹${Math.round(bal.pending)}` : (bal.return_due > 0 ? `Return ₹${Math.round(bal.return_due)}` : 'Settled');
                lines.push(`Cash charged: ₹${Math.round(charged)}${pricing.eligibleHalf ? ' (half-price rule)' : ''}. ${pendOrRet}.`);
                if (targetStudent) {
                    lines.push(pricing.eligibleHalf ? 'Student crossed 250+ points in this month.' : 'Student is below 250 points in this month.');
                }
            }
            if (hintEl) hintEl.textContent = lines.join(' ');
        }

        function clearResourceRequestForm() {
            const modeEl = document.getElementById('resourceRequestMode');
            const itemEl = document.getElementById('resourceRequestItem');
            const qtyEl = document.getElementById('resourceRequestQty');
            const cashEl = document.getElementById('resourceRequestCashPaid');
            const urgentEl = document.getElementById('resourceRequestUrgent');
            const vetoEl = document.getElementById('resourceAdminVeto');

            if (modeEl) modeEl.value = 'redeem_points';
            if (qtyEl) qtyEl.value = '1';
            if (cashEl) cashEl.value = '0';
            if (urgentEl) urgentEl.value = 'no';
            if (vetoEl) vetoEl.value = 'off';
            if (itemEl && itemEl.options && itemEl.options.length > 0) {
                itemEl.selectedIndex = 0;
            }

            updateResourceContext();
            updateResourceRequestPreview();
            showAlert('Request form cleared', 'info');
        }

        function renderResourceEligibility() {
            const tbody = document.getElementById('resourceEligibilityBody');
            if (!tbody) return;

            const monthKey = getResourceContextMonthKey();
            const student = getResourceContextStudent();
            if (!student) {
                tbody.innerHTML = `<tr><td colspan="8" class="text-center" style="padding: 22px;">Select a student to view eligibility</td></tr>`;
                return;
            }

            const items = getResourceCabinet().slice().sort((a, b) => String(a.name || '').localeCompare(String(b.name || '')));
            if (!items.length) {
                tbody.innerHTML = `<tr><td colspan="8" class="text-center" style="padding: 22px;">No cabinet items</td></tr>`;
                return;
            }

            const monthTotal = getStudentMonthTotalPoints(student.id, monthKey);
            const excessRemaining = getStudentAvailableExcessPoints(student.id, monthKey);
            const cashHalfEligible = monthTotal >= 250;

            tbody.innerHTML = items.map(it => {
                const held = parseInt(it.total_held, 10) || 0;
                const price = Number(it.price_per_unit) || 0;
                const pointsCost = calculatePointsCostWithGst(price);
                const redeemOk = held > 0 && excessRemaining >= pointsCost && pointsCost > 0;
                const cashFull = Math.round(price);
                const cashHalf = Math.ceil(price / 2);
                return `
                    <tr>
                        <td>${escapeHtml(String(it.name || '').trim())}</td>
                        <td>${escapeHtml(String(it.unit || '').trim() || '-')}</td>
                        <td>${held}</td>
                        <td>₹${cashFull}</td>
                        <td>${pointsCost}</td>
                        <td>${redeemOk ? '<span class=\"fee-status fee-paid\">YES</span>' : '<span class=\"fee-status fee-due\">NO</span>'}</td>
                        <td>₹${cashFull}</td>
                        <td>${cashHalfEligible ? `₹${cashHalf}` : '-'}</td>
                    </tr>
                `;
            }).join('');
        }

        function renderResourceCabinet() {
            const tbody = document.getElementById('resourceCabinetBody');
            if (!tbody) return;
            const isAdmin = currentUserRole === 'admin';
            const rows = getResourceCabinet().slice().sort((a, b) => (parseInt(a.id, 10) || 0) - (parseInt(b.id, 10) || 0));
            if (!rows.length) {
                tbody.innerHTML = `<tr><td colspan="6" class="text-center" style="padding: 22px;">No cabinet items yet</td></tr>`;
                return;
            }
            tbody.innerHTML = rows.map(it => {
                const action = isAdmin
                    ? `<button class="secondary" onclick="editResourceCabinetItem(${parseInt(it.id, 10) || 0})"><i class="fas fa-pen"></i> Edit</button>`
                    : `<span style="color: var(--text-muted); font-size: 12px;">Read-only</span>`;
                return `
                    <tr>
                        <td>${parseInt(it.id, 10) || '-'}</td>
                        <td>${escapeHtml(String(it.name || '').trim())}</td>
                        <td>${escapeHtml(String(it.unit || '').trim() || '-')}</td>
                        <td>${formatMoneyValue(it.price_per_unit)}</td>
                        <td>${parseInt(it.total_held, 10) || 0}</td>
                        <td>${action}</td>
                    </tr>
                `;
            }).join('');
        }

        function editResourceCabinetItem(id) {
            if (currentUserRole !== 'admin') return;
            const itemId = parseInt(id, 10) || 0;
            const item = getResourceCabinet().find(it => parseInt(it.id, 10) === itemId);
            if (!item) return;
            editingResourceItemId = itemId;
            const nameEl = document.getElementById('resourceItemName');
            const unitEl = document.getElementById('resourceItemUnit');
            const priceEl = document.getElementById('resourceItemPrice');
            const heldEl = document.getElementById('resourceItemHeld');
            if (nameEl) nameEl.value = String(item.name || '').trim();
            if (unitEl) unitEl.value = String(item.unit || '').trim();
            if (priceEl) priceEl.value = String(formatMoneyValue(item.price_per_unit));
            if (heldEl) heldEl.value = String(parseInt(item.total_held, 10) || 0);
        }

        async function saveResourceCabinetItem() {
            if (currentUserRole !== 'admin') {
                showAlert('Only Admin can update the resource cabinet.', 'warning');
                return;
            }
            const name = String(getElementValue('resourceItemName') || '').trim();
            const unit = String(getElementValue('resourceItemUnit') || '').trim();
            const price = Math.max(0, parseFloat(getElementValue('resourceItemPrice')) || 0);
            const held = Math.max(0, parseInt(getElementValue('resourceItemHeld'), 10) || 0);
            if (!name) {
                showAlert('Enter item name', 'warning');
                return;
            }
            const nowIso = new Date().toISOString();
            const data = db.getData();
            data.resource_cabinet = Array.isArray(data.resource_cabinet) ? data.resource_cabinet : [];

            let item = null;
            if (editingResourceItemId) {
                item = data.resource_cabinet.find(it => parseInt(it.id, 10) === parseInt(editingResourceItemId, 10));
            }
            if (!item) {
                const match = data.resource_cabinet.find(it => String(it.name || '').trim().toLowerCase() === name.toLowerCase());
                if (match) item = match;
            }

            if (item) {
                item.name = name;
                item.unit = unit;
                item.price_per_unit = price;
                item.total_held = held;
                item.updated_at = nowIso;
                if (!item.created_at) item.created_at = nowIso;
            } else {
                const nextId = Date.now();
                data.resource_cabinet.push({
                    id: nextId,
                    name,
                    unit,
                    price_per_unit: price,
                    total_held: held,
                    created_at: nowIso,
                    updated_at: nowIso
                });
            }
            editingResourceItemId = null;
            db.saveData(data);
            populateResourceRequestItems();
            renderResourceCabinet();

            if (SERVER_SYNC.enabled) {
                pushToServer(db.getData(), { silent: true }).catch(() => {});
            }
            showAlert('Resource cabinet updated', 'success');
        }

        function renderResourceRequests() {
            const tbody = document.getElementById('resourceRequestsBody');
            if (!tbody) return;
            _showTableSkeleton('resourceRequestsBody', 12, 3);
            const filter = String(getElementValue('resourceQueueFilter') || 'mine').trim().toLowerCase();
            const all = getResourceRequests().slice();
            const rollKey = normalizeRoll(currentLoginId || '');
            const isTeacher = currentUserRole === 'teacher';
            const isAdmin = currentUserRole === 'admin';

            const visible = all.filter(req => {
                const status = String(req && req.status || '').trim().toLowerCase();
                if (filter === 'mine') {
                    if (currentUserRole === 'student') {
                        return normalizeRoll(req && req.student_roll || '') === rollKey;
                    }
                    return true;
                }
                if (filter === 'pending_teacher') return status === 'pending_teacher';
                if (filter === 'pending_admin') return status === 'pending_admin';
                return true;
            }).sort((a, b) => {
                const ar = resourceStatusRank(a && a.status);
                const br = resourceStatusRank(b && b.status);
                if (br !== ar) return br - ar;
                return parseSyncStamp((b && (b.updated_at || b.created_at)) || '') - parseSyncStamp((a && (a.updated_at || a.created_at)) || '');
            });

            if (!visible.length) {
                tbody.innerHTML = `<tr><td colspan="12" class="text-center" style="padding: 22px;">No requests</td></tr>`;
                return;
            }

            const studentById = new Map((db.getStudents() || []).map(s => [parseInt(s.id, 10), s]));
            tbody.innerHTML = visible.map(req => {
                const rid = parseInt(req && req.id, 10) || 0;
                const sid = parseInt(req && req.studentId, 10) || 0;
                const student = sid ? studentById.get(sid) : null;
                const roll = String((req && req.student_roll) || (student && student.roll) || '').trim();
                const studentName = student ? renderStudentName(student, (req && req.month) || getCurrentMonthKey()) : escapeHtml(String((req && (req.student_name || req.studentName)) || ''));
                const mode = String(req && req.type || '').trim().toLowerCase();
                const qty = Math.max(1, parseInt(req && req.qty, 10) || 1);
                const cost = Math.round(Number(req && req.total_cost) || 0);
                const adminVeto = Boolean(req && req.admin_veto) || String(req && req.admin_veto || '').trim().toLowerCase() === 'true';
                const pointsCost = mode === 'redeem_points'
                    ? (Math.max(0, parseInt(req && req.points_cost, 10) || 0) || calculatePointsCostWithGst(cost))
                    : 0;
                const costLabel = mode === 'redeem_points' ? `${pointsCost} pts` : `₹${cost}`;
                const status = String(req && req.status || '').trim().toLowerCase() || 'pending_teacher';
                const statusLabel = status.replace(/_/g, ' ').toUpperCase();
                const modeLabel = adminVeto ? `${mode} (VETO)` : mode;
                const requestedDate = req && req.created_at ? formatDateLabel(String(req.created_at).slice(0, 10)) : '-';
                const approvedDate = (req && (req.approved_at || req.admin_approved_at)) ? formatDateLabel(String(req.approved_at || req.admin_approved_at).slice(0, 10)) : '-';

                let actionHtml = `<span style="color: var(--text-muted); font-size: 12px;">-</span>`;
                if ((isTeacher || isAdmin) && status === 'pending_teacher') {
                    actionHtml = `
                        <input id="resourceTeacherRemark-${rid}" type="text" placeholder="Remark..." style="width: 180px; margin-right: 6px;">
                        <button class="secondary" onclick="teacherDecideResourceRequest(${rid}, 'recommended')">Recommend</button>
                        <button class="danger" onclick="teacherDecideResourceRequest(${rid}, 'not_recommended')">Not</button>
                    `;
                } else if (isAdmin && (status === 'pending_admin' || status === 'pending_teacher' || status === 'not_recommended')) {
                    actionHtml = `
                        <input id="resourceAdminRemark-${rid}" type="text" placeholder="Admin remark..." style="width: 180px; margin-right: 6px;">
                        <button onclick="adminApproveResourceRequest(${rid}, this)">Approve</button>
                        <button class="danger" onclick="adminRejectResourceRequest(${rid}, this)">Reject</button>
                    `;
                } else if (status === 'approved' || status === 'fulfilled') {
                    actionHtml = `<span style="color: var(--text-muted); font-size: 12px;">Approved</span>`;
                } else if (status === 'rejected') {
                    actionHtml = `<span style="color: var(--text-muted); font-size: 12px;">Rejected</span>`;
                } else if (status === 'not_recommended') {
                    actionHtml = `<span style="color: var(--text-muted); font-size: 12px;">Not recommended</span>`;
                }

                return `
                    <tr>
                        <td>${rid || '-'}</td>
                        <td>${escapeHtml(String(req && req.month || ''))}</td>
                        <td>${escapeHtml(requestedDate)}</td>
                        <td>${escapeHtml(approvedDate)}</td>
                        <td>${escapeHtml(modeLabel || '-')}</td>
                        <td>${studentName || '-'}</td>
                        <td>${escapeHtml(formatRollDisplay(roll))}</td>
                        <td>${escapeHtml(String(req && (req.item_name || req.item) || ''))}</td>
                        <td>${qty}</td>
                        <td>${escapeHtml(costLabel)}</td>
                        <td>${escapeHtml(statusLabel)}</td>
                        <td>${actionHtml}</td>
                    </tr>
                `;
            }).join('');
        }

        function populateResourceTransactionFilters() {
            const select = document.getElementById('resourceTransactionsStudentFilter');
            if (!select) return;
            const prev = String(select.value || 'all');
            const txns = getResourceTransactions() || [];
            const studentById = new Map((db.getStudents() || []).map(s => [parseInt(s.id, 10), s]));
            const seen = new Set();
            const options = [{ value: 'all', label: 'All Students' }];

            txns.forEach(txn => {
                const sid = parseInt(txn && txn.studentId, 10) || 0;
                const student = sid ? studentById.get(sid) : null;
                const roll = String((txn && txn.student_roll) || (student && student.roll) || '').trim();
                const name = String((txn && (txn.student_name || txn.studentName)) || (student && (student.base_name || student.name)) || '').trim();
                let value = '';
                if (sid > 0) value = `id:${sid}`;
                else if (roll) value = `roll:${normalizeRoll(roll)}`;
                if (!value || seen.has(value)) return;
                seen.add(value);
                const label = `${name || 'Unknown'}${roll ? ` (${formatRollDisplay(roll)})` : ''}`;
                options.push({ value, label });
            });

            options.sort((a, b) => {
                if (a.value === 'all') return -1;
                if (b.value === 'all') return 1;
                return String(a.label || '').localeCompare(String(b.label || ''));
            });
            select.innerHTML = options.map(opt => `<option value="${escapeHtml(opt.value)}">${escapeHtml(opt.label)}</option>`).join('');
            select.value = options.some(opt => opt.value === prev) ? prev : 'all';
        }

        function renderResourceTransactions() {
            const tbody = document.getElementById('resourceTransactionsBody');
            if (!tbody) return;
            populateResourceTransactionFilters();
            _showTableSkeleton('resourceTransactionsBody', 12, 3);
            const filter = String(getElementValue('resourceTransactionsFilter') || 'all').trim().toLowerCase();
            const studentFilterRaw = String(getElementValue('resourceTransactionsStudentFilter') || 'all').trim();
            const studentFilter = studentFilterRaw.toLowerCase();
            const dateFilter = String(getElementValue('resourceTransactionsDateFilter') || '').trim();
            const monthFilter = String(getElementValue('resourceTransactionsMonthFilter') || '').trim();
            let rows = getResourceTransactions().slice().sort((a, b) => parseSyncStamp((b && (b.created_at || b.updated_at)) || '') - parseSyncStamp((a && (a.created_at || a.updated_at)) || ''));

            const isCompleted = (txn) => {
                if (txn && txn.pending_settlement) return false;
                const mode = String(txn && txn.type || '').trim().toLowerCase();
                if (mode === 'redeem_points') return true;
                if (mode !== 'cash_purchase') return true;
                const cashPaid = Math.max(0, parseFloat(txn && txn.cash_paid) || 0);
                const charged = Math.max(0, parseFloat(txn && txn.cash_charged) || 0) || Math.max(0, parseFloat(txn && txn.total_cost) || 0);
                const bal = computeResourceCashBalance(charged, cashPaid);
                const pendingRaw = parseFloat(txn && txn.cash_due);
                const returnRaw = parseFloat(txn && txn.cash_return_due);
                const pending = Math.max(0, Number.isFinite(pendingRaw) ? pendingRaw : bal.pending);
                const ret = Math.max(0, Number.isFinite(returnRaw) ? returnRaw : bal.return_due);
                return pending <= 0 && ret <= 0;
            };

            if (filter === 'completed') {
                rows = rows.filter(isCompleted);
            } else if (filter === 'not_completed') {
                rows = rows.filter(txn => !isCompleted(txn));
            }

            const studentById = new Map((db.getStudents() || []).map(s => [parseInt(s.id, 10), s]));
            if (studentFilter && studentFilter !== 'all') {
                rows = rows.filter(txn => {
                    const sid = parseInt(txn && txn.studentId, 10) || 0;
                    const student = sid ? studentById.get(sid) : null;
                    const roll = normalizeRoll((txn && txn.student_roll) || (student && student.roll) || '');
                    if (studentFilter.startsWith('id:')) {
                        const targetId = parseInt(studentFilter.slice(3), 10) || 0;
                        return targetId > 0 && sid === targetId;
                    }
                    if (studentFilter.startsWith('roll:')) {
                        const targetRoll = normalizeRoll(studentFilter.slice(5));
                        return !!targetRoll && roll === targetRoll;
                    }
                    return false;
                });
            }
            if (dateFilter) {
                rows = rows.filter(txn => {
                    const raw = String((txn && (txn.created_at || txn.updated_at)) || '').trim();
                    return raw && raw.slice(0, 10) === dateFilter;
                });
            }
            if (monthFilter) {
                rows = rows.filter(txn => {
                    const explicitMonth = String(txn && txn.month || '').trim();
                    if (explicitMonth) return explicitMonth === monthFilter;
                    const raw = String((txn && (txn.created_at || txn.updated_at)) || '').trim();
                    return raw && raw.slice(0, 7) === monthFilter;
                });
            }
            if (currentUserRole === 'student') {
                const rollKey = normalizeRoll(currentLoginId || '');
                rows = rows.filter(txn => {
                    const sid = parseInt(txn && txn.studentId, 10) || 0;
                    const student = sid ? studentById.get(sid) : null;
                    const roll = String((txn && txn.student_roll) || (student && student.roll) || '').trim();
                    return normalizeRoll(roll) === rollKey;
                });
            }

            const updateSelectedStudentPendingSummary = (filteredRows, studentMap) => {
                const summaryEl = document.getElementById('resourceTxnStudentPendingSummary');
                if (!summaryEl) return;
                if (!studentFilter || studentFilter === 'all') {
                    summaryEl.style.display = 'none';
                    summaryEl.textContent = '';
                    return;
                }
                let totalPending = 0;
                let matchedTxns = 0;
                let studentLabel = 'Selected Student';
                filteredRows.forEach(txn => {
                    const mode = String(txn && txn.type || '').trim().toLowerCase();
                    if (mode !== 'cash_purchase') return;
                    const sid = parseInt(txn && txn.studentId, 10) || 0;
                    const student = sid ? studentMap.get(sid) : null;
                    if (student && !studentLabel.includes('(')) {
                        const roll = String(student.roll || '').trim();
                        const name = String(student.base_name || student.name || '').trim();
                        studentLabel = `${name || 'Selected Student'}${roll ? ` (${formatRollDisplay(roll)})` : ''}`;
                    }
                    const cashPaid = Math.max(0, parseFloat(txn && txn.cash_paid) || 0);
                    const cashCharged = Math.max(0, parseFloat(txn && txn.cash_charged) || 0);
                    const fallbackCharged = Math.max(0, parseFloat(txn && txn.total_cost) || 0);
                    const charged = cashCharged || fallbackCharged;
                    if (!charged) return;
                    const bal = computeResourceCashBalance(charged, cashPaid);
                    const cashDueRaw = parseFloat(txn && txn.cash_due);
                    const due = Math.max(0, Number.isFinite(cashDueRaw) ? cashDueRaw : bal.pending);
                    if (due > 0) {
                        totalPending += due;
                        matchedTxns += 1;
                    }
                });
                summaryEl.style.display = '';
                summaryEl.innerHTML = `<strong>${escapeHtml(studentLabel)}</strong> pending amount: <strong style="color:#fca5a5;">Rs ${escapeHtml(formatMoneyValue(totalPending))}</strong> <span style="color:var(--text-muted);">(from ${matchedTxns} pending transaction${matchedTxns === 1 ? '' : 's'})</span>`;
            };
            updateSelectedStudentPendingSummary(rows, studentById);

            if (!rows.length) {
                tbody.innerHTML = `<tr><td colspan="12" class="text-center" style="padding: 22px;">No transactions</td></tr>`;
                renderResourceSettlementSummary([]);
                return;
            }
            tbody.innerHTML = rows.map(txn => {
                const id = parseInt(txn && txn.id, 10) || 0;
                const sid = parseInt(txn && txn.studentId, 10) || 0;
                const student = sid ? studentById.get(sid) : null;
                const roll = String((txn && txn.student_roll) || (student && student.roll) || '').trim();
                const studentName = student ? renderStudentName(student, (txn && txn.month) || getCurrentMonthKey()) : escapeHtml(String((txn && (txn.student_name || txn.studentName)) || ''));
                const mode = String(txn && txn.type || '').trim().toLowerCase();
                const qty = Math.max(1, parseInt(txn && txn.qty, 10) || 1);
                const points = Math.max(0, parseInt(txn && txn.points_used, 10) || 0);
                const cashPaid = Math.max(0, parseFloat(txn && txn.cash_paid) || 0);
                const cashCharged = Math.max(0, parseFloat(txn && txn.cash_charged) || 0);
                const fallbackCharged = Math.max(0, parseFloat(txn && txn.total_cost) || 0);
                const charged = cashCharged || (mode === 'cash_purchase' ? fallbackCharged : 0);
                const bal = computeResourceCashBalance(charged, cashPaid);
                const cashDueRaw = parseFloat(txn && txn.cash_due);
                const cashReturnRaw = parseFloat(txn && txn.cash_return_due);
                const cashDue = Math.max(0, Number.isFinite(cashDueRaw) ? cashDueRaw : bal.pending);
                const cashReturnDue = Math.max(0, Number.isFinite(cashReturnRaw) ? cashReturnRaw : bal.return_due);
                const cashLabel = mode === 'cash_purchase' && charged
                    ? `₹${Math.round(cashPaid)} of ₹${Math.round(charged)}${cashDue > 0 ? ` (Due ₹${Math.round(cashDue)})` : ' (Paid)'}`
                    : '-';
                const pendRetLabel = mode === 'cash_purchase' && charged
                    ? (cashDue > 0 ? `Pending ₹${Math.round(cashDue)}` : (cashReturnDue > 0 ? `Return ₹${Math.round(cashReturnDue)}` : (txn && txn.pending_settlement ? 'Pending Settlement' : 'Settled')))
                    : (txn && txn.pending_settlement ? 'Pending Settlement' : '-');
                const created = txn && txn.created_at ? formatDateLabel(String(txn.created_at).slice(0, 10)) : '-';
                const advPtsDed = Math.max(0, parseInt(txn && txn.advantage_points_deducted, 10) || 0);
                // Check if this transaction's advantage deduction is already reversed
                const advDeductionRecord = advPtsDed > 0
                    ? (db.getData().resource_advantage_deductions || []).find(d => parseInt(d.transaction_id, 10) === id)
                    : null;
                const advAlreadyReversed = advDeductionRecord && advDeductionRecord.reversed;

                let action = `<span style="color: var(--text-muted); font-size: 12px;">-</span>`;
                const actionParts = [];
                if (currentUserRole === 'admin' && id && ((txn && txn.pending_settlement) || (mode === 'cash_purchase' && (cashDue > 0 || cashReturnDue > 0)))) {
                    actionParts.push(`<button class="secondary" onclick="adminSettleResourceTransaction(${id})">Settle</button>`);
                }
                if (currentUserRole === 'admin' && advPtsDed > 0 && !advAlreadyReversed) {
                    actionParts.push(`<button class="secondary" style="border-color:rgba(251,191,36,0.5);color:#fbbf24;font-size:11px;padding:3px 8px;margin-top:4px" onclick="adminReverseAdvantageDeduction(${id})" title="Reverse the ${advPtsDed}-point advantage deduction for this transaction">↩ Reverse Adv (${advPtsDed}pts)</button>`);
                }
                if (advAlreadyReversed) {
                    actionParts.push(`<span style="font-size:11px;color:#64748b">Adv reversed</span>`);
                }
                if (actionParts.length) action = actionParts.join('<br>');

                const rowClass = isCompleted(txn) ? 'txn-row-complete' : 'txn-row-open';
                const advBadge = advPtsDed > 0 ? `<span style="font-size:10px;background:rgba(120,53,15,0.5);border:1px solid rgba(251,191,36,0.3);color:#fcd34d;padding:1px 5px;border-radius:4px;margin-left:4px" title="Half-price advantage used">−${advPtsDed}pts</span>` : '';
                return `
                    <tr class="${rowClass}">
                        <td>${id || '-'}</td>
                        <td>${escapeHtml(String(txn && txn.month || ''))}</td>
                        <td>${escapeHtml(mode || '-')}</td>
                        <td>${studentName || '-'}</td>
                        <td>${escapeHtml(formatRollDisplay(roll))}</td>
                        <td>${escapeHtml(String(txn && (txn.item_name || txn.item) || ''))}${advBadge}</td>
                        <td>${qty}</td>
                        <td>${points || '-'}</td>
                        <td>${escapeHtml(cashLabel)}</td>
                        <td>${escapeHtml(pendRetLabel)}</td>
                        <td>${escapeHtml(created)}</td>
                        <td>${action}</td>
                    </tr>
                `;
            }).join('');
            _animateTableRows('resourceTransactionsTable');
        }

        async function adminReverseAdvantageDeduction(transactionId) {
            if (currentUserRole !== 'admin') return;
            const txnId = parseInt(transactionId, 10) || 0;
            if (!txnId) return;
            const data = db.getData();
            const deductions = Array.isArray(data.resource_advantage_deductions) ? data.resource_advantage_deductions : [];
            const ded = deductions.find(d => parseInt(d.transaction_id, 10) === txnId && !d.reversed);
            if (!ded) { showAlert('No active advantage deduction found for this transaction.', 'warning'); return; }

            const studentById = new Map((db.getStudents() || []).map(s => [parseInt(s.id, 10), s]));
            const student = studentById.get(parseInt(ded.studentId, 10));
            const studentName = student ? String(student.base_name || student.name || '').trim() : '(unknown)';
            const roll = student ? formatRollDisplay(student.roll) : formatRollDisplay(String(ded.student_roll || ''));

            const confirmed = await openConfirmModal('Reverse Advantage Deduction',
                `<div class="confirm-details">
                    <div class="row"><div class="k">Student</div><div class="v">${escapeHtml(studentName)} (${escapeHtml(roll)})</div></div>
                    <div class="row"><div class="k">Month</div><div class="v">${escapeHtml(ded.month || '-')}</div></div>
                    <div class="row"><div class="k">Item</div><div class="v">${escapeHtml(ded.item_name || '-')} ×${ded.qty || 1}</div></div>
                    <div class="row"><div class="k" style="color:#fbbf24">Points to Restore</div><div class="v" style="color:#4ade80;font-weight:700">+${ded.points_deducted} pts</div></div>
                    <p style="margin-top:10px;font-size:12px;color:#94a3b8">This will permanently mark the deduction as reversed and restore the points to the student's monthly tally. The transaction record will not be changed.</p>
                </div>`
            );
            if (!confirmed) return;

            pushUndoSnapshot('Reverse advantage deduction');
            const nowIso = new Date().toISOString();
            const idx = deductions.findIndex(d => parseInt(d.transaction_id, 10) === txnId && !d.reversed);
            if (idx < 0) { showAlert('Deduction already reversed or not found.', 'warning'); return; }
            data.resource_advantage_deductions[idx] = {
                ...data.resource_advantage_deductions[idx],
                reversed: true,
                reversed_at: nowIso,
                reversed_by: String(currentLoginId || 'Admin').trim()
            };
            db.saveData(data);
            if (SERVER_SYNC.enabled) pushToServer(db.getData(), { silent: true }).catch(() => {});
            renderResourceTransactions();
            showAlert(`Advantage deduction reversed — ${ded.points_deducted} pts restored to ${studentName}'s tally.`, 'success');
        }

        function computeResourceCashPricing(totalCashCost, monthTotalPoints) {
            const full = Math.max(0, Math.round(Number(totalCashCost) || 0));
            const total = Math.max(0, parseInt(monthTotalPoints, 10) || 0);
            const eligibleHalf = total >= 250;
            const charged = eligibleHalf ? Math.ceil(full / 2) : full;
            return {
                full,
                eligibleHalf,
                charged: Math.max(0, Math.round(charged)),
                rule: eligibleHalf ? 'half_250' : 'full'
            };
        }

        function computeResourceCashBalance(cashCharged, cashPaid) {
            const charged = Math.max(0, Math.round(Number(cashCharged) || 0));
            const paid = Math.max(0, Math.round(Number(cashPaid) || 0));
            const delta = paid - charged; // + = return due, - = pending due
            const pending = Math.max(0, charged - paid);
            const ret = Math.max(0, paid - charged);
            return { charged, paid, delta, pending, return_due: ret };
        }

        async function adminQuickCashPurchase(kind) {
            if (currentUserRole !== 'admin') return;
            const action = String(kind || '').trim().toLowerCase();
            if (!['full_paid', 'half_paid', 'due'].includes(action)) {
                showAlert('Invalid cash action', 'warning');
                return;
            }

            const monthKey = getResourceContextMonthKey();
            const currentMonth = getCurrentMonthKey();
            if (monthKey !== currentMonth) {
                showAlert('Quick purchases are only allowed for the current month.', 'warning');
                return;
            }

            const student = getResourceContextStudent();
            if (!student) {
                showAlert('Select a student to process a purchase.', 'warning');
                return;
            }

            const itemId = parseInt(getElementValue('resourceRequestItem'), 10) || 0;
            const qty = Math.max(1, parseInt(getElementValue('resourceRequestQty'), 10) || 1);
            if (!itemId) {
                showAlert('Select an item', 'warning');
                return;
            }
            const item = getResourceCabinet().find(it => parseInt(it.id, 10) === itemId);
            if (!item) {
                showAlert('Item not found in cabinet', 'warning');
                return;
            }
            if ((parseInt(item.total_held, 10) || 0) < qty) {
                showAlert('Not enough stock held for this quantity', 'warning');
                return;
            }

            const monthTotal = getStudentMonthTotalPoints(student.id, monthKey);
            const totalCashCost = Math.max(0, (Number(item.price_per_unit) || 0) * qty);
            const pricing = computeResourceCashPricing(totalCashCost, monthTotal);

            let charged = pricing.charged;
            let pricingRule = pricing.rule;
            if (action === 'full_paid') {
                charged = pricing.full;
                pricingRule = 'full';
            } else if (action === 'half_paid') {
                if (!pricing.eligibleHalf) {
                    showAlert('Half-price rule not eligible (student below 250 points this month).', 'warning');
                    return;
                }
                charged = pricing.charged;
                pricingRule = 'half_250';
            }

            const cashPaid = action === 'due' ? 0 : charged;
            const cashDue = action === 'due' ? charged : 0;
            const cashReturnDue = 0;
            const actionLabel = action === 'due' ? 'Emergency Due' : (action === 'half_paid' ? 'Cash Half Paid' : 'Cash Full Paid');
            const roll = formatRollDisplay(student.roll);
            const studentName = String(student.base_name || student.name || '').trim();
            const confirmed = await openConfirmModal('Confirm Transaction', `
                <div class="confirm-details">
                    <div class="row"><div class="k">Student</div><div class="v">${escapeHtml(studentName)} (${escapeHtml(roll)})</div></div>
                    <div class="row"><div class="k">Month</div><div class="v">${escapeHtml(monthKey)}</div></div>
                    <div class="row"><div class="k">Mode</div><div class="v">cash_purchase</div></div>
                    <div class="row"><div class="k">Item</div><div class="v">${escapeHtml(String(item.name || '').trim())} x${qty}</div></div>
                    <div class="row"><div class="k">Cash Charged</div><div class="v">₹${Math.round(charged)}</div></div>
                    <div class="row"><div class="k">Cash Paid Now</div><div class="v">₹${Math.round(cashPaid)}</div></div>
                    <div class="row"><div class="k">Pending</div><div class="v">₹${Math.round(cashDue)}</div></div>
                </div>
            `);
            if (!confirmed) {
                return;
            }

            const nowIso = new Date().toISOString();
            const cabinetItem = (db.getData().resource_cabinet || []).find(it => parseInt(it.id, 10) === itemId) || { ...item };
            if ((parseInt(cabinetItem.total_held, 10) || 0) < qty) {
                showAlert('Not enough stock held (cabinet changed). Refresh and retry.', 'warning');
                return;
            }
            cabinetItem.total_held = Math.max(0, (parseInt(cabinetItem.total_held, 10) || 0) - qty);
            cabinetItem.updated_at = nowIso;
            if (!cabinetItem.created_at) cabinetItem.created_at = nowIso;

            const txnRow = {
                id: Date.now() + Math.floor(Math.random() * 1000),
                request_id: 0,
                month: monthKey,
                type: 'cash_purchase',
                studentId: parseInt(student.id, 10),
                student_roll: normalizeRoll(student.roll),
                item_id: itemId,
                item_name: String(item.name || '').trim(),
                unit: String(item.unit || '').trim(),
                qty,
                price_per_unit: Number(item.price_per_unit) || 0,
                total_cost: pricing.full,
                cash_pricing_rule: pricingRule,
                cash_charged: charged,
                cash_paid: cashPaid,
                cash_due: cashDue,
                cash_return_due: cashReturnDue,
                note: action === 'due' ? 'Emergency purchase (cash due)' : (pricingRule === 'half_250' ? 'Cash purchase (half-price)' : 'Cash purchase (full)'),
                created_at: nowIso,
                updated_at: nowIso,
                created_by_login_id: String(currentLoginId || 'Admin').trim()
            };

            applyResourcePatchLocally({ resource_cabinet: [cabinetItem], resource_transactions: [txnRow] });
            loadResourcesTab();
            showAlert(action === 'due' ? 'Emergency purchase recorded (cash due)' : 'Cash purchase recorded', 'success');
        }

        async function adminSettleResourceTransaction(txnId) {
            if (currentUserRole !== 'admin') return;
            const id = parseInt(txnId, 10) || 0;
            if (!id) return;
            const txn = getResourceTransactions().find(t => parseInt(t && t.id, 10) === id) || null;
            if (!txn) {
                showAlert('Transaction not found. Refresh.', 'warning');
                return;
            }
            const mode = String(txn.type || '').trim().toLowerCase();
            const isPendingSettlement = !!(txn && txn.pending_settlement);

            // Guard: only settleable transactions are pending_settlement ones or cash_purchase with outstanding amounts
            if (!isPendingSettlement && mode !== 'cash_purchase') {
                showAlert('Only cash purchases or pending-settlement transactions can be settled.', 'info');
                return;
            }

            const cashPaid = Math.max(0, parseFloat(txn.cash_paid) || 0);
            const charged = mode === 'cash_purchase'
                ? (Math.max(0, parseFloat(txn.cash_charged) || 0) || Math.max(0, parseFloat(txn.total_cost) || 0))
                : 0;
            const bal = mode === 'cash_purchase' ? computeResourceCashBalance(charged, cashPaid) : { pending: 0, return_due: 0 };
            const cashDueRaw = parseFloat(txn.cash_due);
            const cashReturnRaw = parseFloat(txn.cash_return_due);
            const cashDue = mode === 'cash_purchase' ? Math.max(0, Number.isFinite(cashDueRaw) ? cashDueRaw : bal.pending) : 0;
            const cashReturn = mode === 'cash_purchase' ? Math.max(0, Number.isFinite(cashReturnRaw) ? cashReturnRaw : bal.return_due) : 0;

            if (!isPendingSettlement && cashDue <= 0 && cashReturn <= 0) {
                showAlert('No pending/return amount for this transaction.', 'info');
                return;
            }

            let confirmHtml;
            if (mode === 'redeem_points') {
                const points = Math.max(0, parseInt(txn.points_used, 10) || 0);
                confirmHtml = `
                    <div class="confirm-details">
                        <div class="row"><div class="k">Txn</div><div class="v">#${id}</div></div>
                        <div class="row"><div class="k">Mode</div><div class="v">Redeem Points</div></div>
                        <div class="row"><div class="k">Item</div><div class="v">${escapeHtml(String(txn.item_name || ''))}</div></div>
                        <div class="row"><div class="k">Qty</div><div class="v">${Math.max(1, parseInt(txn.qty, 10) || 1)}</div></div>
                        <div class="row"><div class="k">Points Used</div><div class="v">${points}</div></div>
                    </div>
                    <p style="margin-top: 10px; color: var(--text-muted);">Confirm that the item has been delivered and this transaction is complete.</p>
                `;
            } else {
                confirmHtml = `
                    <div class="confirm-details">
                        <div class="row"><div class="k">Txn</div><div class="v">#${id}</div></div>
                        <div class="row"><div class="k">Charged</div><div class="v">₹${Math.round(charged)}</div></div>
                        <div class="row"><div class="k">Paid</div><div class="v">₹${Math.round(cashPaid)}</div></div>
                        <div class="row"><div class="k">Pending</div><div class="v">₹${Math.round(cashDue)}</div></div>
                        <div class="row"><div class="k">Return</div><div class="v">₹${Math.round(cashReturn)}</div></div>
                    </div>
                    <p style="margin-top: 10px; color: var(--text-muted);">Confirm will settle this transaction (pending paid and/or return given).</p>
                `;
            }

            const confirmed = await openConfirmModal('Settle Transaction', confirmHtml);
            if (!confirmed) return;

            const nowIso = new Date().toISOString();
            const updatedTxn = {
                ...txn,
                pending_settlement: false,
                settled_at: nowIso,
                settled_by_login_id: String(currentLoginId || 'Admin').trim(),
                updated_at: nowIso
            };
            if (mode === 'cash_purchase') {
                updatedTxn.cash_paid = cashPaid + cashDue - cashReturn;
                updatedTxn.cash_due = 0;
                updatedTxn.cash_return = Math.max(0, parseFloat(txn.cash_return) || 0) + cashReturn;
                updatedTxn.cash_return_due = 0;
            }
            applyResourcePatchLocally({ resource_transactions: [updatedTxn] });
            renderResourceTransactions();
            showAlert('Transaction settled successfully!', 'success');
        }

        async function adminManualRedeem(redeemRemaining) {
            if (currentUserRole !== 'admin') return;
            const monthKey = getResourceContextMonthKey();
            const currentMonth = getCurrentMonthKey();
            if (monthKey > currentMonth) {
                showAlert('Cannot redeem points for a future month.', 'warning');
                return;
            }
            const student = getResourceContextStudent();
            if (!student) {
                showAlert('Select a student first.', 'warning');
                return;
            }

            const remaining = getStudentAvailableExcessPoints(student.id, monthKey);
            const requested = redeemRemaining
                ? remaining
                : Math.max(0, parseInt(getElementValue('resourceManualRedeemPoints'), 10) || 0);
            if (!requested) {
                showAlert('Enter points to redeem.', 'warning');
                return;
            }
            if (remaining <= 0) {
                showAlert('No remaining excess points for the selected month.', 'info');
                return;
            }
            let points = requested;
            if (points > remaining) {
                if (!confirm(`Only ${Math.round(remaining)} excess points are remaining for ${monthKey}. Redeem remaining instead?`)) {
                    return;
                }
                points = remaining;
            }

            const remark = String(getElementValue('resourceManualRedeemRemark') || '').trim();
            if (!confirm(`Manual redeem ${Math.round(points)} points for ${String(student.base_name || student.name || '').trim()} (${formatRollDisplay(student.roll)}) in ${monthKey}?`)) {
                return;
            }

            const nowIso = new Date().toISOString();
            const txnRow = {
                id: Date.now() + Math.floor(Math.random() * 1000),
                request_id: 0,
                month: monthKey,
                type: 'redeem_points',
                manual: true,
                studentId: parseInt(student.id, 10),
                student_roll: normalizeRoll(student.roll),
                item_id: 0,
                item_name: 'Manual Redeem',
                unit: '',
                qty: 1,
                price_per_unit: 0,
                total_cost: 0,
                points_used: Math.max(0, Math.round(points)),
                note: remark || 'Manual redeem (offline)',
                created_at: nowIso,
                updated_at: nowIso,
                created_by_login_id: String(currentLoginId || 'Admin').trim()
            };

            applyResourcePatchLocally({ resource_transactions: [txnRow] });
            const pointsEl = document.getElementById('resourceManualRedeemPoints');
            const remarkEl = document.getElementById('resourceManualRedeemRemark');
            if (pointsEl) pointsEl.value = '0';
            if (remarkEl) remarkEl.value = '';
            updateResourceContext();
            renderResourceTransactions();
            showAlert('Manual redeem recorded', 'success');
        }

        async function submitResourceRequest() {
            const mode = String(getElementValue('resourceRequestMode') || 'redeem_points').trim().toLowerCase();
            const itemId = parseInt(getElementValue('resourceRequestItem'), 10) || 0;
            const qty = Math.max(1, parseInt(getElementValue('resourceRequestQty'), 10) || 1);
            let cashPaid = Math.max(0, parseFloat(getElementValue('resourceRequestCashPaid')) || 0);
            const urgentSelect = document.getElementById('resourceRequestUrgent');
            const urgent = currentUserRole === 'admin' && String(urgentSelect && urgentSelect.value || 'no').trim().toLowerCase() === 'yes';
            const adminVeto = currentUserRole === 'admin' && String(getElementValue('resourceAdminVeto') || 'off').trim().toLowerCase() === 'on';

            if (currentUserRole !== 'student' && currentUserRole !== 'admin' && currentUserRole !== 'teacher') {
                showAlert('Only Student, Teacher, or Admin can submit requests.', 'warning');
                return;
            }
            if (!itemId) {
                showAlert('Select an item', 'warning');
                return;
            }
            const item = getResourceCabinet().find(it => parseInt(it.id, 10) === itemId);
            if (!item) {
                showAlert('Item not found in cabinet', 'warning');
                return;
            }
            if ((parseInt(item.total_held, 10) || 0) < qty) {
                showAlert('Not enough stock held for this quantity', 'warning');
                return;
            }

            const monthKey = getResourceContextMonthKey();
            const totalCashCost = Math.max(0, (Number(item.price_per_unit) || 0) * qty);
            const totalPointsCost = calculatePointsCostWithGst(totalCashCost);

            const student = getResourceContextStudent();
            if (!student) {
                showAlert('Select a student to process this request.', 'warning');
                return;
            }

            if (mode === 'redeem_points') {
                const available = getStudentAvailableExcessPoints(student.id, monthKey);
                if (totalPointsCost > available) {
                    if (!adminVeto) {
                        showAlert('Insufficient excess points for this request', 'warning');
                        return;
                    }
                }
            }

            const currentMonth = getCurrentMonthKey();
            const nowIso = currentUserRole === 'admin' ? getAdminResourceRequestIsoOrNow() : new Date().toISOString();

            if (currentUserRole === 'admin' && urgent) {
                // Admin urgent: create a request that goes straight to pending_admin (so it appears in Requests first).
                const reqId = Date.now();
                const monthTotal = getStudentMonthTotalPoints(student.id, monthKey);
                const cashPricing = computeResourceCashPricing(totalCashCost, monthTotal);
                const charged = mode === 'cash_purchase' ? cashPricing.charged : 0;
                const bal = mode === 'cash_purchase' ? computeResourceCashBalance(charged, cashPaid) : null;
                const confirmHtml = `
                    <div class="confirm-details">
                        <div class="row"><div class="k">Student</div><div class="v">${escapeHtml(String(student.base_name || student.name || '').trim())} (${escapeHtml(formatRollDisplay(student.roll))})</div></div>
                        <div class="row"><div class="k">Month</div><div class="v">${escapeHtml(monthKey)}</div></div>
                        <div class="row"><div class="k">Mode</div><div class="v">${escapeHtml(mode)}</div></div>
                        <div class="row"><div class="k">Item</div><div class="v">${escapeHtml(String(item.name || '').trim())} x${qty}</div></div>
                        ${mode === 'redeem_points'
                            ? `<div class="row"><div class="k">Points Cost (GST+50%)</div><div class="v">${Math.round(totalPointsCost)} pts</div></div>`
                            : `<div class="row"><div class="k">Cash Charged</div><div class="v">₹${Math.round(charged)}</div></div>
                               <div class="row"><div class="k">Payment</div><div class="v" style="display:flex;flex-direction:column;gap:6px;padding-top:2px;">
                                 <label style="cursor:pointer;display:flex;align-items:center;gap:6px;"><input type="radio" name="cashPayOption" value="full"> Full Paid — ₹${Math.round(charged)}</label>
                                 <label style="cursor:pointer;display:flex;align-items:center;gap:6px;"><input type="radio" name="cashPayOption" value="half"> Half Paid — ₹${Math.round(charged / 2)}</label>
                                 <label style="cursor:pointer;display:flex;align-items:center;gap:6px;"><input type="radio" name="cashPayOption" value="custom" checked> Custom — ₹${Math.round(cashPaid)}</label>
                               </div></div>`
                        }
                        <div class="row"><div class="k">Urgent</div><div class="v">YES</div></div>
                        <div class="row"><div class="k">Admin Veto</div><div class="v">${adminVeto ? 'ON' : 'OFF'}</div></div>
                    </div>
                    <p style="margin-top: 10px; color: var(--text-muted);">This will add an urgent request to the Requests Queue. Approve it below to create the transaction.</p>
                `;
                const confirmed = await openConfirmModal('Submit Urgent Request', confirmHtml);
                if (!confirmed) return;
                if (mode === 'cash_purchase') {
                    const _payOpt = document.querySelector('#confirmBody input[name="cashPayOption"]:checked');
                    if (_payOpt && _payOpt.value === 'full') cashPaid = Math.round(charged);
                    else if (_payOpt && _payOpt.value === 'half') cashPaid = Math.round(charged / 2);
                }

                const reqRow = {
                    id: reqId,
                    type: mode,
                    studentId: parseInt(student.id, 10),
                    student_roll: normalizeRoll(student.roll),
                    month: monthKey,
                    item_id: itemId,
                    item_name: String(item.name || '').trim(),
                    unit: String(item.unit || '').trim(),
                    qty,
                    price_per_unit: Number(item.price_per_unit) || 0,
                    total_cost: totalCashCost,
                    points_cost: mode === 'redeem_points' ? totalPointsCost : 0,
                    cash_paid: mode === 'cash_purchase' ? cashPaid : 0,
                    urgent: true,
                    admin_veto: adminVeto,
                    status: 'pending_admin',
                    admin_remark: 'Urgent admin-initiated (needs approval)',
                    created_at: nowIso,
                    updated_at: nowIso
                };

                applyResourcePatchLocally({ resource_requests: [reqRow] });
                loadResourcesTab();
                showAlert('Urgent request added to queue. Approve it below to record the transaction.', 'success');
                return;
            }

            if (currentUserRole === 'admin') {
                // Admin normal request: create a complete request row (pending_teacher) so merges stay consistent.
                const monthTotal = getStudentMonthTotalPoints(student.id, monthKey);
                const cashPricing = computeResourceCashPricing(totalCashCost, monthTotal);
                const charged = mode === 'cash_purchase' ? cashPricing.charged : 0;
                const bal = mode === 'cash_purchase' ? computeResourceCashBalance(charged, cashPaid) : null;
                const confirmHtml = `
                    <div class="confirm-details">
                        <div class="row"><div class="k">Student</div><div class="v">${escapeHtml(String(student.base_name || student.name || '').trim())} (${escapeHtml(formatRollDisplay(student.roll))})</div></div>
                        <div class="row"><div class="k">Month</div><div class="v">${escapeHtml(monthKey)}</div></div>
                        <div class="row"><div class="k">Mode</div><div class="v">${escapeHtml(mode)}</div></div>
                        <div class="row"><div class="k">Item</div><div class="v">${escapeHtml(String(item.name || '').trim())} x${qty}</div></div>
                        ${mode === 'redeem_points'
                            ? `<div class="row"><div class="k">Points Cost (GST+50%)</div><div class="v">${Math.round(totalPointsCost)} pts</div></div>`
                            : `<div class="row"><div class="k">Cash Charged</div><div class="v">₹${Math.round(charged)}</div></div>
                               <div class="row"><div class="k">Payment</div><div class="v" style="display:flex;flex-direction:column;gap:6px;padding-top:2px;">
                                 <label style="cursor:pointer;display:flex;align-items:center;gap:6px;"><input type="radio" name="cashPayOption" value="full"> Full Paid — ₹${Math.round(charged)}</label>
                                 <label style="cursor:pointer;display:flex;align-items:center;gap:6px;"><input type="radio" name="cashPayOption" value="half"> Half Paid — ₹${Math.round(charged / 2)}</label>
                                 <label style="cursor:pointer;display:flex;align-items:center;gap:6px;"><input type="radio" name="cashPayOption" value="custom" checked> Custom — ₹${Math.round(cashPaid)}</label>
                               </div></div>`
                        }
                        <div class="row"><div class="k">Admin Veto</div><div class="v">${adminVeto ? 'ON' : 'OFF'}</div></div>
                    </div>
                `;
                const confirmed = await openConfirmModal('Submit Request', confirmHtml);
                if (!confirmed) return;
                if (mode === 'cash_purchase') {
                    const _payOpt = document.querySelector('#confirmBody input[name="cashPayOption"]:checked');
                    if (_payOpt && _payOpt.value === 'full') cashPaid = Math.round(charged);
                    else if (_payOpt && _payOpt.value === 'half') cashPaid = Math.round(charged / 2);
                }
                const isBackdated = monthKey !== currentMonth;
                const reqRow = {
                    id: Date.now(),
                    type: mode,
                    studentId: parseInt(student.id, 10),
                    student_roll: normalizeRoll(student.roll),
                    month: monthKey,
                    item_id: itemId,
                    item_name: String(item.name || '').trim(),
                    unit: String(item.unit || '').trim(),
                    qty,
                    price_per_unit: Number(item.price_per_unit) || 0,
                    total_cost: totalCashCost,
                    points_cost: mode === 'redeem_points' ? totalPointsCost : 0,
                    cash_paid: mode === 'cash_purchase' ? cashPaid : 0,
                    urgent: false,
                    admin_veto: adminVeto,
                    status: isBackdated ? 'pending_admin' : 'pending_teacher',
                    admin_remark: isBackdated ? 'Backdated admin entry (approval needed)' : '',
                    created_at: nowIso,
                    updated_at: nowIso
                };
                applyResourcePatchLocally({ resource_requests: [reqRow] });
                loadResourcesTab();
                showAlert(isBackdated ? 'Backdated request added to queue. Approve it below to record the transaction.' : 'Request submitted to teacher for recommendation', 'success');
                return;
            }

            if (currentUserRole === 'teacher') {
                const monthTotal = getStudentMonthTotalPoints(student.id, monthKey);
                const cashPricing = computeResourceCashPricing(totalCashCost, monthTotal);
                const charged = mode === 'cash_purchase' ? cashPricing.charged : 0;
                const confirmHtml = `
                    <div class="confirm-details">
                        <div class="row"><div class="k">Student</div><div class="v">${escapeHtml(String(student.base_name || student.name || '').trim())} (${escapeHtml(formatRollDisplay(student.roll))})</div></div>
                        <div class="row"><div class="k">Month</div><div class="v">${escapeHtml(monthKey)}</div></div>
                        <div class="row"><div class="k">Mode</div><div class="v">${escapeHtml(mode)}</div></div>
                        <div class="row"><div class="k">Item</div><div class="v">${escapeHtml(String(item.name || '').trim())} x${qty}</div></div>
                        ${mode === 'redeem_points'
                            ? `<div class="row"><div class="k">Points Cost (GST+50%)</div><div class="v">${Math.round(totalPointsCost)} pts</div></div>`
                            : `<div class="row"><div class="k">Cash Charged</div><div class="v">₹${Math.round(charged)}</div></div>
                               <div class="row"><div class="k">Cash Paid</div><div class="v">₹${Math.round(cashPaid)}</div></div>`
                        }
                    </div>
                    <p style="margin-top: 10px; color: var(--text-muted);">This request will enter <strong>Pending Teacher</strong>. You can then recommend it to Admin from the Requests Queue.</p>
                `;
                const confirmed = await openConfirmModal('Submit Teacher Request', confirmHtml);
                if (!confirmed) return;
                const reqRow = {
                    id: Date.now(),
                    type: mode,
                    studentId: parseInt(student.id, 10),
                    student_roll: normalizeRoll(student.roll),
                    month: monthKey,
                    item_id: itemId,
                    item_name: String(item.name || '').trim(),
                    unit: String(item.unit || '').trim(),
                    qty,
                    price_per_unit: Number(item.price_per_unit) || 0,
                    total_cost: totalCashCost,
                    points_cost: mode === 'redeem_points' ? totalPointsCost : 0,
                    cash_paid: mode === 'cash_purchase' ? cashPaid : 0,
                    urgent: false,
                    admin_veto: false,
                    status: 'pending_teacher',
                    requested_by_login_id: String(currentLoginId || 'Teacher').trim(),
                    requested_by_role: 'teacher',
                    created_at: nowIso,
                    updated_at: nowIso
                };
                applyResourcePatchLocally({ resource_requests: [reqRow] });
                loadResourcesTab();
                showAlert('Teacher request added to queue. Recommend it to forward to Admin.', 'success');
                return;
            }

            // Student normal request: server will validate & build canonical row for the logged-in student.
            {
                const monthTotal = getStudentMonthTotalPoints(student.id, monthKey);
                const cashPricing = computeResourceCashPricing(totalCashCost, monthTotal);
                const charged = mode === 'cash_purchase' ? cashPricing.charged : 0;
                const bal = mode === 'cash_purchase' ? computeResourceCashBalance(charged, cashPaid) : null;
                const confirmHtml = `
                    <div class="confirm-details">
                        <div class="row"><div class="k">Student</div><div class="v">${escapeHtml(String(student.base_name || student.name || '').trim())} (${escapeHtml(formatRollDisplay(student.roll))})</div></div>
                        <div class="row"><div class="k">Month</div><div class="v">${escapeHtml(monthKey)}</div></div>
                        <div class="row"><div class="k">Mode</div><div class="v">${escapeHtml(mode)}</div></div>
                        <div class="row"><div class="k">Item</div><div class="v">${escapeHtml(String(item.name || '').trim())} x${qty}</div></div>
                        ${mode === 'redeem_points'
                            ? `<div class="row"><div class="k">Points Cost (GST+50%)</div><div class="v">${Math.round(totalPointsCost)} pts</div></div>`
                            : `<div class="row"><div class="k">Cash Charged</div><div class="v">₹${Math.round(charged)}</div></div>
                               <div class="row"><div class="k">Payment</div><div class="v" style="display:flex;flex-direction:column;gap:6px;padding-top:2px;">
                                 <label style="cursor:pointer;display:flex;align-items:center;gap:6px;"><input type="radio" name="cashPayOption" value="full"> Full Paid — ₹${Math.round(charged)}</label>
                                 <label style="cursor:pointer;display:flex;align-items:center;gap:6px;"><input type="radio" name="cashPayOption" value="half"> Half Paid — ₹${Math.round(charged / 2)}</label>
                                 <label style="cursor:pointer;display:flex;align-items:center;gap:6px;"><input type="radio" name="cashPayOption" value="custom" checked> Custom — ₹${Math.round(cashPaid)}</label>
                               </div></div>`
                        }
                    </div>
                `;
                const confirmed = await openConfirmModal('Submit Request', confirmHtml);
                if (!confirmed) return;
                if (mode === 'cash_purchase') {
                    const _payOpt = document.querySelector('#confirmBody input[name="cashPayOption"]:checked');
                    if (_payOpt && _payOpt.value === 'full') cashPaid = Math.round(charged);
                    else if (_payOpt && _payOpt.value === 'half') cashPaid = Math.round(charged / 2);
                }
            }

            const patch = {
                resource_requests: [{
                    id: Date.now(),
                    type: mode,
                    item_id: itemId,
                    qty,
                    cash_paid: mode === 'cash_purchase' ? cashPaid : 0
                }]
            };
            try {
                const resp = await fetchWithTimeout(SERVER_SYNC.dataUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    credentials: 'include',
                    body: JSON.stringify({ data: patch, peers: getSyncBaseUrls() })
                }, 4500);
                if (resp.status === 401 || resp.status === 403) {
                    showAlert('Please re-login on this device.', 'warning');
                    return;
                }
                if (!resp.ok) {
                    showAlert('Request submit failed. Try Master Update.', 'warning');
                    return;
                }
            } catch (err) {
                showAlert('Request submit failed (offline). Try Master Update.', 'warning');
                return;
            }

            await pullFromServer(false);
            loadResourcesTab();
            showAlert('Request submitted to teacher for recommendation', 'success');
        }

        async function teacherDecideResourceRequest(requestId, decision) {
            if (currentUserRole !== 'teacher' && currentUserRole !== 'admin') return;
            const rid = parseInt(requestId, 10) || 0;
            if (!rid) return;
            const remark = String(getElementValue(`resourceTeacherRemark-${rid}`) || '').trim();
            const patch = {
                resource_requests: [{
                    id: rid,
                    teacher_decision: String(decision || '').trim().toLowerCase(),
                    teacher_remark: remark
                }]
            };
            await pushToServer(patch, { silent: true, allowPatch: true });
            await pullFromServer(false);
            renderResourceRequests();
            showAlert('Teacher decision saved', 'success');
        }

        // INR ↔ Points conversion rate (must match calculatePointsCostWithGst factor = 1.5)
        const _ADVANTAGE_POINTS_PER_INR = 1.5;

        function _calcAdvantagePointsDeducted(inrSaved) {
            return Math.max(0, Math.round(inrSaved * _ADVANTAGE_POINTS_PER_INR));
        }

        async function adminApproveResourceRequest(requestId, _triggerBtn) {
            if (currentUserRole !== 'admin') return;
            const rid = parseInt(requestId, 10) || 0;
            if (!rid) return;
            const _restoreApproveBtn = _btnSetLoading(_triggerBtn);
            const req = getResourceRequests().find(r => parseInt(r && r.id, 10) === rid) || null;
            if (!req) { _restoreApproveBtn(); return; }

            const nowIso = new Date().toISOString();
            const remark = String(getElementValue(`resourceAdminRemark-${rid}`) || '').trim();
            const qty = Math.max(1, parseInt(req.qty, 10) || 1);
            const itemId = parseInt(req.item_id, 10) || 0;
            const cabinetItem = getResourceCabinet().find(it => parseInt(it.id, 10) === itemId);
            if (!cabinetItem) { showAlert('Cabinet item missing. Refresh.', 'warning'); _restoreApproveBtn(); return; }
            if ((parseInt(cabinetItem.total_held, 10) || 0) < qty) { showAlert('Not enough stock held. Update cabinet first.', 'warning'); _restoreApproveBtn(); return; }

            const mode = String(req.type || '').trim().toLowerCase();
            const monthKey = String(req.month || getCurrentMonthKey()).trim();
            const studentId = parseInt(req.studentId, 10) || 0;
            const totalCashCost = Math.max(0, Number(req.total_cost) || 0);
            const totalPointsCost = calculatePointsCostWithGst(totalCashCost);
            const adminVeto = Boolean(req.admin_veto) || String(req.admin_veto || '').trim().toLowerCase() === 'true';

            if (mode === 'redeem_points') {
                const available = getStudentAvailableExcessPoints(studentId, monthKey);
                if (totalPointsCost > available) {
                    if (!adminVeto) { showAlert('Insufficient excess points at approval time.', 'warning'); _restoreApproveBtn(); return; }
                }
            }

            const student = (db.getStudents() || []).find(s => parseInt(s && s.id, 10) === studentId) || null;
            const studentName = student ? String(student.base_name || student.name || '').trim() : '';
            const roll = student ? formatRollDisplay(student.roll) : formatRollDisplay(String(req.student_roll || '').trim());
            const cashPaid = Math.max(0, parseFloat(req.cash_paid) || 0);

            // Compute BEFORE advantage deductions affect the total (use raw month total for eligibility check)
            const rawMonthTotal = (() => {
                const scores = (db.getData() || {}).scores || [];
                let t = 0;
                scores.forEach(row => {
                    if (parseInt(row.studentId, 10) !== studentId) return;
                    const m = String(row.month || (row.date ? String(row.date).slice(0, 7) : '') || '').trim();
                    if (m !== monthKey) return;
                    t += parseInt(row.points, 10) || 0;
                });
                return t;
            })();
            const cashPricing = computeResourceCashPricing(totalCashCost, rawMonthTotal);

            // ── Half-price advantage dialog (cash_purchase + eligible) ─────────────
            let useAdvantage = false;   // admin's decision
            let advantagePointsDeducted = 0;
            let finalCashPricingRule = cashPricing.rule;
            let charged = mode === 'cash_purchase' ? cashPricing.charged : 0;

            if (mode === 'cash_purchase' && cashPricing.eligibleHalf) {
                const inrSaved   = cashPricing.full - cashPricing.charged;   // = full / 2
                const ptsDeduce  = _calcAdvantagePointsDeducted(inrSaved);
                const currentPts = getStudentMonthTotalPoints(studentId, monthKey);
                const ptsAfter   = currentPts - ptsDeduce;
                const willLoseEligibility = ptsAfter < 250;

                const advHtml = `
                <div style="text-align:center;margin-bottom:14px">
                    <div style="font-size:13px;color:#94a3b8;margin-bottom:6px">Student</div>
                    <div style="font-size:18px;font-weight:700;color:#e2e8f0">${escapeHtml(studentName || '-')} <span style="color:#64748b;font-size:14px">(${escapeHtml(roll)})</span></div>
                    <div style="font-size:13px;color:#64748b;margin-top:2px">${escapeHtml(monthKey)} &nbsp;·&nbsp; ${escapeHtml(String(req.item_name||'').trim())} ×${qty}</div>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px;margin-bottom:14px">
                    <div style="background:rgba(15,23,42,0.7);border:1px solid rgba(148,163,184,0.2);border-radius:10px;padding:12px;text-align:center">
                        <div style="font-size:11px;color:#64748b;text-transform:uppercase;letter-spacing:.8px;margin-bottom:4px">Full Price</div>
                        <div style="font-size:22px;font-weight:800;color:#e2e8f0">₹${cashPricing.full}</div>
                    </div>
                    <div style="background:rgba(5,46,22,0.5);border:1px solid rgba(34,197,94,0.35);border-radius:10px;padding:12px;text-align:center">
                        <div style="font-size:11px;color:#64748b;text-transform:uppercase;letter-spacing:.8px;margin-bottom:4px">Half Price</div>
                        <div style="font-size:22px;font-weight:800;color:#4ade80">₹${cashPricing.charged}</div>
                    </div>
                </div>
                <div style="background:rgba(120,53,15,0.4);border:1px solid rgba(251,191,36,0.4);border-radius:12px;padding:14px 16px;margin-bottom:14px;text-align:center">
                    <div style="font-size:12px;color:#fcd34d;text-transform:uppercase;letter-spacing:.8px;margin-bottom:6px">⚠ Points Deduction if Advantage Used</div>
                    <div style="font-size:28px;font-weight:900;color:#fbbf24">−${ptsDeduce} pts</div>
                    <div style="font-size:12px;color:#92400e;margin-top:4px">₹${inrSaved} saved × 1.5 = ${ptsDeduce} points</div>
                    <div style="font-size:12px;color:#94a3b8;margin-top:8px">
                        Current tally: <strong style="color:#e2e8f0">${currentPts} pts</strong>
                        &nbsp;→&nbsp;
                        After deduction: <strong style="color:${ptsAfter < 0 ? '#f87171' : ptsAfter < 250 ? '#fbbf24' : '#4ade80'}">${ptsAfter} pts</strong>
                    </div>
                    ${willLoseEligibility ? `<div style="margin-top:8px;font-size:11px;padding:6px 10px;background:rgba(239,68,68,0.15);border:1px solid rgba(239,68,68,0.3);border-radius:6px;color:#fca5a5">This will drop the student below 250 pts — they'll lose half-price eligibility for this month.</div>` : ''}
                </div>
                <div style="background:rgba(15,23,42,0.5);border:1px solid rgba(148,163,184,0.15);border-radius:8px;padding:10px 14px;font-size:12px;color:#64748b;margin-bottom:14px">
                    <strong style="color:#94a3b8">INR ↔ Points rate:</strong> ₹1 = 1.5 pts &nbsp;|&nbsp; ₹${inrSaved} saved → ${ptsDeduce} pts deducted<br>
                    <span style="color:#475569">Deduction is stored securely — cannot be deleted by teachers.</span>
                </div>
                <div style="display:grid;grid-template-columns:1fr 1fr;gap:10px">
                    <button onclick="document.getElementById('_advChoice').value='advantage';document.getElementById('_advChoice').dispatchEvent(new Event('change'))"
                        style="padding:12px;border-radius:10px;border:2px solid #22c55e;background:rgba(5,46,22,0.6);color:#4ade80;font-weight:700;cursor:pointer;font-size:14px">
                        ✓ Use Half-Price<br><span style="font-size:11px;font-weight:400;color:#86efac">Pay ₹${cashPricing.charged} · Deduct ${ptsDeduce} pts</span>
                    </button>
                    <button onclick="document.getElementById('_advChoice').value='full';document.getElementById('_advChoice').dispatchEvent(new Event('change'))"
                        style="padding:12px;border-radius:10px;border:2px solid #64748b;background:rgba(15,23,42,0.6);color:#94a3b8;font-weight:700;cursor:pointer;font-size:14px">
                        Pay Full Price<br><span style="font-size:11px;font-weight:400;color:#64748b">Pay ₹${cashPricing.full} · No pts deducted</span>
                    </button>
                </div>
                <input type="hidden" id="_advChoice" value="">`;

                // Show modal and wait for a choice from the two buttons
                const choice = await new Promise(resolve => {
                    const modal = document.getElementById('detailsModal');
                    const modalBody = document.getElementById('modalBody');
                    const titleEl = modal && modal.querySelector('.modal-header h2');
                    if (!modal || !modalBody) { resolve(null); return; }
                    if (titleEl) titleEl.textContent = 'Half-Price Advantage';
                    modalBody.innerHTML = advHtml;
                    openModal('detailsModal');
                    const inp = document.getElementById('_advChoice');
                    const onChoice = () => {
                        inp.removeEventListener('change', onChoice);
                        closeModal('detailsModal');
                        resolve(inp.value || null);
                    };
                    inp.addEventListener('change', onChoice);
                    // Also resolve on modal close (cancel = opt out entirely)
                    const onClose = () => {
                        modal.removeEventListener('_modalClosed', onClose);
                        inp.removeEventListener('change', onChoice);
                        resolve(null);
                    };
                    modal.addEventListener('_modalClosed', onClose);
                });

                if (!choice) { _restoreApproveBtn(); return; }   // cancelled
                if (choice === 'advantage') {
                    useAdvantage = true;
                    advantagePointsDeducted = ptsDeduce;
                    finalCashPricingRule = 'half_250';
                    charged = cashPricing.charged;
                } else {
                    useAdvantage = false;
                    finalCashPricingRule = 'full_override';
                    charged = cashPricing.full;
                }
            }
            // ─────────────────────────────────────────────────────────────────────

            // Standard confirmation summary
            const balFinal = mode === 'cash_purchase' ? computeResourceCashBalance(charged, cashPaid) : null;
            const cashDue = mode === 'cash_purchase' ? Math.max(0, balFinal.pending) : 0;
            const cashReturnDue = mode === 'cash_purchase' ? Math.max(0, balFinal.return_due) : 0;

            const confirmHtml = `
                <div class="confirm-details">
                    <div class="row"><div class="k">Student</div><div class="v">${escapeHtml(studentName || '-')} (${escapeHtml(roll)})</div></div>
                    <div class="row"><div class="k">Month</div><div class="v">${escapeHtml(monthKey)}</div></div>
                    <div class="row"><div class="k">Item</div><div class="v">${escapeHtml(String(req.item_name||'').trim())} ×${qty}</div></div>
                    ${mode === 'redeem_points'
                        ? `<div class="row"><div class="k">Points Used</div><div class="v">${Math.round(totalPointsCost)} pts</div></div>`
                        : `<div class="row"><div class="k">Cash Charged</div><div class="v">₹${Math.round(charged)}${useAdvantage ? ' <span style="color:#4ade80">(half-price)</span>' : ''}</div></div>
                           <div class="row"><div class="k">Cash Paid</div><div class="v">₹${Math.round(cashPaid)}</div></div>
                           <div class="row"><div class="k">Pending</div><div class="v">₹${Math.round(cashDue)}</div></div>
                           <div class="row"><div class="k">Return</div><div class="v">₹${Math.round(cashReturnDue)}</div></div>
                           ${useAdvantage ? `<div class="row"><div class="k" style="color:#fbbf24">Pts Deducted</div><div class="v" style="color:#fbbf24;font-weight:700">−${advantagePointsDeducted} pts</div></div>` : ''}`
                    }
                    <div class="row"><div class="k">Admin Veto</div><div class="v">${adminVeto ? 'ON' : 'OFF'}</div></div>
                </div>`;
            const confirmed = await openConfirmModal('Confirm Approval', confirmHtml);
            if (!confirmed) { _restoreApproveBtn(); return; }

            pushUndoSnapshot('Approve resource request');

            const updatedReq = { ...req, status: 'approved', admin_decision: 'approved', admin_remark: remark, approved_at: nowIso, approved_by_login_id: String(currentLoginId || 'Admin').trim(), updated_at: nowIso };
            const updatedCabinet = { ...cabinetItem, total_held: Math.max(0, (parseInt(cabinetItem.total_held, 10) || 0) - qty), updated_at: nowIso };

            const txnId = Date.now();
            const txnRow = {
                id: txnId,
                request_id: rid,
                month: monthKey,
                type: mode,
                studentId,
                student_roll: String(req.student_roll || '').trim(),
                item_id: itemId,
                item_name: String(req.item_name || '').trim(),
                unit: String(req.unit || '').trim(),
                qty,
                price_per_unit: Number(req.price_per_unit) || 0,
                total_cost: Number(req.total_cost) || 0,
                points_used: mode === 'redeem_points' ? totalPointsCost : 0,
                cash_pricing_rule: mode === 'cash_purchase' ? finalCashPricingRule : '',
                cash_charged: mode === 'cash_purchase' ? charged : 0,
                cash_paid: mode === 'cash_purchase' ? cashPaid : 0,
                cash_due: cashDue,
                cash_return_due: cashReturnDue,
                admin_veto: adminVeto,
                advantage_points_deducted: useAdvantage ? advantagePointsDeducted : 0,
                pending_settlement: true,
                created_at: nowIso,
                updated_at: nowIso,
                created_by_login_id: String(currentLoginId || 'Admin').trim()
            };

            const patch = { resource_requests: [updatedReq], resource_cabinet: [updatedCabinet], resource_transactions: [txnRow] };

            // If advantage used, add protected deduction record
            if (useAdvantage && advantagePointsDeducted > 0) {
                patch.resource_advantage_deductions = [{
                    id: txnId + 1,
                    studentId,
                    student_roll: String(req.student_roll || '').trim(),
                    month: monthKey,
                    points_deducted: advantagePointsDeducted,
                    transaction_id: txnId,
                    item_name: String(req.item_name || '').trim(),
                    qty,
                    inr_saved: cashPricing.full - cashPricing.charged,
                    created_at: nowIso,
                    created_by_login_id: String(currentLoginId || 'Admin').trim(),
                    reversed: false,
                    reversed_at: '',
                    reversed_by: ''
                }];
            }

            applyResourcePatchLocally(patch);
            _restoreApproveBtn();
            loadResourcesTab();
            showAlert(`Request approved${useAdvantage ? ` — ${advantagePointsDeducted} pts deducted for half-price advantage` : ''}`, 'success');
        }

        async function adminRejectResourceRequest(requestId, _triggerBtn) {
            if (currentUserRole !== 'admin') return;
            const rid = parseInt(requestId, 10) || 0;
            if (!rid) return;
            const _restoreRejectBtn = _btnSetLoading(_triggerBtn);
            const req = getResourceRequests().find(r => parseInt(r && r.id, 10) === rid) || null;
            if (!req) { _restoreRejectBtn(); return; }
            const nowIso = new Date().toISOString();
            const remark = String(getElementValue(`resourceAdminRemark-${rid}`) || '').trim();
            const updatedReq = {
                ...req,
                status: 'rejected',
                admin_decision: 'rejected',
                admin_remark: remark,
                rejected_at: nowIso,
                rejected_by_login_id: String(currentLoginId || 'Admin').trim(),
                updated_at: nowIso
            };
            pushUndoSnapshot('Reject resource request');
            applyResourcePatchLocally({ resource_requests: [updatedReq] });
            _restoreRejectBtn();
            renderResourceRequests();
            showAlert('Request rejected. Press Ctrl+Z to undo.', 'info');
        }

        function loadResourcesTab() {
            applyResourcesRoleUi();
            renderResourceCabinet();
            populateResourceRequestItems();
            populateResourceContextClassOptions();
            populateResourceContextStudents();
            updateResourceContext();
            renderResourceRequests();
            populateResourceTransactionFilters();
            renderResourceTransactions();
            autoAdjustTableFonts();
        }

        let syllabusAttendanceExpanded = false;

        function getSyllabusSelection() {
            const board = String(getElementValue('syllabusBoardFilter') || 'CBSE').trim().toUpperCase();
            const classLevel = String(getElementValue('syllabusClassFilter') || '3').trim();
            const subject = String(getElementValue('syllabusSubjectFilter') || '').trim();
            return { board, classLevel, subject };
        }

        function encodeSyllabusToken(board, classLevel, subject, chapter) {
            return encodeURIComponent(JSON.stringify([board, classLevel, subject, chapter]));
        }

        function decodeSyllabusToken(token) {
            try {
                const decoded = JSON.parse(decodeURIComponent(String(token || '')));
                if (!Array.isArray(decoded) || decoded.length < 4) return null;
                return {
                    board: String(decoded[0] || '').trim().toUpperCase(),
                    classLevel: String(decoded[1] || '').trim(),
                    subject: String(decoded[2] || '').trim(),
                    chapter: String(decoded[3] || '').trim()
                };
            } catch (err) {
                return null;
            }
        }

        function getSyllabusCatalogClassSubjects(board, classLevel) {
            const catalog = db.getSyllabusCatalog();
            const classes = (((catalog || {}).boards || {})[board] || {}).classes || {};
            const classData = classes[String(classLevel)] || {};
            return (classData.subjects && typeof classData.subjects === 'object') ? classData.subjects : {};
        }

        function applySyllabusRoleUi() {
            const isAdmin = currentUserRole === 'admin';
            const canMark = isAdmin || currentUserRole === 'teacher';
            const adminCard = document.getElementById('syllabusAdminToolsCard');
            if (adminCard) adminCard.style.display = isAdmin ? '' : 'none';
            const defaultDate = document.getElementById('syllabusDefaultDate');
            if (defaultDate) {
                if (!defaultDate.value) defaultDate.value = formatDateKey(new Date());
                defaultDate.disabled = !canMark;
            }
        }

        function populateSyllabusClassOptions() {
            const board = String(getElementValue('syllabusBoardFilter') || 'CBSE').trim().toUpperCase();
            const select = document.getElementById('syllabusClassFilter');
            if (!select) return;
            const catalog = db.getSyllabusCatalog();
            const classes = (((catalog || {}).boards || {})[board] || {}).classes || {};
            const current = String(select.value || '').trim();
            const options = Object.keys(classes).sort((a, b) => (parseInt(a, 10) || 0) - (parseInt(b, 10) || 0));
            select.innerHTML = options.map(classLevel => `<option value="${classLevel}">Class ${classLevel}</option>`).join('');
            if (options.includes(current)) {
                select.value = current;
            } else if (options.length) {
                select.value = options[0];
            }
        }

        function populateSyllabusSubjectOptions() {
            const { board, classLevel } = getSyllabusSelection();
            const select = document.getElementById('syllabusSubjectFilter');
            if (!select) return;
            const subjectMap = getSyllabusCatalogClassSubjects(board, classLevel);
            const subjects = Object.keys(subjectMap).sort((a, b) => a.localeCompare(b));
            const current = String(select.value || '').trim();
            select.innerHTML = subjects.map(subject => `<option value="${escapeHtml(subject)}">${escapeHtml(subject)}</option>`).join('');
            if (subjects.includes(current)) {
                select.value = current;
            } else if (subjects.length) {
                select.value = subjects[0];
            }
        }

        function getSyllabusTrackingMap() {
            const map = new Map();
            (db.getSyllabusTracking() || []).forEach(row => {
                const key = String(row && row.key || '').trim();
                if (key) map.set(key, row);
            });
            return map;
        }

        function getAttendanceStudentsForClassDate(classLevel, date) {
            const students = db.getStudents().filter(student =>
                student &&
                student.active !== false &&
                String(student.class || '') === String(classLevel || '')
            );
            const attendeeRows = [];
            students.forEach(student => {
                const attendance = getAttendanceRecord(student.id, date);
                const status = String(attendance && attendance.status || '').trim().toLowerCase();
                if (status === 'present' || status === 'late') {
                    attendeeRows.push({
                        id: parseInt(student.id, 10) || 0,
                        roll: String(student.roll || '').trim().toUpperCase(),
                        name: String(student.base_name || student.name || '').trim()
                    });
                }
            });
            attendeeRows.sort((a, b) => String(a.roll || '').localeCompare(String(b.roll || '')));
            return attendeeRows;
        }

        function getLatestSyllabusSession(record) {
            if (!record || !Array.isArray(record.sessions) || !record.sessions.length) return null;
            return record.sessions
                .slice()
                .sort((a, b) => String(b.date || '').localeCompare(String(a.date || '')))[0];
        }

        function getSyllabusAttendanceLabel(session) {
            if (!session || !Array.isArray(session.attended_names) || !session.attended_names.length) return '-';
            const names = session.attended_names.filter(Boolean);
            if (syllabusAttendanceExpanded || names.length <= 6) {
                return escapeHtml(names.join(', '));
            }
            return `${escapeHtml(names.slice(0, 6).join(', '))} ... (+${names.length - 6})`;
        }

        function renderSyllabusChapterTable() {
            const tbody = document.getElementById('syllabusChapterBody');
            if (!tbody) return;
            const canMark = currentUserRole === 'admin' || currentUserRole === 'teacher';
            const { board, classLevel, subject } = getSyllabusSelection();
            const subjectMap = getSyllabusCatalogClassSubjects(board, classLevel);
            const chapterSearch = String(getElementValue('syllabusChapterSearch') || '').trim().toLowerCase();
            const chapters = (subjectMap[subject] || []).filter(Boolean);
            const filtered = chapters.filter(ch => String(ch).toLowerCase().includes(chapterSearch));
            const trackingMap = getSyllabusTrackingMap();
            const defaultDate = String(getElementValue('syllabusDefaultDate') || formatDateKey(new Date())).trim();

            if (!filtered.length) {
                tbody.innerHTML = `<tr><td colspan="6" class="text-center" style="padding: 30px;">No chapter/topic found for this filter.</td></tr>`;
                return;
            }

            tbody.innerHTML = filtered.map((chapter, idx) => {
                const chapterText = String(chapter || '').trim();
                const key = buildSyllabusTrackingKey(board, classLevel, subject, chapterText);
                const token = encodeSyllabusToken(board, classLevel, subject, chapterText);
                const record = trackingMap.get(key) || null;
                const conductedDates = Array.isArray(record && record.conducted_dates)
                    ? record.conducted_dates.slice().sort((a, b) => String(a).localeCompare(String(b)))
                    : [];
                const dateChips = conductedDates.length
                    ? conductedDates.map(date => `<span style="display:inline-block; margin:2px 4px 2px 0; padding:2px 8px; border-radius:999px; background:#1f2937; color:#e5e7eb; font-size:12px;">${escapeHtml(date)}</span>`).join('')
                    : '<span style="color:#9ca3af;">Not conducted</span>';
                const latestSession = getLatestSyllabusSession(record);
                const lastConducted = latestSession ? String(latestSession.date || '') : (conductedDates.length ? conductedDates[conductedDates.length - 1] : '-');
                const attendanceLabel = getSyllabusAttendanceLabel(latestSession);
                const inputId = `syllabusDate_${idx}`;
                const title = latestSession && Array.isArray(latestSession.attended_names) ? latestSession.attended_names.join(', ') : '';
                return `
                    <tr>
                        <td>${idx + 1}</td>
                        <td>${escapeHtml(chapterText)}</td>
                        <td>${dateChips}</td>
                        <td>${escapeHtml(lastConducted || '-')}</td>
                        <td title="${escapeHtml(title)}">${attendanceLabel}</td>
                        <td>
                            <div style="display:flex; gap:6px; align-items:center;">
                                <input type="date" id="${inputId}" value="${escapeHtml(defaultDate)}" ${canMark ? '' : 'disabled'} style="max-width:130px;">
                                <button class="secondary" onclick="markSyllabusConductedByToken('${token}','${inputId}')" ${canMark ? '' : 'disabled'} data-allow="true">
                                    <i class="fas fa-check"></i> Mark
                                </button>
                            </div>
                        </td>
                    </tr>
                `;
            }).join('');
            renderResourceSettlementSummary(rows, studentById);
        }

        function renderResourceSettlementSummary(rows, studentById = null) {
            const target = document.getElementById('resourceSettlementBody');
            const card = document.getElementById('resourceSettlementCard');
            if (!target || !card) return;
            const txns = Array.isArray(rows) ? rows : getResourceTransactions();
            const byId = studentById || new Map((db.getStudents() || []).map(s => [parseInt(s.id, 10), s]));
            const summary = new Map();

            txns.forEach(txn => {
                const mode = String(txn && txn.type || '').trim().toLowerCase();
                if (mode !== 'cash_purchase') return;
                const sid = parseInt(txn && txn.studentId, 10) || 0;
                if (!sid) return;
                const cashPaid = Math.max(0, parseFloat(txn && txn.cash_paid) || 0);
                const cashCharged = Math.max(0, parseFloat(txn && txn.cash_charged) || 0);
                const fallbackCharged = Math.max(0, parseFloat(txn && txn.total_cost) || 0);
                const charged = cashCharged || fallbackCharged;
                if (!charged) return;
                const bal = computeResourceCashBalance(charged, cashPaid);
                const cashDueRaw = parseFloat(txn && txn.cash_due);
                const cashReturnRaw = parseFloat(txn && txn.cash_return_due);
                const due = Math.max(0, Number.isFinite(cashDueRaw) ? cashDueRaw : bal.pending);
                const ret = Math.max(0, Number.isFinite(cashReturnRaw) ? cashReturnRaw : bal.return_due);
                if (due <= 0 && ret <= 0 && !txn.pending_settlement) return;

                const entry = summary.get(sid) || { due: 0, ret: 0, count: 0 };
                entry.due += due;
                entry.ret += ret;
                entry.count += 1;
                summary.set(sid, entry);
            });

            if (!summary.size) {
                card.style.display = 'none';
                target.innerHTML = '';
                return;
            }
            card.style.display = '';
            const rowsHtml = Array.from(summary.entries())
                .map(([sid, s]) => {
                    const student = byId.get(parseInt(sid, 10));
                    const roll = student ? formatRollDisplay(student.roll) : '';
                    const name = student ? renderStudentName(student, getCurrentMonthKey()) : 'Unknown';
                    const due = formatMoneyValue(s.due);
                    const ret = formatMoneyValue(s.ret);
                    const net = formatMoneyValue(Math.max(0, s.due - s.ret));
                    return `
                        <tr>
                            <td>${name}</td>
                            <td>${escapeHtml(roll || '-')}</td>
                            <td>${s.count}</td>
                            <td>₹${due}</td>
                            <td>₹${ret}</td>
                            <td>₹${net}</td>
                        </tr>
                    `;
                }).join('');
            target.innerHTML = rowsHtml;
        }

        function addSyllabusSubject() {
            if (currentUserRole !== 'admin') {
                showAlert('Only admin can add subjects.', 'warning');
                return;
            }
            const { board, classLevel } = getSyllabusSelection();
            const subjectName = String(getElementValue('syllabusNewSubject') || '').trim();
            if (!subjectName) {
                showAlert('Enter a subject name.', 'warning');
                return;
            }
            const data = db.getData();
            data.syllabus_catalog = normalizeSyllabusCatalogShape(data.syllabus_catalog || {});
            data.syllabus_catalog.boards[board] = data.syllabus_catalog.boards[board] || { classes: {} };
            data.syllabus_catalog.boards[board].classes[classLevel] = data.syllabus_catalog.boards[board].classes[classLevel] || { subjects: {} };
            const subjects = data.syllabus_catalog.boards[board].classes[classLevel].subjects || {};
            if (subjects[subjectName]) {
                showAlert('Subject already exists for this class.', 'info');
                return;
            }
            subjects[subjectName] = getDefaultTopicsForSubject(subjectName, getSyllabusStage(classLevel));
            data.syllabus_catalog.boards[board].classes[classLevel].subjects = subjects;
            data.syllabus_seed_version = SYLLABUS_SEED_VERSION;
            db.saveData(data);
            document.getElementById('syllabusNewSubject').value = '';
            populateSyllabusSubjectOptions();
            renderSyllabusChapterTable();
            showAlert('Subject added.', 'success');
        }

        function addSyllabusChapter() {
            if (currentUserRole !== 'admin') {
                showAlert('Only admin can add chapters/topics.', 'warning');
                return;
            }
            const { board, classLevel, subject } = getSyllabusSelection();
            const chapter = String(getElementValue('syllabusNewChapter') || '').trim();
            if (!subject) {
                showAlert('Select a subject first.', 'warning');
                return;
            }
            if (!chapter) {
                showAlert('Enter chapter/topic name.', 'warning');
                return;
            }
            const data = db.getData();
            data.syllabus_catalog = normalizeSyllabusCatalogShape(data.syllabus_catalog || {});
            data.syllabus_catalog.boards[board] = data.syllabus_catalog.boards[board] || { classes: {} };
            data.syllabus_catalog.boards[board].classes[classLevel] = data.syllabus_catalog.boards[board].classes[classLevel] || { subjects: {} };
            const subjectMap = data.syllabus_catalog.boards[board].classes[classLevel].subjects || {};
            const existing = Array.isArray(subjectMap[subject]) ? subjectMap[subject] : [];
            if (existing.some(item => String(item || '').trim().toLowerCase() === chapter.toLowerCase())) {
                showAlert('Chapter/topic already exists.', 'info');
                return;
            }
            subjectMap[subject] = [...existing, chapter];
            data.syllabus_catalog.boards[board].classes[classLevel].subjects = subjectMap;
            data.syllabus_seed_version = SYLLABUS_SEED_VERSION;
            db.saveData(data);
            document.getElementById('syllabusNewChapter').value = '';
            renderSyllabusChapterTable();
            showAlert('Chapter/topic added.', 'success');
        }

        function markSyllabusConductedByToken(token, inputId) {
            const canMark = currentUserRole === 'admin' || currentUserRole === 'teacher';
            if (!canMark) {
                showAlert('Only admin/teacher can mark conducted classes.', 'warning');
                return;
            }
            const parsed = decodeSyllabusToken(token);
            if (!parsed) {
                showAlert('Invalid chapter key.', 'danger');
                return;
            }
            const input = document.getElementById(inputId);
            const dateValue = String((input && input.value) || getElementValue('syllabusDefaultDate') || '').trim();
            if (!/^\d{4}-\d{2}-\d{2}$/.test(dateValue)) {
                showAlert('Select a valid conducted date.', 'warning');
                return;
            }
            const trackingMap = getSyllabusTrackingMap();
            const key = buildSyllabusTrackingKey(parsed.board, parsed.classLevel, parsed.subject, parsed.chapter);
            const existing = trackingMap.get(key) || null;
            const attendees = getAttendanceStudentsForClassDate(parsed.classLevel, dateValue);
            const nowIso = new Date().toISOString();
            const sessionsByDate = new Map();
            (Array.isArray(existing && existing.sessions) ? existing.sessions : []).forEach(sess => {
                if (!sess || !sess.date) return;
                sessionsByDate.set(String(sess.date), sess);
            });
            sessionsByDate.set(dateValue, {
                date: dateValue,
                attended_student_ids: attendees.map(item => item.id).filter(v => v > 0),
                attended_rolls: attendees.map(item => item.roll).filter(Boolean),
                attended_names: attendees.map(item => item.name).filter(Boolean),
                marked_by: String(currentLoginId || currentUserRole || '').trim(),
                marked_at: nowIso
            });
            const nextRow = {
                id: parseInt(existing && existing.id, 10) || Date.now() + Math.floor(Math.random() * 1000),
                key,
                board: parsed.board,
                class_level: parsed.classLevel,
                subject: parsed.subject,
                chapter: parsed.chapter,
                conducted_dates: Array.from(new Set([...(Array.isArray(existing && existing.conducted_dates) ? existing.conducted_dates : []), dateValue])).sort(),
                sessions: Array.from(sessionsByDate.values()).sort((a, b) => String(a.date || '').localeCompare(String(b.date || ''))),
                created_at: String(existing && existing.created_at || nowIso),
                updated_at: nowIso
            };
            db.upsertSyllabusTrackingRows([nextRow]);
            renderSyllabusChapterTable();
            showAlert(`Marked conducted on ${dateValue}. Attendance captured: ${attendees.length} student(s).`, 'success');
        }

        function toggleSyllabusAttendanceView(expand) {
            syllabusAttendanceExpanded = !!expand;
            renderSyllabusChapterTable();
        }

        function loadSyllabusTab() {
            applySyllabusRoleUi();
            const boardSelect = document.getElementById('syllabusBoardFilter');
            if (boardSelect && !boardSelect.value) boardSelect.value = 'CBSE';
            populateSyllabusClassOptions();
            populateSyllabusSubjectOptions();
            renderSyllabusChapterTable();
            autoAdjustTableFonts();
        }

        function getFeesExportRows() {
            const statusFilter = getElementValue('feesStatusFilter') || 'active';
            const search = (getElementValue('feesSearch') || '').trim().toLowerCase();
            const monthKey = getCurrentMonthKey();
            let students = filterStudentsByStatus(db.getStudents(), statusFilter, monthKey);
            const groupFilter = getElementValue('feesGroupFilter') || 'all';
            if (groupFilter !== 'all') {
                students = students.filter(student => getStudentGroup(student) === groupFilter);
            }
            if (search) {
                students = students.filter(student => {
                    const name = (student.base_name || student.name || '').toLowerCase();
                    const roll = (student.roll || '').toLowerCase();
                    return name.includes(search) || roll.includes(search);
                });
            }
            const feeMap = getFeeRecordMap();
            return students.map(student => {
                const record = getFeeRecordForStudent(student.id, feeMap);
                const baseAmount = record.amount !== null && record.amount !== undefined
                    ? record.amount
                    : (Number.isFinite(Number(student.fees)) ? Number(student.fees) : '');
                const pendingAmount = Number.isFinite(Number(record.pending_amount))
                    ? Number(record.pending_amount)
                    : baseAmount;
                const startValue = getEffectiveFeeStartDate(record);
                const periodValue = record.period_months || 1;
                const dueDate = computeFeeDueDate({ ...record, start_date: startValue, period_months: periodValue });
                const overdue = isFeeOverdue({ ...record, start_date: startValue, period_months: periodValue });
                const lastPaid = record.last_paid_date ? formatDateLabel(record.last_paid_date) : '';
                const statusLabel = overdue ? 'Past Due' : (record.last_paid_date ? 'Paid' : 'Due');
                return {
                    'Roll No.': formatRollDisplay(student.roll),
                    'Student Name': student.base_name || student.name || '',
                    'Class': student.class || '',
                    'Group': getStudentGroup(student) || '',
                    'Fees': pendingAmount,
                    'Start Date': startValue ? formatDateLabel(startValue) : '',
                    'Period (Months)': periodValue,
                    'Due Date': dueDate ? formatDateLabel(dueDate) : '',
                    'Last Paid': lastPaid,
                    'Status': statusLabel,
                    'Remarks': record.remarks || ''
                };
            });
        }

        async function exportFeesData(format) {
            const rows = getFeesExportRows();
            if (!rows.length) {
                showAlert('No fees data to export', 'warning');
                return;
            }
            const dateStamp = new Date().toISOString().split('T')[0];
            if (format === 'xlsx') {
                await ensureXlsxLoaded();
                const worksheet = XLSX.utils.json_to_sheet(rows);
                const workbook = XLSX.utils.book_new();
                XLSX.utils.book_append_sheet(workbook, worksheet, 'Fees');
                XLSX.writeFile(workbook, `fees_export_${dateStamp}.xlsx`);
                return;
            }
            if (format === 'txt') {
                const headers = Object.keys(rows[0]);
                const lines = [headers.join('\t')].concat(rows.map(row => headers.map(key => String((row && row[key] !== undefined && row[key] !== null) ? row[key] : '')).join('\t')));
                const blob = new Blob([lines.join('\n')], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `fees_export_${dateStamp}.txt`;
                document.body.appendChild(link);
                link.click();
                link.remove();
                return;
            }
            if (format === 'docx') {
                const headers = Object.keys(rows[0]);
                const rowsHtml = rows.map(row => `<tr>${headers.map(h => `<td>${escapeHtml(String((row && row[h] !== undefined && row[h] !== null) ? row[h] : ''))}</td>`).join('')}</tr>`).join('');
                const html = `
                    <html><head><meta charset="utf-8"></head><body>
                    <h2>Fees Export (${dateStamp})</h2>
                    <table border="1" cellspacing="0" cellpadding="6">
                        <tr>${headers.map(h => `<th>${escapeHtml(h)}</th>`).join('')}</tr>
                        ${rowsHtml}
                    </table>
                    </body></html>`;
                const blob = new Blob([html], { type: 'application/vnd.openxmlformats-officedocument.wordprocessingml.document' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `fees_export_${dateStamp}.docx`;
                document.body.appendChild(link);
                link.click();
                link.remove();
            }
        }

        function inferMonthYearFromSheetName(sheetName) {
            const lower = sheetName.toLowerCase();
            const monthMap = {
                jan: 1, january: 1,
                feb: 2, february: 2,
                mar: 3, march: 3,
                apr: 4, april: 4,
                may: 5,
                jun: 6, june: 6,
                jul: 7, july: 7,
                aug: 8, august: 8,
                sep: 9, sept: 9, september: 9,
                oct: 10, october: 10,
                nov: 11, november: 11,
                dec: 12, december: 12
            };
            let month = null;
            Object.keys(monthMap).some(key => {
                if (lower.includes(key)) {
                    month = monthMap[key];
                    return true;
                }
                return false;
            });

            let year = null;
            const yearMatch = lower.match(/(20\d{2}|\d{2})/);
            if (yearMatch) {
                const raw = yearMatch[1];
                year = raw.length === 2 ? 2000 + parseInt(raw, 10) : parseInt(raw, 10);
            }
            if (month && !year) {
                year = new Date().getFullYear();
            }
            return { month, year };
        }

        function buildDateString(year, month, day) {
            if (!year || !month || !day) return null;
            const date = new Date(Date.UTC(year, month - 1, day));
            return date.toISOString().split('T')[0];
        }

        function parseHeaderDate(value, context) {
            if (value instanceof Date && !Number.isNaN(value.getTime())) {
                return buildDateString(value.getUTCFullYear(), value.getUTCMonth() + 1, value.getUTCDate());
            }
            if (typeof value === 'number') {
                if (value > 31) {
                    const parsed = XLSX.SSF.parse_date_code(value);
                    if (parsed && parsed.y && parsed.m && parsed.d) {
                        if (parsed.y >= 2020) {
                            return buildDateString(parsed.y, parsed.m, parsed.d);
                        }
                        return null;
                    }
                } else if (context && context.month && context.year) {
                    return buildDateString(context.year, context.month, value);
                }
            }
            if (typeof value === 'string') {
                const trimmed = value.trim();
                if (!trimmed) return null;
                const dayOnly = trimmed.match(/^(\d{1,2})$/);
                if (dayOnly && context && context.month && context.year) {
                    return buildDateString(context.year, context.month, parseInt(dayOnly[1], 10));
                }
                const parsedTime = Date.parse(trimmed);
                if (!Number.isNaN(parsedTime)) {
                    const parsedDate = new Date(parsedTime);
                    if (parsedDate.getUTCFullYear() >= 2020) {
                        return buildDateString(parsedDate.getUTCFullYear(), parsedDate.getUTCMonth() + 1, parsedDate.getUTCDate());
                    }
                    return null;
                }
                const shortMatch = trimmed.match(/(\d{1,2})\s*([A-Za-z]{3,})/);
                if (shortMatch && context && context.year) {
                    const day = parseInt(shortMatch[1], 10);
                    const monthText = shortMatch[2].toLowerCase().slice(0, 3);
                    const monthLookup = { jan: 1, feb: 2, mar: 3, apr: 4, may: 5, jun: 6, jul: 7, aug: 8, sep: 9, oct: 10, nov: 11, dec: 12 };
                    const month = monthLookup[monthText];
                    if (month) {
                        return buildDateString(context.year, month, day);
                    }
                }
            }
            return null;
        }

        function parseScoreCell(cell) {
            if (cell === null || cell === undefined || cell === '') {
                return { points: null, stars: 0, vetos: 0 };
            }
            if (typeof cell === 'number') {
                return { points: Number(cell), stars: 0, vetos: 0 };
            }
            const text = String(cell).trim();
            if (!text) {
                return { points: null, stars: 0, vetos: 0 };
            }
            const stars = (text.match(/\*/g) || []).length;
            const vetoTokens = text.match(/v+/ig) || [];
            const vetos = vetoTokens.reduce((sum, token) => sum + token.length, 0);
            const numberMatch = text.match(/-?\d+(\.\d+)?/);
            const points = numberMatch ? Number(numberMatch[0]) : null;
            return { points, stars, vetos };
        }

        function parseTokenAdjustment(raw, token) {
            const text = String(raw || '').trim();
            if (!text) return 0;
            if (/^-?\d+$/.test(text)) {
                return parseInt(text, 10);
            }
            const sign = text.startsWith('-') ? -1 : 1;
            const body = text.replace(/^[-+]/, '');
            if (token === '*' && /^\*+$/.test(body)) {
                return sign * body.length;
            }
            if (token === 'V' && /^v+$/i.test(body)) {
                return sign * body.length;
            }
            return NaN;
        }

        function escapeHtml(value) {
            return String(coalesce(value, ''))
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        function isWorkbookSheetVisible(workbook, sheetName) {
            const metaSheets = workbook && workbook.Workbook && Array.isArray(workbook.Workbook.Sheets)
                ? workbook.Workbook.Sheets
                : [];
            const meta = metaSheets.find(item => String(item && item.name || '') === String(sheetName));
            if (!meta) return true;
            return Number(meta.Hidden || 0) === 0;
        }

        function getVisibleSheetRows(sheet) {
            const allRows = XLSX.utils.sheet_to_json(sheet, { header: 1, raw: true, defval: '' });
            const hiddenCols = new Set();
            (sheet['!cols'] || []).forEach((col, idx) => {
                if (col && col.hidden) hiddenCols.add(idx);
            });
            const hiddenRows = new Set();
            (sheet['!rows'] || []).forEach((row, idx) => {
                if (row && row.hidden) hiddenRows.add(idx);
            });

            const rows = [];
            allRows.forEach((row, rowIndex) => {
                if (hiddenRows.has(rowIndex)) return;
                const outputRow = [];
                (row || []).forEach((cell, colIndex) => {
                    if (hiddenCols.has(colIndex)) return;
                    outputRow.push(cell);
                });
                rows.push(outputRow);
            });
            return rows;
        }

        function isRelevantExtraHeader(headerText) {
            const value = String(headerText || '').trim();
            if (!value) return false;
            if (/^column\d*$/i.test(value)) return false;
            if (/^unnamed/i.test(value)) return false;
            if (/^\d+(\.\d+)?$/.test(value)) return false;
            return true;
        }

        function toExtraColumnKey(headerText, fallbackIndex = 0) {
            const base = String(headerText || '')
                .toLowerCase()
                .replace(/[^a-z0-9]+/g, '_')
                .replace(/^_+|_+$/g, '');
            if (base) return base.slice(0, 48);
            return `extra_${fallbackIndex + 1}`;
        }

        function findHeaderRow(rows) {
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i].map(cell => String(cell || '').trim().toLowerCase());
                const hasRoll = row.some(cell => cell.includes('roll'));
                const hasName = row.some(cell => cell.includes('student') || cell.includes('name') || cell.includes('candidate'));
                if (hasRoll && hasName) {
                    return i;
                }
            }
            return -1;
        }

        function detectColumnIndex(headerRow, keywords) {
            for (let i = 0; i < headerRow.length; i++) {
                const value = String(headerRow[i] || '').trim().toLowerCase();
                if (!value) continue;
                if (keywords.some(keyword => value.includes(keyword))) {
                    return i;
                }
            }
            return -1;
        }

        function extractPartyAndLeadership(rows) {
            const parties = [];
            const leadership = [];
            let partyRow = -1;
            let partyCol = -1;
            let powerCol = -1;
            let postRow = -1;
            let postCol = -1;
            let holderCol = -1;

            rows.forEach((row, r) => {
                row.forEach((cell, c) => {
                    const label = String(cell || '').trim().toLowerCase();
                    if (label === 'party') {
                        partyRow = r;
                        partyCol = c;
                    }
                    if (label === 'power') {
                        powerCol = c;
                    }
                    if (label === 'post') {
                        postRow = r;
                        postCol = c;
                    }
                    if (label === 'post holders' || label === 'post holder') {
                        holderCol = c;
                    }
                });
            });

            if (partyRow >= 0 && partyCol >= 0) {
                for (let r = partyRow + 1; r < partyRow + 20 && r < rows.length; r++) {
                    const code = rows[r][partyCol];
                    if (!code) continue;
                    const codeText = String(code).trim();
                    if (!codeText || codeText.toLowerCase() === 'total') continue;
                    parties.push({ code: codeText, members: [] });
                }
            }

            if (postRow >= 0 && postCol >= 0) {
                for (let r = postRow + 1; r < postRow + 30 && r < rows.length; r++) {
                    const post = rows[r][postCol];
                    if (!post) continue;
                    const holder = holderCol >= 0 ? rows[r][holderCol] : '';
                    leadership.push({ post: String(post).trim(), holder: String(holder || '').trim() });
                }
            }

            return { parties, leadership };
        }

        function parseWorkbook(workbook) {
            const studentsMap = new Map();
            const nameSet = new Set();
            const scores = [];
            const monthStudents = {};
            const monthExtraColumns = {};
            const monthStudentExtras = {};
            const monthRosterProfiles = {};
            const scannedSheets = [];
            let parties = [];
            let leadership = [];
            let studentIdCounter = 1;
            let scoreIdCounter = 1;

            workbook.SheetNames.forEach(sheetName => {
                if (!isWorkbookSheetVisible(workbook, sheetName)) return;
                const sheet = workbook.Sheets[sheetName];
                const rows = getVisibleSheetRows(sheet);
                if (!rows.length) return;
                scannedSheets.push(sheetName);

                const context = inferMonthYearFromSheetName(sheetName);
                const { parties: foundParties, leadership: foundLeadership } = extractPartyAndLeadership(rows);
                if (foundParties.length) parties = foundParties;
                if (foundLeadership.length) leadership = foundLeadership;

                const headerRowIndex = findHeaderRow(rows);
                if (headerRowIndex < 0) return;
                const headerRow = rows[headerRowIndex];

                const rollCol = detectColumnIndex(headerRow, ['roll']);
                const nameCol = detectColumnIndex(headerRow, ['student', 'name', 'candidate']);
                const classCol = detectColumnIndex(headerRow, ['class']);
                const feesCol = detectColumnIndex(headerRow, ['fees']);
                const voteCol = detectColumnIndex(headerRow, ['vote power', 'votepower', 'vote']);
                const totalCol = detectColumnIndex(headerRow, ['total', 'final score', 'final']);
                const rankCol = detectColumnIndex(headerRow, ['rank']);
                const starsCol = detectColumnIndex(headerRow, ['stars', 'star']);
                const vetoCol = detectColumnIndex(headerRow, ['veto', 'vetoes', 'vetos']);

                const knownCols = new Set([rollCol, nameCol, classCol, feesCol, voteCol, totalCol, rankCol, starsCol, vetoCol].filter(i => i >= 0));
                const dateCols = headerRow.map((cell, idx) => {
                    if (knownCols.has(idx)) return null;
                    const dateStr = parseHeaderDate(cell, context);
                    if (!dateStr) return null;
                    return { index: idx, date: dateStr };
                }).filter(Boolean);
                const monthKey = (context && context.year && context.month)
                    ? `${context.year}-${String(context.month).padStart(2, '0')}`
                    : (dateCols.length ? dateCols[0].date.substring(0, 7) : null);
                if (monthKey && !monthStudents[monthKey]) {
                    monthStudents[monthKey] = new Set();
                }
                if (monthKey && !monthExtraColumns[monthKey]) {
                    monthExtraColumns[monthKey] = [];
                }
                if (monthKey && !monthStudentExtras[monthKey]) {
                    monthStudentExtras[monthKey] = {};
                }
                if (monthKey && !monthRosterProfiles[monthKey]) {
                    monthRosterProfiles[monthKey] = {};
                }

                const dateIndexSet = new Set(dateCols.map(col => col.index));
                const trailingStart = dateCols.length ? (Math.max(...dateCols.map(col => col.index)) + 1) : headerRow.length;
                const seenExtraKeys = new Set((monthExtraColumns[monthKey] || []).map(col => col.key));
                const extraCols = [];
                for (let idx = trailingStart; idx < headerRow.length; idx++) {
                    if (knownCols.has(idx) || dateIndexSet.has(idx)) continue;
                    const label = String(headerRow[idx] || '').trim();
                    if (!isRelevantExtraHeader(label)) continue;
                    const baseKey = toExtraColumnKey(label, idx);
                    let key = baseKey;
                    let counter = 2;
                    while (seenExtraKeys.has(key)) {
                        key = `${baseKey}_${counter++}`;
                    }
                    seenExtraKeys.add(key);
                    extraCols.push({ index: idx, key, label });
                }
                if (monthKey && extraCols.length) {
                    monthExtraColumns[monthKey] = [...(monthExtraColumns[monthKey] || []), ...extraCols.map(col => ({ key: col.key, label: col.label }))];
                }

                for (let r = headerRowIndex + 1; r < rows.length; r++) {
                    const row = rows[r];
                    if (!row || !row.length) continue;
                    const rollRaw = rollCol >= 0 ? row[rollCol] : '';
                    const nameRaw = nameCol >= 0 ? row[nameCol] : '';
                    if (!rollRaw || !nameRaw) continue;
                    const roll = String(rollRaw || '').trim();
                    if (!isValidRollNo(roll)) continue;
                    const rawNameText = String(nameRaw || '').trim();
                    const nameMeta = extractNameMeta(rawNameText);
                    const name = nameMeta.baseName;
                    if (!isValidStudentName(name)) continue;
                    if (!roll && !name) continue;

                    const nameKey = name.toUpperCase();
                    if (!roll && nameKey && nameSet.has(nameKey)) {
                        continue;
                    }

                    const key = roll ? roll.toUpperCase() : nameKey;
                    let student = studentsMap.get(key);
                    if (!student) {
                        student = {
                            id: studentIdCounter++,
                            roll,
                            name,
                            base_name: name,
                            raw_name: rawNameText,
                            class: null,
                            fees: 0,
                            total_score: null,
                            rank: null,
                            vote_power: null,
                            stars: nameMeta.stars,
                            veto_count: nameMeta.vetos,
                            group: deriveGroupFromRoll(roll),
                            active: true
                        };
                        studentsMap.set(key, student);
                    }
                    if (!student.raw_name || /\([^)]+\)/.test(rawNameText)) {
                        student.raw_name = rawNameText;
                    }
                    if (monthKey && monthStudents[monthKey]) {
                        if (roll) monthStudents[monthKey].add(roll.toUpperCase());
                        else if (nameKey) monthStudents[monthKey].add(nameKey);
                    }
                    if (nameKey) {
                        nameSet.add(nameKey);
                    }

                    if (classCol >= 0) {
                        const classValue = parseInt(row[classCol], 10);
                        if (!Number.isNaN(classValue)) student.class = classValue;
                    }
                    if (feesCol >= 0) {
                        const feesValue = parseInt(row[feesCol], 10);
                        if (!Number.isNaN(feesValue)) student.fees = feesValue;
                    }
                    if (voteCol >= 0) {
                        const voteValue = parseInt(row[voteCol], 10);
                        if (!Number.isNaN(voteValue)) student.vote_power = voteValue;
                    }
                    if (totalCol >= 0) {
                        const totalValue = parseInt(row[totalCol], 10);
                        if (!Number.isNaN(totalValue)) student.total_score = totalValue;
                    }
                    if (rankCol >= 0) {
                        const rankValue = parseInt(row[rankCol], 10);
                        if (!Number.isNaN(rankValue)) student.rank = rankValue;
                    }
                    if (starsCol >= 0) {
                        const starsValue = parseInt(row[starsCol], 10);
                        if (!Number.isNaN(starsValue)) student.stars = Math.max(0, starsValue);
                    }
                    if (vetoCol >= 0) {
                        const vetoValue = parseInt(row[vetoCol], 10);
                        if (!Number.isNaN(vetoValue)) student.veto_count = Math.max(0, vetoValue);
                    }
                    if (monthKey && roll) {
                        monthRosterProfiles[monthKey][roll.toUpperCase()] = {
                            roll: roll.toUpperCase(),
                            name: rawNameText || name,
                            base_name: name,
                            class: student.class || null
                        };
                    }
                    if (monthKey && extraCols.length) {
                        const studentMonthKey = (roll ? roll.toUpperCase() : nameKey);
                        if (studentMonthKey) {
                            const existingValues = monthStudentExtras[monthKey][studentMonthKey] || {};
                            extraCols.forEach(({ index, key }) => {
                                const cell = row[index];
                                if (cell === null || cell === undefined) return;
                                if (typeof cell === 'string' && !cell.trim()) return;
                                existingValues[key] = typeof cell === 'number' ? cell : String(cell).trim();
                            });
                            if (Object.keys(existingValues).length) {
                                monthStudentExtras[monthKey][studentMonthKey] = existingValues;
                            }
                        }
                    }

                    dateCols.forEach(({ index, date }) => {
                        const cell = row[index];
                        const parsedScore = parseScoreCell(cell);
                        const points = parsedScore.points;
                        if (points === null || Number.isNaN(points)) return;
                        if (starsCol < 0 && parsedScore.stars) {
                            student.stars = (parseInt(student.stars, 10) || 0) + parsedScore.stars;
                        }
                        if (vetoCol < 0 && parsedScore.vetos) {
                            student.veto_count = (parseInt(student.veto_count, 10) || 0) + parsedScore.vetos;
                        }
                        scores.push({
                            id: scoreIdCounter++,
                            studentId: student.id,
                            date,
                            points,
                            stars: parsedScore.stars,
                            vetos: parsedScore.vetos,
                            month: date.substring(0, 7),
                            notes: ''
                        });
                    });
                }
            });

            return {
                students: Array.from(studentsMap.values()),
                scores,
                month_students: Object.fromEntries(
                    Object.entries(monthStudents).map(([key, value]) => [key, Array.from(value)])
                ),
                month_extra_columns: monthExtraColumns,
                month_student_extras: monthStudentExtras,
                month_roster_profiles: Object.fromEntries(
                    Object.entries(monthRosterProfiles).map(([key, value]) => [key, Object.values(value)])
                ),
                parties,
                leadership,
                scanned_sheets: scannedSheets
            };
        }

        async function importExcel() {
            // Server-side historical import:
            // - monthly totals from Total Score / Final Score
            // - per-date star usage markers from real date columns
            // Feb 26 and newer months are never touched.
            const file = document.getElementById('excelFile').files[0];
            if (!file) {
                showAlert('Please select an Excel file', 'danger');
                return;
            }
            if (!confirm(
                'Import Historical Scores from Excel workbook?\n\n' +
                '• Reads historical monthly totals from "Total Score" (fallback: "Final Score")\n' +
                '• Imports historical star usage from date columns only (for red * cells)\n' +
                '• Old admin-imported scores for those months will be replaced\n' +
                '• Feb 2026, Mar 2026 and current teacher data are NOT changed\n\n' +
                'Continue?'
            )) return;

            const btn = event && event.target;
            if (btn) { btn.disabled = true; btn.textContent = 'Importing…'; }

            const formData = new FormData();
            formData.append('file', file);
            try {
                const resp = await fetch('/scoreboard/import-historical-data', {
                    method: 'POST',
                    body: formData,
                    credentials: 'same-origin'
                });
                if (!resp.ok) {
                    const errText = await resp.text();
                    showAlert('Import failed (HTTP ' + resp.status + '): ' + errText, 'danger');
                    return;
                }
                const result = await resp.json();
                if (result.success) {
                    const lines = [`✓ ${result.message}`];
                    Object.entries(result.month_report || {}).forEach(([mk, r]) => {
                        if (r.status === 'ok') {
                            lines.push(`  ${mk} (${r.sheet}): ${r.students_imported} totals + ${r.star_usage_rows || 0} star markers [total col ${r.total_col || '-'}, date cols ${r.date_columns || 0}, header row ${r.header_row}]`);
                        } else {
                            lines.push(`  ${mk}: SKIPPED — ${r.reason}`);
                        }
                    });
                    showAlert(lines.join('\n'), 'success');
                    // Pull fresh data from server so the scoreboard reflects the import
                    await pullFromServer(false, true);
                    loadScoreboard();
                } else {
                    showAlert('Import failed: ' + (result.error || 'Unknown error'), 'danger');
                }
            } catch (e) {
                showAlert('Import error: ' + e.message, 'danger');
            } finally {
                if (btn) { btn.disabled = false; btn.textContent = 'Import Historical Data'; }
            }
        }

        async function exportToExcel() {
            await ensureXlsxLoaded();
            const students = db.getStudents();
            const data = students.map(s => ({ ...s }));

            const ws = XLSX.utils.json_to_sheet(data);
            const wb = XLSX.utils.book_new();
            XLSX.utils.book_append_sheet(wb, ws, 'Students');
            XLSX.writeFile(wb, 'EA_Scoreboard_Export.xlsx');

            showAlert('Data exported to Excel!', 'success');
        }

        function exportJSON() {
            const data = db.getData();
            const json = JSON.stringify(data, null, 2);
            const blob = new Blob([json], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'EA_Scoreboard_Backup.json';
            a.click();
            URL.revokeObjectURL(url);
            showAlert('Data exported as JSON!', 'success');
        }

        function importJSON() {
            document.getElementById('jsonFile').click();
            document.getElementById('jsonFile').onchange = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        db.saveData(data);
                        db.ensureSchema();
                        showAlert('Data imported successfully!', 'success');
                        loadScoreboard();
                        loadStudents();
                        updateAppealsTabNotification();
                    } catch (err) {
                        showAlert('Error importing JSON: ' + err.message, 'danger');
                    }
                };
                reader.readAsText(file);
            };
        }

        // ══════════════════════════════════════════════════════════════════════
        // Device Monitoring Panel (Admin only)
        // ══════════════════════════════════════════════════════════════════════
        let _deviceLogCache = [];   // last-fetched raw log entries

        async function loadDeviceLog() {
            if (!SERVER_SYNC.enabled) {
                showToast('Server not connected — device log unavailable.', 'warning');
                return;
            }
            const tbody = document.getElementById('deviceSummaryBody');
            if (tbody) tbody.innerHTML = '<tr><td colspan="11" class="text-center loading">Loading…</td></tr>';
            try {
                const resp = await fetch('/scoreboard/device-checkin', {
                    cache: 'no-store', credentials: 'include'
                });
                if (!resp.ok) { showToast('Failed to load device log.', 'danger'); return; }
                const json = await resp.json();
                _deviceLogCache = Array.isArray(json.log) ? json.log : [];
                filterDeviceLog();
            } catch (e) {
                showToast('Error loading device log: ' + e.message, 'danger');
            }
        }

        function filterDeviceLog() {
            const q = (document.getElementById('deviceLogFilter')?.value || '').toLowerCase().trim();
            const roleF = (document.getElementById('deviceLogRoleFilter')?.value || '').toLowerCase();
            let entries = _deviceLogCache;
            if (roleF) entries = entries.filter(e => (e.role || '').toLowerCase() === roleF);
            if (q) entries = entries.filter(e =>
                (e.login_id || '').toLowerCase().includes(q) ||
                (e.device_name || '').toLowerCase().includes(q) ||
                (e.os || '').toLowerCase().includes(q) ||
                (e.browser || '').toLowerCase().includes(q) ||
                (e.ip || '').toLowerCase().includes(q) ||
                (e.device_id || '').toLowerCase().includes(q)
            );
            _renderDeviceSummary(entries);
            _renderDeviceFullLog(entries);
        }

        function _renderDeviceSummary(entries) {
            // Build unique-device map (keyed by device_id)
            const deviceMap = new Map();
            for (const e of entries) {
                const key = e.device_id || ('noid_' + (e.login_id || ''));
                if (!deviceMap.has(key)) {
                    deviceMap.set(key, { ...e, visits: 0, allUsers: new Set() });
                }
                const rec = deviceMap.get(key);
                rec.visits++;
                rec.allUsers.add(e.login_id || '');
                // Keep most-recent entry (entries are chronological, last = most recent)
                if (!rec.latest_ts || e.ts > rec.latest_ts) {
                    rec.latest_ts = e.ts;
                    rec.login_id = e.login_id;
                    rec.role = e.role;
                    rec.ip = e.ip;
                }
            }
            const devices = [...deviceMap.values()];

            // Summary stats
            const statsEl = document.getElementById('deviceSummaryStats');
            if (statsEl) {
                const admins = new Set(entries.filter(e => e.role === 'admin').map(e => e.login_id)).size;
                const teachers = new Set(entries.filter(e => e.role === 'teacher').map(e => e.login_id)).size;
                const students = new Set(entries.filter(e => e.role === 'student').map(e => e.login_id)).size;
                statsEl.innerHTML = [
                    { label: 'Total Visits', val: entries.length, color: '#6ee7b7' },
                    { label: 'Unique Devices', val: devices.length, color: '#93c5fd' },
                    { label: 'Admins', val: admins, color: '#fbbf24' },
                    { label: 'Teachers', val: teachers, color: '#c4b5fd' },
                    { label: 'Students', val: students, color: '#6ee7b7' },
                ].map(s => `
                    <div style="background:rgba(30,41,59,0.6);border:1px solid var(--border);border-radius:8px;padding:8px 16px;min-width:100px;text-align:center">
                        <div style="font-size:22px;font-weight:700;color:${s.color}">${s.val}</div>
                        <div style="font-size:11px;color:var(--text-muted);margin-top:2px">${s.label}</div>
                    </div>`).join('');
            }

            const tbody = document.getElementById('deviceSummaryBody');
            if (!tbody) return;
            if (!devices.length) {
                tbody.innerHTML = '<tr><td colspan="11" class="text-center" style="padding:16px;color:var(--text-muted)">No devices found.</td></tr>';
                return;
            }
            // Sort: most recent first
            devices.sort((a, b) => (b.latest_ts || '').localeCompare(a.latest_ts || ''));
            tbody.innerHTML = devices.map((d, i) => {
                const ts = d.latest_ts ? _fmtTs(d.latest_ts) : '—';
                const roleColor = d.role === 'admin' ? '#fbbf24' : d.role === 'teacher' ? '#c4b5fd' : '#6ee7b7';
                const uuidShort = d.device_id ? d.device_id.substring(0, 8) + '…' : '—';
                return `<tr>
                    <td class="rank-cell">${i + 1}</td>
                    <td><strong>${_esc(d.device_name || '?')}</strong></td>
                    <td>${_esc(d.os || '—')}</td>
                    <td>${_esc(d.browser || '—')}</td>
                    <td style="font-size:12px">${_esc(d.screen || '—')}</td>
                    <td><strong>${_esc(d.login_id || '—')}</strong></td>
                    <td><span style="color:${roleColor};font-size:12px;font-weight:600">${_esc(d.role || '—')}</span></td>
                    <td style="font-size:12px;font-family:monospace">${_esc(d.ip || '—')}</td>
                    <td style="font-size:12px;white-space:nowrap">${ts}</td>
                    <td style="text-align:center">${d.visits}</td>
                    <td style="font-size:11px;font-family:monospace;color:var(--text-muted)"
                        title="${_esc(d.device_id || '')}">${uuidShort}</td>
                </tr>`;
            }).join('');
        }

        function _renderDeviceFullLog(entries) {
            const countEl = document.getElementById('deviceFullLogCount');
            if (countEl) countEl.textContent = `— ${entries.length} entries`;
            const tbody = document.getElementById('deviceFullLogBody');
            if (!tbody) return;
            if (!entries.length) {
                tbody.innerHTML = '<tr><td colspan="11" class="text-center" style="padding:12px;color:var(--text-muted)">No entries.</td></tr>';
                return;
            }
            // Show last 200 (most recent first)
            const slice = [...entries].reverse().slice(0, 200);
            tbody.innerHTML = slice.map((e, i) => {
                const roleColor = e.role === 'admin' ? '#fbbf24' : e.role === 'teacher' ? '#c4b5fd' : '#6ee7b7';
                const eventColor = e.event === 'login' ? '#6ee7b7' : '#93c5fd';
                return `<tr>
                    <td class="rank-cell" style="color:var(--text-muted)">${i + 1}</td>
                    <td style="font-size:12px;white-space:nowrap">${_fmtTs(e.ts)}</td>
                    <td><strong>${_esc(e.login_id || '—')}</strong></td>
                    <td><span style="color:${roleColor};font-size:12px;font-weight:600">${_esc(e.role || '—')}</span></td>
                    <td><span style="color:${eventColor};font-size:11px">${_esc(e.event || '—')}</span></td>
                    <td>${_esc(e.device_name || '—')}</td>
                    <td>${_esc(e.os || '—')}</td>
                    <td>${_esc(e.browser || '—')}</td>
                    <td style="font-size:12px">${_esc(e.screen || '—')}</td>
                    <td style="font-size:12px;font-family:monospace">${_esc(e.ip || '—')}</td>
                    <td style="font-size:11px;font-family:monospace;color:var(--text-muted)">${_esc(e.device_id || '—')}</td>
                </tr>`;
            }).join('');
        }

        function _fmtTs(isoStr) {
            if (!isoStr) return '—';
            try {
                return new Date(isoStr).toLocaleString('en-IN', {
                    timeZone: serverTimezone || 'Asia/Kolkata',
                    day: '2-digit', month: 'short', year: 'numeric',
                    hour: '2-digit', minute: '2-digit', second: '2-digit'
                });
            } catch { return isoStr; }
        }

        function _esc(s) {
            return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
        }

        function exportDeviceLog(format) {
            const entries = _deviceLogCache;
            if (!entries.length) { showToast('No data to export. Click Refresh first.', 'warning'); return; }
            let content, mime, ext;
            if (format === 'json') {
                content = JSON.stringify(entries, null, 2);
                mime = 'application/json';
                ext = 'json';
            } else {
                // CSV
                const headers = ['timestamp_utc','login_id','role','event','device_name','os','browser','screen','ip','device_uuid'];
                const rows = entries.map(e => headers.map(h => {
                    const val = (h === 'device_uuid' ? e.device_id : e[h === 'timestamp_utc' ? 'ts' : h]) || '';
                    return '"' + String(val).replace(/"/g, '""') + '"';
                }).join(','));
                content = [headers.join(','), ...rows].join('\r\n');
                mime = 'text/csv';
                ext = 'csv';
            }
            const blob = new Blob([content], { type: mime });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `ea_device_log_${formatDateKey(new Date())}.${ext}`;
            a.click();
            URL.revokeObjectURL(url);
            showToast(`Device log exported as ${ext.toUpperCase()}.`, 'success');
        }

        async function clearDeviceLog() {
            if (!confirm('Clear the entire device connection log? This cannot be undone.')) return;
            try {
                const resp = await fetch('/scoreboard/device-log/clear', {
                    method: 'POST', credentials: 'include',
                    headers: { 'Content-Type': 'application/json' }
                });
                if (!resp.ok) { showToast('Failed to clear log.', 'danger'); return; }
                _deviceLogCache = [];
                filterDeviceLog();
                showToast('Device log cleared.', 'success');
            } catch (e) {
                showToast('Error: ' + e.message, 'danger');
            }
        }
        // ══════════════════════════════════════════════════════════════════════

        function backupData() {
            const data = db.getData();
            const backup = {
                timestamp: new Date().toISOString(),
                data
            };
            console.log('Backup:', backup);
            showAlert('Backup created: ' + backup.timestamp, 'success');
        }

        // ==========================================
        // GOOD CONDUCT BADGE
        // ==========================================
        // Formula:
        //   1. Attendance rate >= 75% across all months with data
        //   2. Average monthly score >= 0 (net positive across all months)
        //   3. No single month score below -100
        //   4. Total VETO usage <= 1
        //   5. Student must be active
        //
        // Attendance rate = (total present + late days) / (total recorded days) * 100
        // Monthly score = sum of points + attendance penalties for each month

        function computeGoodConductData() {
            const students = db.getStudents().filter(s => s.active !== false);
            const months = db.getMonths();
            if (!months.length) return [];

            const allAttendance = db.getAttendance();
            const allScores = (db.getData() || {}).scores || [];

            // Build per-student attendance map: { studentId -> { date -> latestRecord } }
            const attendanceByStudent = new Map();
            allAttendance.forEach(record => {
                if (!record || !record.studentId || !record.date) return;
                const sid = parseInt(record.studentId, 10);
                const date = String(record.date || '').trim();
                if (!sid || !date) return;
                if (!attendanceByStudent.has(sid)) attendanceByStudent.set(sid, new Map());
                const studentMap = attendanceByStudent.get(sid);
                const prev = studentMap.get(date);
                const prevStamp = Date.parse(safeProp(prev, 'updated_at') || safeProp(prev, 'created_at') || '') || 0;
                const nextStamp = Date.parse(safeProp(record, 'updated_at') || safeProp(record, 'created_at') || '') || 0;
                if (!prev || nextStamp >= prevStamp) {
                    studentMap.set(date, record);
                }
            });

            // Build per-student, per-month score totals
            const scoresByStudentMonth = new Map();
            allScores.forEach(score => {
                if (!score || !score.studentId) return;
                const sid = parseInt(score.studentId, 10);
                const month = String(score.month || (score.date ? String(score.date).slice(0, 7) : '') || '').trim();
                if (!sid || !month) return;
                const key = `${sid}|${month}`;
                scoresByStudentMonth.set(key, (scoresByStudentMonth.get(key) || 0) + (parseInt(score.points, 10) || 0));
            });

            // Build per-student total VETO usage (negative vetos across all scores)
            const vetoUsageByStudent = new Map();
            allScores.forEach(score => {
                if (!score || !score.studentId) return;
                const sid = parseInt(score.studentId, 10);
                const vetos = parseInt(score.vetos, 10) || 0;
                if (vetos < 0) {
                    vetoUsageByStudent.set(sid, (vetoUsageByStudent.get(sid) || 0) + Math.abs(vetos));
                }
            });

            return students.map(student => {
                const sid = student.id;

                // Attendance: count present/late vs total recorded days
                const studentAttMap = attendanceByStudent.get(sid);
                let totalDays = 0;
                let presentDays = 0;
                if (studentAttMap) {
                    studentAttMap.forEach(record => {
                        totalDays++;
                        const status = normalizeAttendanceStatus(record.status);
                        if (status === 'present' || status === 'late') {
                            presentDays++;
                        }
                    });
                }
                const attendanceRate = totalDays > 0 ? Math.round((presentDays / totalDays) * 100) : null;

                // Monthly scores
                const monthScores = [];
                months.forEach(month => {
                    const key = `${sid}|${month}`;
                    const penalty = getAttendancePenaltyByDateForMonth(month).get(sid);
                    const penaltyTotal = penalty ? Object.values(penalty).reduce((s, v) => s + (parseInt(v, 10) || 0), 0) : 0;
                    const rawScore = scoresByStudentMonth.get(key) || 0;
                    monthScores.push(rawScore + penaltyTotal);
                });

                const monthCount = monthScores.length;
                const totalScore = monthScores.reduce((s, v) => s + v, 0);
                const avgScore = monthCount > 0 ? Math.round(totalScore / monthCount) : 0;
                const lowestMonth = monthCount > 0 ? Math.min(...monthScores) : 0;
                const vetoUsage = vetoUsageByStudent.get(sid) || 0;

                // Eligibility checks
                const attendanceOk = attendanceRate !== null && attendanceRate >= 75;
                const avgScoreOk = avgScore >= 0;
                const noDeepNegative = lowestMonth >= -100;
                const vetoOk = vetoUsage <= 1;
                const eligible = attendanceOk && avgScoreOk && noDeepNegative && vetoOk;

                // Build failure reasons
                const reasons = [];
                if (attendanceRate === null) reasons.push('No attendance data');
                else if (!attendanceOk) reasons.push(`Attendance ${attendanceRate}% < 75%`);
                if (!avgScoreOk) reasons.push(`Avg score ${avgScore} < 0`);
                if (!noDeepNegative) reasons.push(`Month low ${lowestMonth} < −100`);
                if (!vetoOk) reasons.push(`VETOs used: ${vetoUsage} > 1`);

                return {
                    student,
                    attendanceRate,
                    avgScore,
                    monthCount,
                    vetoUsage,
                    lowestMonth,
                    eligible,
                    reasons
                };
            }).sort((a, b) => {
                // Eligible first, then by attendance rate desc, then avg score desc
                if (a.eligible !== b.eligible) return a.eligible ? -1 : 1;
                if ((a.attendanceRate || 0) !== (b.attendanceRate || 0)) return (b.attendanceRate || 0) - (a.attendanceRate || 0);
                return b.avgScore - a.avgScore;
            });
        }

        function renderGoodConductBadge() {
            const tbody = document.getElementById('goodConductBody');
            if (!tbody) return;
            const filter = String(getElementValue('goodConductFilter') || 'eligible').trim();
            const data = computeGoodConductData();
            const filtered = filter === 'eligible' ? data.filter(r => r.eligible) : data;

            if (!filtered.length) {
                tbody.innerHTML = `<tr><td colspan="10" class="text-center" style="padding: 30px; color: var(--text-muted);">${
                    filter === 'eligible' ? 'No students currently eligible for the Good Conduct Badge.' : 'No active students found.'
                }</td></tr>`;
                return;
            }

            tbody.innerHTML = filtered.map((row, idx) => {
                const s = row.student;
                const badgeClass = row.eligible ? 'star-used-green' : '';
                const badgeLabel = row.eligible
                    ? '<span style="color: #6ee7b7; font-weight: 700;">&#x2713; Eligible</span>'
                    : `<span style="color: #f87171; font-size: 12px;" title="${escapeHtml(row.reasons.join('; '))}">&times; ${escapeHtml(row.reasons[0] || 'Not eligible')}</span>`;
                return `
                    <tr class="${row.eligible ? 'score-recorded-row' : ''}">
                        <td>${idx + 1}</td>
                        <td>${formatRollDisplay(s.roll)}</td>
                        <td>${renderStudentName(s)}</td>
                        <td>${getStudentGroup(s) || '-'}</td>
                        <td style="font-family: var(--number-font); ${row.attendanceRate !== null && row.attendanceRate < 75 ? 'color: #f87171;' : ''}">${row.attendanceRate !== null ? row.attendanceRate + '%' : '-'}</td>
                        <td style="font-family: var(--number-font); ${row.avgScore < 0 ? 'color: #f87171;' : ''}">${row.avgScore}</td>
                        <td style="font-family: var(--number-font);">${row.monthCount}</td>
                        <td style="font-family: var(--number-font); ${row.vetoUsage > 1 ? 'color: #f87171;' : ''}">${row.vetoUsage}</td>
                        <td style="font-family: var(--number-font); ${row.lowestMonth < -100 ? 'color: #f87171;' : ''}">${row.lowestMonth}</td>
                        <td class="${badgeClass}">${badgeLabel}</td>
                    </tr>
                `;
            }).join('');
        }

        let restorePointsCache = [];

        async function loadRestorePoints() {
            if (currentUserRole !== 'admin') return;
            const select = document.getElementById('restorePointSelect');
            const preview = document.getElementById('restorePreview');
            if (!select) return;
            try {
                const res = await fetch('/scoreboard/offline-restore-points', { credentials: 'same-origin' });
                const payload = await res.json();
                if (!res.ok || !payload.success) {
                    throw new Error(payload.error || 'Failed to load restore points');
                }
                const items = Array.isArray(payload.items) ? payload.items : [];
                restorePointsCache = items;
                select.innerHTML = items.map(item => {
                    const when = new Date(item.modified_at).toLocaleString();
                    const lockTag = item.locked ? '[LOCKED]' : '';
                    const labelTag = item.label ? ` {${escapeHtml(item.label)}}` : '';
                    return `<option value="${item.id}">${lockTag} [${item.source}] ${item.name}${labelTag} | ${when}</option>`;
                }).join('');
                if (!items.length) {
                    select.innerHTML = '<option value="">No restore points found</option>';
                }
                if (preview) preview.textContent = `Found ${items.length} restore points.`;
            } catch (err) {
                showAlert(`Restore list error: ${err.message}`, 'danger');
            }
        }

        async function previewRestorePoint() {
            const select = document.getElementById('restorePointSelect');
            const preview = document.getElementById('restorePreview');
            if (!select || !preview) return;
            const value = select.value;
            if (!value) {
                preview.textContent = 'Select a restore point.';
                return;
            }
            const item = (restorePointsCache || []).find(i => i.id === value);
            if (!item) {
                preview.textContent = `Selected restore id:\n${value}`;
                return;
            }
            preview.textContent = [
                `Selected: ${item.name}`,
                `Source: ${item.source}`,
                `Modified: ${new Date(item.modified_at).toLocaleString()}`,
                `Size: ${(Number(item.size || 0) / 1024).toFixed(1)} KB`,
                `Locked: ${item.locked ? 'Yes' : 'No'}`,
                `Label: ${item.label || '-'}`,
                '',
                `Restore ID: ${item.id}`,
                'A safety backup will be created before apply.'
            ].join('\n');
        }

        async function toggleRestorePointLock(lockState) {
            if (currentUserRole !== 'admin') {
                showAlert('Only Admin can lock restore points.', 'warning');
                return;
            }
            const select = document.getElementById('restorePointSelect');
            if (!select || !select.value) {
                showAlert('Select a restore point first.', 'warning');
                return;
            }
            let label = '';
            if (lockState) {
                label = prompt('Enter label for this restore point (e.g. Stable Feb 13 21:00):', '') || '';
            }
            try {
                const res = await fetch('/scoreboard/offline-restore-point-lock', {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: select.value, locked: lockState, label })
                });
                const payload = await res.json();
                if (!res.ok || !payload.success) {
                    throw new Error(payload.error || 'Lock update failed');
                }
                showAlert(lockState ? 'Restore point locked.' : 'Restore point unlocked.', 'success');
                await loadRestorePoints();
            } catch (err) {
                showAlert(`Lock error: ${err.message}`, 'danger');
            }
        }

        async function applyRestorePoint() {
            if (currentUserRole !== 'admin') {
                showAlert('Only Admin can restore backups.', 'warning');
                return;
            }
            const select = document.getElementById('restorePointSelect');
            if (!select || !select.value) {
                showAlert('Select a restore point first.', 'warning');
                return;
            }
            if (!confirm(`Restore selected backup?\n\n${select.value}\n\nA safety backup will be created automatically.`)) {
                return;
            }
            try {
                const res = await fetch('/scoreboard/offline-restore', {
                    method: 'POST',
                    credentials: 'same-origin',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ id: select.value })
                });
                const payload = await res.json();
                if (!res.ok || !payload.success) {
                    throw new Error(payload.error || 'Restore failed');
                }
                showAlert(`Restore applied. Students: ${payload.students}, Scores: ${payload.scores}`, 'success');
                await pullFromServer(true, true);
                loadScoreboard();
                loadStudents();
                loadRestorePoints();
            } catch (err) {
                showAlert(`Restore error: ${err.message}`, 'danger');
            }
        }

        function showStats() {
            const data = db.getData();
            const stats = `
                Total Students: ${data.students.length}
                Total Scores Recorded: ${data.scores.length}
                Months with Data: ${db.getMonths().length}
                Parties: ${(data.parties || []).length}
                Leadership Posts: ${(data.leadership || []).length}
                Storage Used: ~${(JSON.stringify(data).length / 1024).toFixed(2)} KB
            `;
            alert(stats);
        }

        function clearAllData() {
            if (confirm('WARNING: This will delete all data! Are you sure?')) {
                db.clearAll();
                showAlert('All data cleared', 'success');
                loadScoreboard();
            }
        }

        async function loadFeb26Seed() {
            if (!confirm('This will replace current data with Feb 26 sheet data. Continue?')) {
                return;
            }
            const seedData = await getFeb26Seed();
            const existing = db.getData();
            const seed = cloneSeed(seedData || {});
            seed.students = seed.students.map(student => normalizeStudentMeta({ ...student, active: true, group: deriveGroupFromRoll(student.roll) }));
            seed.parties = seed.parties.map((party, idx) => ({ id: idx + 1, ...party, members: [] }));
            seed.leadership = seed.leadership.map((post, idx) => ({ id: idx + 1, ...post }));

            db.saveData({
                students: seed.students,
                scores: seed.scores,
                months: [],
                month_students: seed.month_students || {},
                month_roster_profiles: { '2026-02': toRosterProfiles(FEB26_STUDENT_ROSTER) },
                parties: seed.parties,
                leadership: seed.leadership,
                class_reps: [],
                election_candidates: [],
                election_votes: [],
                election_individual_votes: [],
                post_holder_history: existing.post_holder_history || [],
                notification_history: existing.notification_history || [],
                appeals: existing.appeals || [],
                attendance: existing.attendance || [],
                fee_records: existing.fee_records || [],
                homework: existing.homework || []
            });
            db.ensureSchema();
            showAlert('Feb 26 data loaded successfully!', 'success');
            loadScoreboard();
            loadStudents();
            loadParties();
            loadLeadership();
        }

        // ── iOS table-row stagger ─────────────────────────────────────────────
        // Call after any table render to play the staggered row entrance.
        // Auto-removes the class after animation completes so the rows are
        // not permanently animated (which would cause repaints on every scroll).
        function _animateTableRows(tableId) {
            const tbl = document.getElementById(tableId);
            if (!tbl) return;
            if ((window.__EA_SUPPRESS_TABLE_ANIM_UNTIL || 0) > Date.now()) {
                tbl.classList.remove('ios-rows-animate');
                return;
            }
            const rows = tbl.querySelectorAll('tbody tr');
            const totalRows = rows.length;
            if (!totalRows) {
                tbl.classList.remove('ios-rows-animate');
                return;
            }
            // Ultra-smooth mode: avoid animating huge tables, and cap stagger length.
            const animatedRows = totalRows > 90 ? 0 : Math.min(totalRows, 24);
            tbl.classList.remove('ios-rows-animate');
            if (animatedRows <= 0) return;
            requestAnimationFrame(() => {
                tbl.classList.add('ios-rows-animate');
                const target = rows[animatedRows - 1] || rows[totalRows - 1];
                const clearAnim = () => tbl.classList.remove('ios-rows-animate');
                if (target) {
                    target.addEventListener('animationend', clearAnim, { once: true });
                    setTimeout(clearAnim, 420);
                } else {
                    setTimeout(clearAnim, 300);
                }
            });
        }

        function openModal(modalId) {
            const modal = document.getElementById(modalId);
            if (!modal) return;
            // Ensure entrance animation replays on every open
            const content = modal.querySelector('.modal-content');
            if (content) { content.style.animation = 'none'; void content.offsetWidth; content.style.animation = ''; }
            modal.classList.remove('modal-exiting');
            modal.classList.add('active');
        }

        function closeModal(modalId = 'detailsModal') {
            const modal = document.getElementById(modalId);
            if (!modal) return;
            const content = modal.querySelector('.modal-content');
            if (content) {
                // Play exit animation, then hide
                modal.classList.add('modal-exiting');
                setTimeout(() => {
                    modal.classList.remove('active', 'modal-exiting');
                    content.style.animation = '';
                    modal.dispatchEvent(new Event('_modalClosed'));
                }, 145);
            } else {
                modal.classList.remove('active');
                modal.dispatchEvent(new Event('_modalClosed'));
            }
        }

        // ── Undo stack ──────────────────────────────────────────────────────────────
        // pushUndoSnapshot(label) — call BEFORE a destructive admin action to capture
        //   a full data snapshot that can be restored with Ctrl+Z (or the Undo button).
        // popUndo() — restores the most recent snapshot and refreshes the active tab.
        function pushUndoSnapshot(label) {
            if (currentUserRole !== 'admin') return;
            try {
                const snapshot = JSON.stringify(db.getData());
                _undoStack.push({ label: String(label || 'Action'), snapshot, ts: Date.now() });
                if (_undoStack.length > _MAX_UNDO_STEPS) _undoStack.shift();
            } catch (e) { /* snapshot failure is silent — undo just won't be available */ }
        }

        function popUndo() {
            if (!_undoStack.length) {
                showAlert('Nothing to undo.', 'info');
                return;
            }
            const entry = _undoStack.pop();
            try {
                const data = JSON.parse(entry.snapshot);
                db.saveData(data, { system: false });
                // Refresh the currently active tab so the rollback is visible immediately.
                const activeBtn = document.querySelector('.tab-button.active');
                if (activeBtn) {
                    const m = (activeBtn.getAttribute('onclick') || '').match(/switchTab\(['"]([^'"]+)['"]/);
                    if (m) switchTab(m[1]);
                }
                showAlert('Undo: "' + entry.label + '" reversed.', 'success');
            } catch (e) {
                showAlert('Undo failed — snapshot was unreadable.', 'danger');
            }
        }

        // Ctrl+Z anywhere in the page (excluding text inputs) triggers undo.
        document.addEventListener('keydown', (e) => {
            if (!(e.ctrlKey || e.metaKey) || e.key !== 'z' || e.shiftKey) return;
            const tag = (document.activeElement && document.activeElement.tagName || '').toLowerCase();
            if (tag === 'input' || tag === 'textarea' || tag === 'select') return;
            e.preventDefault();
            popUndo();
        });

        // ── Skeleton loader helper ───────────────────────────────────────────────────
        // Shows animated shimmer placeholder rows in a table tbody while data loads.
        function _showTableSkeleton(tbodyId, cols, rows) {
            const tbody = document.getElementById(tbodyId);
            if (!tbody) return;
            const c = cols || 6;
            const r = rows || 4;
            const cells = Array(c).fill('<td>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</td>').join('');
            tbody.innerHTML = Array(r).fill('<tr class="skeleton-row">' + cells + '</tr>').join('');
        }

        // ── Optimistic button helper ─────────────────────────────────────────────────
        // Disables a button and shows '...' while an async action runs.
        // Returns a restore function: call it when the action finishes.
        function _btnSetLoading(btn) {
            if (!btn) return () => {};
            const orig = btn.textContent;
            btn.disabled = true;
            btn.textContent = '...';
            return function restore() {
                btn.textContent = orig;
                btn.disabled = false;
            };
        }

        function showAlert(message, type = 'info') {
            const container = document.getElementById('alertContainer');
            const alertId = 'alert-' + Date.now();
            const html = `
                <div class="alert alert-${type}" id="${alertId}">
                    <i class="fas fa-${type === 'success' ? 'check-circle' : type === 'danger' ? 'exclamation-circle' : 'info-circle'}"></i>
                    <span>${message}</span>
                </div>
            `;
            container.insertAdjacentHTML('beforeend', html);
            
            setTimeout(() => {
                const element = document.getElementById(alertId);
                if (element) element.remove();
            }, 4000);
        }

        /* VALIDATION MODAL FUNCTIONS */
        function showValidationModal(title, message) {
            const modal = document.getElementById('validationModal');
            const titleEl = document.getElementById('validationTitle');
            const messageEl = document.getElementById('validationMessage');
            if (titleEl) titleEl.textContent = title;
            if (messageEl) messageEl.innerHTML = message;
            if (modal) modal.classList.remove('hidden');
        }

        function closeValidationModal() {
            const modal = document.getElementById('validationModal');
            if (modal) modal.classList.add('hidden');
        }

        /* CONFIRM MODAL FUNCTIONS (Resources) */
        let _confirmModalResolver = null;
        function openConfirmModal(title, htmlBody) {
            const modal = document.getElementById('confirmModal');
            const titleEl = document.getElementById('confirmTitle');
            const bodyEl = document.getElementById('confirmBody');
            if (titleEl) titleEl.textContent = String(title || 'Confirm');
            if (bodyEl) bodyEl.innerHTML = htmlBody || '';
            if (modal) modal.classList.remove('hidden');
            return new Promise((resolve) => {
                _confirmModalResolver = resolve;
            });
        }

        function closeConfirmModal(confirmed) {
            const modal = document.getElementById('confirmModal');
            if (modal) modal.classList.add('hidden');
            if (typeof _confirmModalResolver === 'function') {
                const resolver = _confirmModalResolver;
                _confirmModalResolver = null;
                resolver(Boolean(confirmed));
            }
        }

        /* STAR/VETO VALIDATION & COUNTER UPDATE */
        function validateStarAvailability(studentId, requestedStars) {
            const student = db.getStudents().find(s => s.id === studentId);
            if (!student) return { valid: false, message: 'Student not found.' };
            const availableStars = parseInt(safeProp(student, 'stars'), 10) || 0;
            if (requestedStars < 0 && availableStars < Math.abs(requestedStars)) {
                return {
                    valid: false,
                    message: `Cannot use/remove ${Math.abs(requestedStars)} star(s).<br>Student currently has ${availableStars} star(s).`
                };
            }
            return { valid: true };
        }

        function validateVetoAvailability(studentId, requestedVetos) {
            const student = db.getStudents().find(s => s.id === studentId);
            if (!student) return { valid: false, message: 'Student not found.' };
            const availableVetos = parseInt(safeProp(student, 'veto_count'), 10) || 0;
            if (requestedVetos < 0 && availableVetos < Math.abs(requestedVetos)) {
                return {
                    valid: false,
                    message: `Cannot use/remove ${Math.abs(requestedVetos)} VETO(s).<br>Student currently has ${availableVetos} VETO(s).`
                };
            }
            return { valid: true };
        }

        function updateStudentStarCounter(studentId, delta) {
            const student = db.getStudents().find(s => s.id === studentId);
            if (!student) return false;
            const currentStars = parseInt(safeProp(student, 'stars'), 10) || 0;
            const newStars = Math.max(0, currentStars + delta);
            student.stars = newStars;
            return true;
        }

        // VETO counters removed by request.

        /* POST HOLDER & ROLE DETECTION */
        function isPostHolder(studentId, month = null) {
            const leadership = db.getLeadership() || [];
            return leadership.some(post => parseInt(post.studentId, 10) === studentId);
        }

        function getLeadershipPost(studentId) {
            const leadership = db.getLeadership() || [];
            return leadership.find(post => parseInt(post.studentId, 10) === studentId);
        }

        function getPostHolderType(studentId) {
            const post = getLeadershipPost(studentId);
            if (!post) return null;
            const postName = String(post.post || '').toUpperCase();
            if (postName.includes('LEADER') || postName.includes('LoP') || postName.includes('CO-LEADER')) {
                return 'major'; // Affects everyone
            }
            return 'minor'; // Affects group or partial students
        }

        function isVetoUser(studentId) {
            return isPostHolder(studentId);
        }

        /* VETO LOGIC FUNCTIONS */
        function applyVetoMarking(studentId, date, isPostHolderVeto = false) {
            // Apply veto marking to current date + next 6 days (7 cells total)
            // All marked cells turn blue with 'V' in current cell
            const startDate = new Date(date);
            const vetoMarkedDates = [];
            
            for (let i = 0; i < 7; i++) {
                const markedDate = new Date(startDate);
                markedDate.setDate(markedDate.getDate() + i);
                const markedDateStr = markedDate.toISOString().split('T')[0];
                vetoMarkedDates.push(markedDateStr);
                
                // Mark in score notes for tracking
                const existingScore = db.getScore(studentId, markedDateStr);
                const month = markedDateStr.substring(0, 7);
                if (existingScore) {
                    existingScore.notes = (existingScore.notes || '') + ` [VETO-${String(date).substring(5)}]`;
                } else {
                    db.addScore({
                        studentId,
                        date: markedDateStr,
                        points: 0,
                        stars: 0,
                        vetos: 0,
                        month: month,
                        notes: `[VETO-${String(date).substring(5)}]`,
                        recordedBy: currentUserRole
                    });
                }
            }
            
            return vetoMarkedDates;
        }

        function checkForCounterVeto(studentId, date) {
            // Check if another student used VETO on same date to cancel this VETO
            const month = date.substring(0, 7);
            const scores = db.getScoresForMonth(month) || [];
            
            const vetoesOnDate = scores.filter(s => {
                return s.date === date && 
                       s.studentId !== studentId && 
                       s.vetos > 0 &&
                       (s.notes || '').includes('VETO');
            });
            
            return vetoesOnDate.length > 0;
        }

        function undoVetoMarking(studentId, date) {
            // Remove VETO markings from 7 days starting from date
            const startDate = new Date(date);
            
            for (let i = 0; i < 7; i++) {
                const markedDate = new Date(startDate);
                markedDate.setDate(markedDate.getDate() + i);
                const markedDateStr = markedDate.toISOString().split('T')[0];
                
                const score = db.getScore(studentId, markedDateStr);
                if (score && score.notes) {
                    score.notes = score.notes.replace(` [VETO-${String(date).substring(5)}]`, '');
                }
            }
        }

        function askPostHolderVetoRole(studentId, callback) {
            // Ask post holder if using VETO as Individual or as Post Holder
            const post = getLeadershipPost(studentId);
            if (!post) {
                callback('individual');
                return;
            }
            
            const postType = getPostHolderType(studentId);
            const prompt = postType === 'major'
                ? `Post Holder "${post.post}" - Use VETO as:\n1. Individual (affects only own dates)\n2. Post Holder (affects entire group)`
                : `Post Holder "${post.post}" - Use VETO as:\n1. Individual (affects only own dates)\n2. Post Holder (affects your group)`;
            
            // For simplicity in this implementation, default to individual
            // In a full UI, this would be a modal with radio buttons
            callback('individual');
        }

        function applyPostHolderVeto(studentId, date, vetoType) {
            // If major post holder, apply to all students
            // If CR or minor post holder, apply to group
            // For now, store this in score notes for tracking
            const score = db.getScore(studentId, date);
            if (score) {
                score.notes = (score.notes || '') + ` [${vetoType.toUpperCase()}-VETO]`;
            }
        }

        // Initialize on load
        document.addEventListener('DOMContentLoaded', async () => {
            ensureDefaultServerEndpoints();
            applyColumnVisibility();
            populateServerEndpointInputs();
            refreshServerHealth();
            setInterval(() => {
                if (document.hidden) return;
                if (getActiveTabName() !== 'tools') return;
                refreshServerHealth();
            }, 30000);

            if (SERVER_SYNC.enabled) {
                await loadSessionContext(3);
                checkinDevice('login'); // fire-and-forget: log this device/session
            }
            updateRoleBadge();
            applyRolePermissions();
            if (currentUserRole === 'admin') {
                reconcileApprovedElectionOutcomes();
                reconcilePendingElectionApprovals();
                syncPostHolderHistory({ persist: false });
            }
            if (currentUserRole === 'admin' || currentUserRole === 'teacher') {
                applyMonthlyRoleVetoGrants({ persist: false });
            }
            updateAppealsTabNotification();
            updateHomeworkTabNotification();
            const activeRosterMonthInput = document.getElementById('activeRosterMonth');
            if (activeRosterMonthInput && !activeRosterMonthInput.value) {
                activeRosterMonthInput.value = getCurrentMonthKey();
            }

            if (SERVER_SYNC.enabled) {
                updateSyncStatus('syncing', 'Connecting');
                // forceFull=true on initial load: skip ?since so every page refresh always
                // fetches a fresh full snapshot — prevents stale data after ?since 204 responses.
                pullFromServer(false, true).catch(() => {});
                if (ENABLE_REALTIME_SYNC) {
                    startRealtimeSync();
                }
                setInterval(() => {
                    if (document.hidden) return;
                    if (isMobileViewport() && getActiveTabName() === 'add-score') return;
                    if (hasActiveRecordScoreEdit() || hasActiveAttendanceEdit()) return;
                    // Pull-only background sync. Push uses explicit Master Update.
                    schedulePullFromServer(false, 0, currentUserRole === 'teacher' || currentUserRole === 'student');
                }, AUTO_SYNC_INTERVAL_MS);

                // Extra safety for WAN: pull immediately when the app regains focus or network.
                let lastFocusPullAt = 0;
                window.addEventListener('online', () => schedulePullFromServer(false, 0, currentUserRole === 'teacher' || currentUserRole === 'student'));
                window.addEventListener('offline', () => updateSyncStatus('offline', 'Offline'));
                document.addEventListener('visibilitychange', () => {
                    if (document.visibilityState !== 'visible') return;
                    const now = Date.now();
                    if (now - lastFocusPullAt < 1500) return;
                    lastFocusPullAt = now;
                    schedulePullFromServer(false, 120, currentUserRole === 'teacher' || currentUserRole === 'student');
                });

                // One-time admin safety: if local admin snapshot is clearly ahead of server,
                // publish it so teacher/student devices converge to the same tally.
                setTimeout(() => { maybeAutoPublishAdminSnapshot().catch(() => {}); }, 1500);
            } else {
                updateSyncStatus('offline', 'Local Only');
            }

            if ('serviceWorker' in navigator && SERVER_SYNC.enabled) {
                navigator.serviceWorker.register('/scoreboard/sw.js', { scope: '/scoreboard/' }).catch(() => {});
            }

            window.addEventListener('beforeinstallprompt', (event) => {
                event.preventDefault();
                installPromptEvent = event;
                const installBtn = document.getElementById('installAppBtn');
                if (installBtn) {
                    installBtn.style.display = 'inline-flex';
                }
            });

            window.addEventListener('beforeunload', () => {
                if (realtimeSyncSource) {
                    realtimeSyncSource.close();
                    realtimeSyncSource = null;
                }
            });

            const installBtn = document.getElementById('installAppBtn');
            if (installBtn) {
                installBtn.addEventListener('click', async () => {
                    if (!installPromptEvent) return;
                    installPromptEvent.prompt();
                    await installPromptEvent.userChoice;
                    installPromptEvent = null;
                    installBtn.style.display = 'none';
                });
            }

            restoreLastActiveTab();
            let resizeTimer = null;
            window.addEventListener('resize', () => {
                if (resizeTimer) clearTimeout(resizeTimer);
                resizeTimer = setTimeout(() => {
                    autoAdjustTableFonts();
                    syncScoreboardDualScrollbars();
                }, 120);
            });
        });
    
        // Clear localStorage on logout to prevent data persistence across users
        function clearUserDataOnLogout() {
            try {
                // Clear remembered profile for this browser
                clearProfileFromLocal();
                // Clear scoreboard-specific data
                const keysToRemove = [];
                for (let i = 0; i < localStorage.length; i++) {
                    const key = localStorage.key(i);
                    // Remove user-specific and cached data
                    if (key && (
                        key.includes('scoreboard') ||
                        key.includes('roster') ||
                        key.includes('backup') ||
                        key === 'ea_active_tab' ||
                        key === 'ea_active_scoreboard_month'
                    )) {
                        keysToRemove.push(key);
                    }
                }
                keysToRemove.forEach(key => localStorage.removeItem(key));
                console.log('localStorage cleared on logout (profile + data)');
            } catch (e) {
                console.error('Failed to clear localStorage:', e);
            }
        }

        // Attach to logout button if exists
        document.addEventListener('DOMContentLoaded', () => {
            const logoutBtn = document.querySelector('[href*="logout"]');
            if (logoutBtn) {
                logoutBtn.addEventListener('click', clearUserDataOnLogout);
            }

            // Scroll Performance Optimization - disable animations during scroll
            let scrollTimeout;
            let isScrolling = false;
            function onScroll() {
                if (!isScrolling) {
                    document.body.classList.add('scrolling');
                    isScrolling = true;
                }
                clearTimeout(scrollTimeout);
                scrollTimeout = setTimeout(() => {
                    document.body.classList.remove('scrolling');
                    isScrolling = false;
                }, 150);
            }
            window.addEventListener('scroll', onScroll, { passive: true });
        });

    </script>
</body>
</html>



